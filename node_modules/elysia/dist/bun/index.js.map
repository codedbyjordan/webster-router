{
  "version": 3,
  "sources": ["../../node_modules/eventemitter3/index.js", "../../node_modules/@sinclair/typebox/value/guard.js", "../../node_modules/@sinclair/typebox/typebox.js", "../../node_modules/@sinclair/typebox/system/system.js", "../../node_modules/@sinclair/typebox/value/deref.js", "../../node_modules/@sinclair/typebox/value/hash.js", "../../node_modules/@sinclair/typebox/errors/errors.js", "../../node_modules/@sinclair/typebox/errors/index.js", "../../node_modules/@sinclair/typebox/value/pointer.js", "../../node_modules/@sinclair/typebox/value/clone.js", "../../node_modules/@sinclair/typebox/value/delta.js", "../../node_modules/@sinclair/typebox/value/mutate.js", "../../node_modules/@sinclair/typebox/value/equal.js", "../../node_modules/@sinclair/typebox/system/index.js", "../../node_modules/@sinclair/typebox/value/check.js", "../../node_modules/@sinclair/typebox/value/create.js", "../../node_modules/@sinclair/typebox/value/cast.js", "../../node_modules/@sinclair/typebox/value/convert.js", "../../node_modules/@sinclair/typebox/value/transform.js", "../../node_modules/@sinclair/typebox/value/value.js", "../../node_modules/@sinclair/typebox/value/index.js", "../../node_modules/@sinclair/typebox/compiler/compiler.js", "../../node_modules/@sinclair/typebox/compiler/index.js", "../../node_modules/fast-decode-uri-component/index.js", "../../node_modules/fast-querystring/lib/parse.js", "../../node_modules/fast-querystring/lib/internals/querystring.js", "../../node_modules/fast-querystring/lib/stringify.js", "../../node_modules/fast-querystring/lib/index.js", "../../node_modules/memoirist/dist/index.js", "../../node_modules/eventemitter3/index.mjs", "../../node_modules/eventemitter3/index.mjs", "../../src/trace.ts", "../../src/error.ts", "../../src/ws/index.ts", "../../node_modules/cookie/index.js", "../../src/utils.ts", "../../src/utils.ts", "../../src/utils.ts", "../../src/cookie.ts", "../../src/handler.ts", "../../src/compose.ts", "../../src/compose.ts", "../../src/dynamic-handle.ts", "../../src/dynamic-handle.ts", "../../src/type-system.ts", "../../src/type-system.ts", "../../src/index.ts"],
  "sourcesContent": [
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IsValueType = exports.IsSymbol = exports.IsFunction = exports.IsString = exports.IsBigInt = exports.IsInteger = exports.IsNumber = exports.IsBoolean = exports.IsNull = exports.IsUndefined = exports.IsArray = exports.IsObject = exports.IsPlainObject = exports.HasPropertyKey = exports.IsDate = exports.IsUint8Array = exports.IsPromise = exports.IsTypedArray = exports.IsIterator = exports.IsAsyncIterator = void 0;\n// --------------------------------------------------------------------------\n// Iterators\n// --------------------------------------------------------------------------\n/** Returns true if this value is an async iterator */\nfunction IsAsyncIterator(value) {\n    return IsObject(value) && Symbol.asyncIterator in value;\n}\nexports.IsAsyncIterator = IsAsyncIterator;\n/** Returns true if this value is an iterator */\nfunction IsIterator(value) {\n    return IsObject(value) && Symbol.iterator in value;\n}\nexports.IsIterator = IsIterator;\n// --------------------------------------------------------------------------\n// Nominal\n// --------------------------------------------------------------------------\n/** Returns true if this value is a typed array */\nfunction IsTypedArray(value) {\n    return ArrayBuffer.isView(value);\n}\nexports.IsTypedArray = IsTypedArray;\n/** Returns true if this value is a Promise */\nfunction IsPromise(value) {\n    return value instanceof Promise;\n}\nexports.IsPromise = IsPromise;\n/** Returns true if the value is a Uint8Array */\nfunction IsUint8Array(value) {\n    return value instanceof Uint8Array;\n}\nexports.IsUint8Array = IsUint8Array;\n/** Returns true if this value is a Date */\nfunction IsDate(value) {\n    return value instanceof Date && Number.isFinite(value.getTime());\n}\nexports.IsDate = IsDate;\n// --------------------------------------------------------------------------\n// Standard\n// --------------------------------------------------------------------------\n/** Returns true if this value has this property key */\nfunction HasPropertyKey(value, key) {\n    return key in value;\n}\nexports.HasPropertyKey = HasPropertyKey;\n/** Returns true if this object is not an instance of any other type */\nfunction IsPlainObject(value) {\n    return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === 'Object';\n}\nexports.IsPlainObject = IsPlainObject;\n/** Returns true of this value is an object type */\nfunction IsObject(value) {\n    return value !== null && typeof value === 'object';\n}\nexports.IsObject = IsObject;\n/** Returns true if this value is an array, but not a typed array */\nfunction IsArray(value) {\n    return Array.isArray(value) && !ArrayBuffer.isView(value);\n}\nexports.IsArray = IsArray;\n/** Returns true if this value is an undefined */\nfunction IsUndefined(value) {\n    return value === undefined;\n}\nexports.IsUndefined = IsUndefined;\n/** Returns true if this value is an null */\nfunction IsNull(value) {\n    return value === null;\n}\nexports.IsNull = IsNull;\n/** Returns true if this value is an boolean */\nfunction IsBoolean(value) {\n    return typeof value === 'boolean';\n}\nexports.IsBoolean = IsBoolean;\n/** Returns true if this value is an number */\nfunction IsNumber(value) {\n    return typeof value === 'number';\n}\nexports.IsNumber = IsNumber;\n/** Returns true if this value is an integer */\nfunction IsInteger(value) {\n    return IsNumber(value) && Number.isInteger(value);\n}\nexports.IsInteger = IsInteger;\n/** Returns true if this value is bigint */\nfunction IsBigInt(value) {\n    return typeof value === 'bigint';\n}\nexports.IsBigInt = IsBigInt;\n/** Returns true if this value is string */\nfunction IsString(value) {\n    return typeof value === 'string';\n}\nexports.IsString = IsString;\n/** Returns true if this value is a function */\nfunction IsFunction(value) {\n    return typeof value === 'function';\n}\nexports.IsFunction = IsFunction;\n/** Returns true if this value is a symbol */\nfunction IsSymbol(value) {\n    return typeof value === 'symbol';\n}\nexports.IsSymbol = IsSymbol;\n/** Returns true if this value is a value type such as number, string, boolean */\nfunction IsValueType(value) {\n    // prettier-ignore\n    return (IsBigInt(value) ||\n        IsBoolean(value) ||\n        IsNull(value) ||\n        IsNumber(value) ||\n        IsString(value) ||\n        IsSymbol(value) ||\n        IsUndefined(value));\n}\nexports.IsValueType = IsValueType;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Transform = Symbol.for('TypeBox.Transform');\nexports.Readonly = Symbol.for('TypeBox.Readonly');\nexports.Optional = Symbol.for('TypeBox.Optional');\nexports.Hint = Symbol.for('TypeBox.Hint');\nexports.Kind = Symbol.for('TypeBox.Kind');\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = '(true|false)';\nexports.PatternNumber = '(0|[1-9][0-9]*)';\nexports.PatternString = '(.*)';\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */\nvar TypeRegistry;\n(function (TypeRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    TypeRegistry.Entries = Entries;\n    /** Clears all user defined types */\n    function Clear() {\n        return map.clear();\n    }\n    TypeRegistry.Clear = Clear;\n    /** Deletes a registered type */\n    function Delete(kind) {\n        return map.delete(kind);\n    }\n    TypeRegistry.Delete = Delete;\n    /** Returns true if this registry contains this kind */\n    function Has(kind) {\n        return map.has(kind);\n    }\n    TypeRegistry.Has = Has;\n    /** Sets a validation function for a user defined type */\n    function Set(kind, func) {\n        map.set(kind, func);\n    }\n    TypeRegistry.Set = Set;\n    /** Gets a custom validation function for a user defined type */\n    function Get(kind) {\n        return map.get(kind);\n    }\n    TypeRegistry.Get = Get;\n})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeBoxError\n// --------------------------------------------------------------------------\nclass TypeBoxError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nexports.TypeBoxError = TypeBoxError;\n/** A registry for user defined string formats */\nvar FormatRegistry;\n(function (FormatRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    FormatRegistry.Entries = Entries;\n    /** Clears all user defined string formats */\n    function Clear() {\n        return map.clear();\n    }\n    FormatRegistry.Clear = Clear;\n    /** Deletes a registered format */\n    function Delete(format) {\n        return map.delete(format);\n    }\n    FormatRegistry.Delete = Delete;\n    /** Returns true if the user defined string format exists */\n    function Has(format) {\n        return map.has(format);\n    }\n    FormatRegistry.Has = Has;\n    /** Sets a validation function for a user defined string format */\n    function Set(format, func) {\n        map.set(format, func);\n    }\n    FormatRegistry.Set = Set;\n    /** Gets a validation function for a user defined string format */\n    function Get(format) {\n        return map.get(format);\n    }\n    FormatRegistry.Get = Get;\n})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// ValueGuard\n// --------------------------------------------------------------------------\n/** Provides functions to type guard raw JavaScript values */\nvar ValueGuard;\n(function (ValueGuard) {\n    /** Returns true if this value is an array */\n    function IsArray(value) {\n        return Array.isArray(value);\n    }\n    ValueGuard.IsArray = IsArray;\n    /** Returns true if this value is bigint */\n    function IsBigInt(value) {\n        return typeof value === 'bigint';\n    }\n    ValueGuard.IsBigInt = IsBigInt;\n    /** Returns true if this value is a boolean */\n    function IsBoolean(value) {\n        return typeof value === 'boolean';\n    }\n    ValueGuard.IsBoolean = IsBoolean;\n    /** Returns true if this value is null */\n    function IsNull(value) {\n        return value === null;\n    }\n    ValueGuard.IsNull = IsNull;\n    /** Returns true if this value is number */\n    function IsNumber(value) {\n        return typeof value === 'number';\n    }\n    ValueGuard.IsNumber = IsNumber;\n    /** Returns true if this value is an object */\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null;\n    }\n    ValueGuard.IsObject = IsObject;\n    /** Returns true if this value is string */\n    function IsString(value) {\n        return typeof value === 'string';\n    }\n    ValueGuard.IsString = IsString;\n    /** Returns true if this value is undefined */\n    function IsUndefined(value) {\n        return value === undefined;\n    }\n    ValueGuard.IsUndefined = IsUndefined;\n})(ValueGuard || (exports.ValueGuard = ValueGuard = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends TypeBoxError {\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */\nvar TypeGuard;\n(function (TypeGuard) {\n    function IsPattern(value) {\n        try {\n            new RegExp(value);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    function IsControlCharacterFree(value) {\n        if (!ValueGuard.IsString(value))\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function IsAdditionalProperties(value) {\n        return IsOptionalBoolean(value) || TSchema(value);\n    }\n    function IsOptionalBigInt(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);\n    }\n    function IsOptionalNumber(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);\n    }\n    function IsOptionalBoolean(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);\n    }\n    function IsOptionalString(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);\n    }\n    function IsOptionalPattern(value) {\n        return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n    }\n    function IsOptionalFormat(value) {\n        return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value));\n    }\n    function IsOptionalSchema(value) {\n        return ValueGuard.IsUndefined(value) || TSchema(value);\n    }\n    // ----------------------------------------------------------------\n    // Types\n    // ----------------------------------------------------------------\n    /** Returns true if the given value is TAny */\n    function TAny(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Any') &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TAny = TAny;\n    /** Returns true if the given value is TArray */\n    function TArray(schema) {\n        return (TKindOf(schema, 'Array') &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items) &&\n            IsOptionalNumber(schema.minItems) &&\n            IsOptionalNumber(schema.maxItems) &&\n            IsOptionalBoolean(schema.uniqueItems) &&\n            IsOptionalSchema(schema.contains) &&\n            IsOptionalNumber(schema.minContains) &&\n            IsOptionalNumber(schema.maxContains));\n    }\n    TypeGuard.TArray = TArray;\n    /** Returns true if the given value is TAsyncIterator */\n    function TAsyncIterator(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'AsyncIterator') &&\n            schema.type === 'AsyncIterator' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items));\n    }\n    TypeGuard.TAsyncIterator = TAsyncIterator;\n    /** Returns true if the given value is TBigInt */\n    function TBigInt(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'BigInt') &&\n            schema.type === 'bigint' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalBigInt(schema.exclusiveMaximum) &&\n            IsOptionalBigInt(schema.exclusiveMinimum) &&\n            IsOptionalBigInt(schema.maximum) &&\n            IsOptionalBigInt(schema.minimum) &&\n            IsOptionalBigInt(schema.multipleOf));\n    }\n    TypeGuard.TBigInt = TBigInt;\n    /** Returns true if the given value is TBoolean */\n    function TBoolean(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Boolean') &&\n            schema.type === 'boolean' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TBoolean = TBoolean;\n    /** Returns true if the given value is TConstructor */\n    function TConstructor(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Constructor') &&\n            schema.type === 'Constructor' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsArray(schema.parameters) &&\n            schema.parameters.every(schema => TSchema(schema)) &&\n            TSchema(schema.returns));\n    }\n    TypeGuard.TConstructor = TConstructor;\n    /** Returns true if the given value is TDate */\n    function TDate(schema) {\n        return (TKindOf(schema, 'Date') &&\n            schema.type === 'Date' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.exclusiveMaximumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMinimumTimestamp) &&\n            IsOptionalNumber(schema.maximumTimestamp) &&\n            IsOptionalNumber(schema.minimumTimestamp) &&\n            IsOptionalNumber(schema.multipleOfTimestamp));\n    }\n    TypeGuard.TDate = TDate;\n    /** Returns true if the given value is TFunction */\n    function TFunction(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Function') &&\n            schema.type === 'Function' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsArray(schema.parameters) &&\n            schema.parameters.every(schema => TSchema(schema)) &&\n            TSchema(schema.returns));\n    }\n    TypeGuard.TFunction = TFunction;\n    /** Returns true if the given value is TInteger */\n    function TInteger(schema) {\n        return (TKindOf(schema, 'Integer') &&\n            schema.type === 'integer' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.exclusiveMaximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.multipleOf));\n    }\n    TypeGuard.TInteger = TInteger;\n    /** Returns true if the given value is TIntersect */\n    function TIntersect(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Intersect') &&\n            (ValueGuard.IsString(schema.type) && schema.type !== 'object' ? false : true) &&\n            ValueGuard.IsArray(schema.allOf) &&\n            schema.allOf.every(schema => TSchema(schema) && !TTransform(schema)) &&\n            IsOptionalString(schema.type) &&\n            (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TIntersect = TIntersect;\n    /** Returns true if the given value is TIterator */\n    function TIterator(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Iterator') &&\n            schema.type === 'Iterator' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items));\n    }\n    TypeGuard.TIterator = TIterator;\n    /** Returns true if the given value is a TKind with the given name. */\n    function TKindOf(schema, kind) {\n        return TKind(schema) && schema[exports.Kind] === kind;\n    }\n    TypeGuard.TKindOf = TKindOf;\n    /** Returns true if the given value is TKind */\n    function TKind(schema) {\n        return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);\n    }\n    TypeGuard.TKind = TKind;\n    /** Returns true if the given value is TLiteral<string> */\n    function TLiteralString(schema) {\n        return TLiteral(schema) && ValueGuard.IsString(schema.const);\n    }\n    TypeGuard.TLiteralString = TLiteralString;\n    /** Returns true if the given value is TLiteral<number> */\n    function TLiteralNumber(schema) {\n        return TLiteral(schema) && ValueGuard.IsNumber(schema.const);\n    }\n    TypeGuard.TLiteralNumber = TLiteralNumber;\n    /** Returns true if the given value is TLiteral<boolean> */\n    function TLiteralBoolean(schema) {\n        return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);\n    }\n    TypeGuard.TLiteralBoolean = TLiteralBoolean;\n    /** Returns true if the given value is TLiteral */\n    function TLiteral(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Literal') &&\n            IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) ||\n            ValueGuard.IsNumber(schema.const) ||\n            ValueGuard.IsString(schema.const)));\n    }\n    TypeGuard.TLiteral = TLiteral;\n    /** Returns true if the given value is TNever */\n    function TNever(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Never') &&\n            ValueGuard.IsObject(schema.not) &&\n            Object.getOwnPropertyNames(schema.not).length === 0);\n    }\n    TypeGuard.TNever = TNever;\n    /** Returns true if the given value is TNot */\n    function TNot(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Not') &&\n            TSchema(schema.not));\n    }\n    TypeGuard.TNot = TNot;\n    /** Returns true if the given value is TNull */\n    function TNull(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Null') &&\n            schema.type === 'null' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TNull = TNull;\n    /** Returns true if the given value is TNumber */\n    function TNumber(schema) {\n        return (TKindOf(schema, 'Number') &&\n            schema.type === 'number' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.exclusiveMaximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.multipleOf));\n    }\n    TypeGuard.TNumber = TNumber;\n    /** Returns true if the given value is TObject */\n    function TObject(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Object') &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsObject(schema.properties) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            IsOptionalNumber(schema.minProperties) &&\n            IsOptionalNumber(schema.maxProperties) &&\n            Object.entries(schema.properties).every(([key, schema]) => IsControlCharacterFree(key) && TSchema(schema)));\n    }\n    TypeGuard.TObject = TObject;\n    /** Returns true if the given value is TPromise */\n    function TPromise(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Promise') &&\n            schema.type === 'Promise' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.item));\n    }\n    TypeGuard.TPromise = TPromise;\n    /** Returns true if the given value is TRecord */\n    function TRecord(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Record') &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            ValueGuard.IsObject(schema.patternProperties) &&\n            ((schema) => {\n                const keys = Object.getOwnPropertyNames(schema.patternProperties);\n                return (keys.length === 1 &&\n                    IsPattern(keys[0]) &&\n                    ValueGuard.IsObject(schema.patternProperties) &&\n                    TSchema(schema.patternProperties[keys[0]]));\n            })(schema));\n    }\n    TypeGuard.TRecord = TRecord;\n    /** Returns true if this value is TRecursive */\n    function TRecursive(schema) {\n        return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === 'Recursive';\n    }\n    TypeGuard.TRecursive = TRecursive;\n    /** Returns true if the given value is TRef */\n    function TRef(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Ref') &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsString(schema.$ref));\n    }\n    TypeGuard.TRef = TRef;\n    /** Returns true if the given value is TString */\n    function TString(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'String') &&\n            schema.type === 'string' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minLength) &&\n            IsOptionalNumber(schema.maxLength) &&\n            IsOptionalPattern(schema.pattern) &&\n            IsOptionalFormat(schema.format));\n    }\n    TypeGuard.TString = TString;\n    /** Returns true if the given value is TSymbol */\n    function TSymbol(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Symbol') &&\n            schema.type === 'symbol' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TSymbol = TSymbol;\n    /** Returns true if the given value is TTemplateLiteral */\n    function TTemplateLiteral(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'TemplateLiteral') &&\n            schema.type === 'string' &&\n            ValueGuard.IsString(schema.pattern) &&\n            schema.pattern[0] === '^' &&\n            schema.pattern[schema.pattern.length - 1] === '$');\n    }\n    TypeGuard.TTemplateLiteral = TTemplateLiteral;\n    /** Returns true if the given value is TThis */\n    function TThis(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'This') &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsString(schema.$ref));\n    }\n    TypeGuard.TThis = TThis;\n    /** Returns true of this value is TTransform */\n    function TTransform(schema) {\n        return ValueGuard.IsObject(schema) && exports.Transform in schema;\n    }\n    TypeGuard.TTransform = TTransform;\n    /** Returns true if the given value is TTuple */\n    function TTuple(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Tuple') &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsNumber(schema.minItems) &&\n            ValueGuard.IsNumber(schema.maxItems) &&\n            schema.minItems === schema.maxItems &&\n            (( // empty\n            ValueGuard.IsUndefined(schema.items) &&\n                ValueGuard.IsUndefined(schema.additionalItems) &&\n                schema.minItems === 0) || (ValueGuard.IsArray(schema.items) &&\n                schema.items.every(schema => TSchema(schema)))));\n    }\n    TypeGuard.TTuple = TTuple;\n    /** Returns true if the given value is TUndefined */\n    function TUndefined(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Undefined') &&\n            schema.type === 'undefined' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUndefined = TUndefined;\n    /** Returns true if the given value is TUnion<Literal<string | number>[]> */\n    function TUnionLiteral(schema) {\n        return TUnion(schema) && schema.anyOf.every((schema) => TLiteralString(schema) || TLiteralNumber(schema));\n    }\n    TypeGuard.TUnionLiteral = TUnionLiteral;\n    /** Returns true if the given value is TUnion */\n    function TUnion(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Union') &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsObject(schema) &&\n            ValueGuard.IsArray(schema.anyOf) &&\n            schema.anyOf.every(schema => TSchema(schema)));\n    }\n    TypeGuard.TUnion = TUnion;\n    /** Returns true if the given value is TUint8Array */\n    function TUint8Array(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Uint8Array') &&\n            schema.type === 'Uint8Array' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minByteLength) &&\n            IsOptionalNumber(schema.maxByteLength));\n    }\n    TypeGuard.TUint8Array = TUint8Array;\n    /** Returns true if the given value is TUnknown */\n    function TUnknown(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Unknown') &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUnknown = TUnknown;\n    /** Returns true if the given value is a raw TUnsafe */\n    function TUnsafe(schema) {\n        return TKindOf(schema, 'Unsafe');\n    }\n    TypeGuard.TUnsafe = TUnsafe;\n    /** Returns true if the given value is TVoid */\n    function TVoid(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Void') &&\n            schema.type === 'void' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TVoid = TVoid;\n    /** Returns true if this value has a Readonly symbol */\n    function TReadonly(schema) {\n        return ValueGuard.IsObject(schema) && schema[exports.Readonly] === 'Readonly';\n    }\n    TypeGuard.TReadonly = TReadonly;\n    /** Returns true if this value has a Optional symbol */\n    function TOptional(schema) {\n        return ValueGuard.IsObject(schema) && schema[exports.Optional] === 'Optional';\n    }\n    TypeGuard.TOptional = TOptional;\n    /** Returns true if the given value is TSchema */\n    function TSchema(schema) {\n        // prettier-ignore\n        return (ValueGuard.IsObject(schema)) && (TAny(schema) ||\n            TArray(schema) ||\n            TBoolean(schema) ||\n            TBigInt(schema) ||\n            TAsyncIterator(schema) ||\n            TConstructor(schema) ||\n            TDate(schema) ||\n            TFunction(schema) ||\n            TInteger(schema) ||\n            TIntersect(schema) ||\n            TIterator(schema) ||\n            TLiteral(schema) ||\n            TNever(schema) ||\n            TNot(schema) ||\n            TNull(schema) ||\n            TNumber(schema) ||\n            TObject(schema) ||\n            TPromise(schema) ||\n            TRecord(schema) ||\n            TRef(schema) ||\n            TString(schema) ||\n            TSymbol(schema) ||\n            TTemplateLiteral(schema) ||\n            TThis(schema) ||\n            TTuple(schema) ||\n            TUndefined(schema) ||\n            TUnion(schema) ||\n            TUint8Array(schema) ||\n            TUnknown(schema) ||\n            TUnsafe(schema) ||\n            TVoid(schema) ||\n            (TKind(schema) && TypeRegistry.Has(schema[exports.Kind])));\n    }\n    TypeGuard.TSchema = TSchema;\n})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */\nvar ExtendsUndefined;\n(function (ExtendsUndefined) {\n    function Check(schema) {\n        return schema[exports.Kind] === 'Intersect'\n            ? schema.allOf.every((schema) => Check(schema))\n            : schema[exports.Kind] === 'Union'\n                ? schema.anyOf.some((schema) => Check(schema))\n                : schema[exports.Kind] === 'Undefined'\n                    ? true\n                    : schema[exports.Kind] === 'Not'\n                        ? !Check(schema.not)\n                        : false;\n    }\n    ExtendsUndefined.Check = Check;\n})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nclass TypeExtendsError extends TypeBoxError {\n}\nexports.TypeExtendsError = TypeExtendsError;\nvar TypeExtendsResult;\n(function (TypeExtendsResult) {\n    TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n    TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n    TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));\nvar TypeExtends;\n(function (TypeExtends) {\n    // --------------------------------------------------------------------------\n    // IntoBooleanResult\n    // --------------------------------------------------------------------------\n    function IntoBooleanResult(result) {\n        return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Throw\n    // --------------------------------------------------------------------------\n    function Throw(message) {\n        throw new TypeExtendsError(message);\n    }\n    // --------------------------------------------------------------------------\n    // StructuralRight\n    // --------------------------------------------------------------------------\n    function IsStructuralRight(right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(right) ||\n            TypeGuard.TIntersect(right) ||\n            TypeGuard.TUnion(right) ||\n            TypeGuard.TUnknown(right) ||\n            TypeGuard.TAny(right));\n    }\n    function StructuralRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(right) ? TNeverRight(left, right) :\n            TypeGuard.TIntersect(right) ? TIntersectRight(left, right) :\n                TypeGuard.TUnion(right) ? TUnionRight(left, right) :\n                    TypeGuard.TUnknown(right) ? TUnknownRight(left, right) :\n                        TypeGuard.TAny(right) ? TAnyRight(left, right) :\n                            Throw('StructuralRight'));\n    }\n    // --------------------------------------------------------------------------\n    // Any\n    // --------------------------------------------------------------------------\n    function TAnyRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function TAny(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TIntersect(right) ? TIntersectRight(left, right) :\n            (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema))) ? TypeExtendsResult.True :\n                TypeGuard.TUnion(right) ? TypeExtendsResult.Union :\n                    TypeGuard.TUnknown(right) ? TypeExtendsResult.True :\n                        TypeGuard.TAny(right) ? TypeExtendsResult.True :\n                            TypeExtendsResult.Union);\n    }\n    // --------------------------------------------------------------------------\n    // Array\n    // --------------------------------------------------------------------------\n    function TArrayRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TUnknown(left) ? TypeExtendsResult.False :\n            TypeGuard.TAny(left) ? TypeExtendsResult.Union :\n                TypeGuard.TNever(left) ? TypeExtendsResult.True :\n                    TypeExtendsResult.False);\n    }\n    function TArray(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True :\n            IsStructuralRight(right) ? StructuralRight(left, right) :\n                !TypeGuard.TArray(right) ? TypeExtendsResult.False :\n                    IntoBooleanResult(Visit(left.items, right.items)));\n    }\n    // --------------------------------------------------------------------------\n    // AsyncIterator\n    // --------------------------------------------------------------------------\n    function TAsyncIterator(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False :\n                IntoBooleanResult(Visit(left.items, right.items)));\n    }\n    // --------------------------------------------------------------------------\n    // BigInt\n    // --------------------------------------------------------------------------\n    function TBigInt(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TBigInt(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Boolean\n    // --------------------------------------------------------------------------\n    function TBooleanRight(left, right) {\n        return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TBoolean(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TBoolean(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------\n    function TConstructor(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                !TypeGuard.TConstructor(right) ? TypeExtendsResult.False :\n                    left.parameters.length > right.parameters.length ? TypeExtendsResult.False :\n                        (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) ? TypeExtendsResult.False :\n                            IntoBooleanResult(Visit(left.returns, right.returns)));\n    }\n    // --------------------------------------------------------------------------\n    // Date\n    // --------------------------------------------------------------------------\n    function TDate(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TDate(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Function\n    // --------------------------------------------------------------------------\n    function TFunction(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                !TypeGuard.TFunction(right) ? TypeExtendsResult.False :\n                    left.parameters.length > right.parameters.length ? TypeExtendsResult.False :\n                        (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) ? TypeExtendsResult.False :\n                            IntoBooleanResult(Visit(left.returns, right.returns)));\n    }\n    // --------------------------------------------------------------------------\n    // Integer\n    // --------------------------------------------------------------------------\n    function TIntegerRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True :\n            TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True :\n                TypeExtendsResult.False);\n    }\n    function TInteger(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True :\n            IsStructuralRight(right) ? StructuralRight(left, right) :\n                TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                    TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Intersect\n    // --------------------------------------------------------------------------\n    function TIntersectRight(left, right) {\n        // prettier-ignore\n        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True)\n            ? TypeExtendsResult.True\n            : TypeExtendsResult.False;\n    }\n    function TIntersect(left, right) {\n        // prettier-ignore\n        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True)\n            ? TypeExtendsResult.True\n            : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Iterator\n    // --------------------------------------------------------------------------\n    function TIterator(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            !TypeGuard.TIterator(right) ? TypeExtendsResult.False :\n                IntoBooleanResult(Visit(left.items, right.items)));\n    }\n    // --------------------------------------------------------------------------\n    // Literal\n    // --------------------------------------------------------------------------\n    function TLiteral(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True :\n            IsStructuralRight(right) ? StructuralRight(left, right) :\n                TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                    TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                        TypeGuard.TString(right) ? TStringRight(left, right) :\n                            TypeGuard.TNumber(right) ? TNumberRight(left, right) :\n                                TypeGuard.TInteger(right) ? TIntegerRight(left, right) :\n                                    TypeGuard.TBoolean(right) ? TBooleanRight(left, right) :\n                                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Never\n    // --------------------------------------------------------------------------\n    function TNeverRight(left, right) {\n        return TypeExtendsResult.False;\n    }\n    function TNever(left, right) {\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Not\n    // --------------------------------------------------------------------------\n    function UnwrapTNot(schema) {\n        let [current, depth] = [schema, 0];\n        while (true) {\n            if (!TypeGuard.TNot(current))\n                break;\n            current = current.not;\n            depth += 1;\n        }\n        return depth % 2 === 0 ? current : exports.Type.Unknown();\n    }\n    function TNot(left, right) {\n        // TypeScript has no concept of negated types, and attempts to correctly check the negated\n        // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n        // the type. Instead we unwrap to either unknown or T and continue evaluating.\n        // prettier-ignore\n        return (TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) :\n            TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) :\n                Throw('Invalid fallthrough for Not'));\n    }\n    // --------------------------------------------------------------------------\n    // Null\n    // --------------------------------------------------------------------------\n    function TNull(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TNull(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Number\n    // --------------------------------------------------------------------------\n    function TNumberRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True :\n            TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True :\n                TypeExtendsResult.False);\n    }\n    function TNumber(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Object\n    // --------------------------------------------------------------------------\n    function IsObjectPropertyCount(schema, count) {\n        return Object.getOwnPropertyNames(schema.properties).length === count;\n    }\n    function IsObjectStringLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectSymbolLike(schema) {\n        // prettier-ignore\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.TString(schema.properties.description.anyOf[0]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[0]))));\n    }\n    function IsObjectNumberLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBooleanLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBigIntLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectDateLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectUint8ArrayLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectFunctionLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectConstructorLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectArrayLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectPromiseLike(schema) {\n        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);\n    }\n    // --------------------------------------------------------------------------\n    // Property\n    // --------------------------------------------------------------------------\n    function Property(left, right) {\n        // prettier-ignore\n        return (Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False :\n            TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False :\n                TypeExtendsResult.True);\n    }\n    function TObjectRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TUnknown(left) ? TypeExtendsResult.False :\n            TypeGuard.TAny(left) ? TypeExtendsResult.Union : (TypeGuard.TNever(left) ||\n                (TypeGuard.TLiteralString(left) && IsObjectStringLike(right)) ||\n                (TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right)) ||\n                (TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right)) ||\n                (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) ||\n                (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right)) ||\n                (TypeGuard.TString(left) && IsObjectStringLike(right)) ||\n                (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) ||\n                (TypeGuard.TNumber(left) && IsObjectNumberLike(right)) ||\n                (TypeGuard.TInteger(left) && IsObjectNumberLike(right)) ||\n                (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right)) ||\n                (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right)) ||\n                (TypeGuard.TDate(left) && IsObjectDateLike(right)) ||\n                (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right)) ||\n                (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))) ? TypeExtendsResult.True :\n                (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) ? (() => {\n                    // When expressing a Record with literal key values, the Record is converted into a Object with\n                    // the Hint assigned as `Record`. This is used to invert the extends logic.\n                    return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;\n                })() :\n                    (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) ? (() => {\n                        return IsObjectPropertyCount(right, 0)\n                            ? TypeExtendsResult.True\n                            : TypeExtendsResult.False;\n                    })() :\n                        TypeExtendsResult.False);\n    }\n    function TObject(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                !TypeGuard.TObject(right) ? TypeExtendsResult.False :\n                    (() => {\n                        for (const key of Object.getOwnPropertyNames(right.properties)) {\n                            if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {\n                                return TypeExtendsResult.False;\n                            }\n                            if (TypeGuard.TOptional(right.properties[key])) {\n                                return TypeExtendsResult.True;\n                            }\n                            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n                                return TypeExtendsResult.False;\n                            }\n                        }\n                        return TypeExtendsResult.True;\n                    })());\n    }\n    // --------------------------------------------------------------------------\n    // Promise\n    // --------------------------------------------------------------------------\n    function TPromise(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True :\n                !TypeGuard.TPromise(right) ? TypeExtendsResult.False :\n                    IntoBooleanResult(Visit(left.item, right.item)));\n    }\n    // --------------------------------------------------------------------------\n    // Record\n    // --------------------------------------------------------------------------\n    function RecordKey(schema) {\n        // prettier-ignore\n        return (exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() :\n            exports.PatternStringExact in schema.patternProperties ? exports.Type.String() :\n                Throw('Unknown record key pattern'));\n    }\n    function RecordValue(schema) {\n        // prettier-ignore\n        return (exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] :\n            exports.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports.PatternStringExact] :\n                Throw('Unable to get record value schema'));\n    }\n    function TRecordRight(left, right) {\n        const [Key, Value] = [RecordKey(right), RecordValue(right)];\n        // prettier-ignore\n        return ((TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True) ? TypeExtendsResult.True :\n            TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) :\n                TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) :\n                    TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) :\n                        TypeGuard.TObject(left) ? (() => {\n                            for (const key of Object.getOwnPropertyNames(left.properties)) {\n                                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n                                    return TypeExtendsResult.False;\n                                }\n                            }\n                            return TypeExtendsResult.True;\n                        })() :\n                            TypeExtendsResult.False);\n    }\n    function TRecord(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                !TypeGuard.TRecord(right) ? TypeExtendsResult.False :\n                    Visit(RecordValue(left), RecordValue(right)));\n    }\n    // --------------------------------------------------------------------------\n    // String\n    // --------------------------------------------------------------------------\n    function TStringRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True :\n            TypeGuard.TString(left) ? TypeExtendsResult.True :\n                TypeExtendsResult.False);\n    }\n    function TString(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TString(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Symbol\n    // --------------------------------------------------------------------------\n    function TSymbol(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TSymbol(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // TemplateLiteral\n    // --------------------------------------------------------------------------\n    function TTemplateLiteral(left, right) {\n        // TemplateLiteral types are resolved to either unions for finite expressions or string\n        // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n        // either type and continue evaluating.\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) :\n            TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) :\n                Throw('Invalid fallthrough for TemplateLiteral'));\n    }\n    // --------------------------------------------------------------------------\n    // Tuple\n    // --------------------------------------------------------------------------\n    function IsArrayOfTuple(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TArray(right) &&\n            left.items !== undefined &&\n            left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True));\n    }\n    function TTupleRight(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(left) ? TypeExtendsResult.True :\n            TypeGuard.TUnknown(left) ? TypeExtendsResult.False :\n                TypeGuard.TAny(left) ? TypeExtendsResult.Union :\n                    TypeExtendsResult.False);\n    }\n    function TTuple(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True :\n                TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True :\n                    !TypeGuard.TTuple(right) ? TypeExtendsResult.False :\n                        (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) || (!ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items)) ? TypeExtendsResult.False :\n                            (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) ? TypeExtendsResult.True :\n                                left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True :\n                                    TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Uint8Array\n    // --------------------------------------------------------------------------\n    function TUint8Array(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TUint8Array(right) ? TypeExtendsResult.True :\n                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Undefined\n    // --------------------------------------------------------------------------\n    function TUndefined(left, right) {\n        // prettier-ignore\n        return (IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                TypeGuard.TRecord(right) ? TRecordRight(left, right) :\n                    TypeGuard.TVoid(right) ? VoidRight(left, right) :\n                        TypeGuard.TUndefined(right) ? TypeExtendsResult.True :\n                            TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Union\n    // --------------------------------------------------------------------------\n    function TUnionRight(left, right) {\n        // prettier-ignore\n        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True)\n            ? TypeExtendsResult.True\n            : TypeExtendsResult.False;\n    }\n    function TUnion(left, right) {\n        // prettier-ignore\n        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True)\n            ? TypeExtendsResult.True\n            : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Unknown\n    // --------------------------------------------------------------------------\n    function TUnknownRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function TUnknown(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(right) ? TNeverRight(left, right) :\n            TypeGuard.TIntersect(right) ? TIntersectRight(left, right) :\n                TypeGuard.TUnion(right) ? TUnionRight(left, right) :\n                    TypeGuard.TAny(right) ? TAnyRight(left, right) :\n                        TypeGuard.TString(right) ? TStringRight(left, right) :\n                            TypeGuard.TNumber(right) ? TNumberRight(left, right) :\n                                TypeGuard.TInteger(right) ? TIntegerRight(left, right) :\n                                    TypeGuard.TBoolean(right) ? TBooleanRight(left, right) :\n                                        TypeGuard.TArray(right) ? TArrayRight(left, right) :\n                                            TypeGuard.TTuple(right) ? TTupleRight(left, right) :\n                                                TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                                                    TypeGuard.TUnknown(right) ? TypeExtendsResult.True :\n                                                        TypeExtendsResult.False);\n    }\n    // --------------------------------------------------------------------------\n    // Void\n    // --------------------------------------------------------------------------\n    function VoidRight(left, right) {\n        // prettier-ignore\n        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True :\n            TypeGuard.TUndefined(left) ? TypeExtendsResult.True :\n                TypeExtendsResult.False;\n    }\n    function TVoid(left, right) {\n        // prettier-ignore\n        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) :\n            TypeGuard.TUnion(right) ? TUnionRight(left, right) :\n                TypeGuard.TUnknown(right) ? TUnknownRight(left, right) :\n                    TypeGuard.TAny(right) ? TAnyRight(left, right) :\n                        TypeGuard.TObject(right) ? TObjectRight(left, right) :\n                            TypeGuard.TVoid(right) ? TypeExtendsResult.True :\n                                TypeExtendsResult.False;\n    }\n    function Visit(left, right) {\n        // prettier-ignore\n        return (\n        // resolvable\n        (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right)) ? TTemplateLiteral(left, right) :\n            (TypeGuard.TNot(left) || TypeGuard.TNot(right)) ? TNot(left, right) :\n                // standard\n                TypeGuard.TAny(left) ? TAny(left, right) :\n                    TypeGuard.TArray(left) ? TArray(left, right) :\n                        TypeGuard.TBigInt(left) ? TBigInt(left, right) :\n                            TypeGuard.TBoolean(left) ? TBoolean(left, right) :\n                                TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) :\n                                    TypeGuard.TConstructor(left) ? TConstructor(left, right) :\n                                        TypeGuard.TDate(left) ? TDate(left, right) :\n                                            TypeGuard.TFunction(left) ? TFunction(left, right) :\n                                                TypeGuard.TInteger(left) ? TInteger(left, right) :\n                                                    TypeGuard.TIntersect(left) ? TIntersect(left, right) :\n                                                        TypeGuard.TIterator(left) ? TIterator(left, right) :\n                                                            TypeGuard.TLiteral(left) ? TLiteral(left, right) :\n                                                                TypeGuard.TNever(left) ? TNever(left, right) :\n                                                                    TypeGuard.TNull(left) ? TNull(left, right) :\n                                                                        TypeGuard.TNumber(left) ? TNumber(left, right) :\n                                                                            TypeGuard.TObject(left) ? TObject(left, right) :\n                                                                                TypeGuard.TRecord(left) ? TRecord(left, right) :\n                                                                                    TypeGuard.TString(left) ? TString(left, right) :\n                                                                                        TypeGuard.TSymbol(left) ? TSymbol(left, right) :\n                                                                                            TypeGuard.TTuple(left) ? TTuple(left, right) :\n                                                                                                TypeGuard.TPromise(left) ? TPromise(left, right) :\n                                                                                                    TypeGuard.TUint8Array(left) ? TUint8Array(left, right) :\n                                                                                                        TypeGuard.TUndefined(left) ? TUndefined(left, right) :\n                                                                                                            TypeGuard.TUnion(left) ? TUnion(left, right) :\n                                                                                                                TypeGuard.TUnknown(left) ? TUnknown(left, right) :\n                                                                                                                    TypeGuard.TVoid(left) ? TVoid(left, right) :\n                                                                                                                        Throw(`Unknown left type operand '${left[exports.Kind]}'`));\n    }\n    function Extends(left, right) {\n        return Visit(left, right);\n    }\n    TypeExtends.Extends = Extends;\n})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */\nvar TypeClone;\n(function (TypeClone) {\n    function ObjectType(value) {\n        const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n        return { ...clonedProperties, ...clonedSymbols };\n    }\n    function ArrayType(value) {\n        return value.map((value) => Visit(value));\n    }\n    function Visit(value) {\n        // prettier-ignore\n        return ValueGuard.IsArray(value) ? ArrayType(value) :\n            ValueGuard.IsObject(value) ? ObjectType(value) :\n                value;\n    }\n    /** Clones a Rest */\n    function Rest(schemas) {\n        return schemas.map((schema) => Type(schema));\n    }\n    TypeClone.Rest = Rest;\n    /** Clones a Type */\n    function Type(schema, options = {}) {\n        return { ...Visit(schema), ...options };\n    }\n    TypeClone.Type = Type;\n})(TypeClone || (exports.TypeClone = TypeClone = {}));\n// --------------------------------------------------------------------------\n// IndexedAccessor\n// --------------------------------------------------------------------------\nvar IndexedAccessor;\n(function (IndexedAccessor) {\n    function OptionalUnwrap(schema) {\n        return schema.map((schema) => {\n            const { [exports.Optional]: _, ...clone } = TypeClone.Type(schema);\n            return clone;\n        });\n    }\n    function IsIntersectOptional(schema) {\n        return schema.every((schema) => TypeGuard.TOptional(schema));\n    }\n    function IsUnionOptional(schema) {\n        return schema.some((schema) => TypeGuard.TOptional(schema));\n    }\n    function ResolveIntersect(schema) {\n        return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;\n    }\n    function ResolveUnion(schema) {\n        return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;\n    }\n    function ResolveOptional(schema) {\n        // prettier-ignore\n        return schema[exports.Kind] === 'Intersect' ? ResolveIntersect(schema) :\n            schema[exports.Kind] === 'Union' ? ResolveUnion(schema) :\n                schema;\n    }\n    function TIntersect(schema, key) {\n        const resolved = schema.allOf.reduce((acc, schema) => {\n            const indexed = Visit(schema, key);\n            return indexed[exports.Kind] === 'Never' ? acc : [...acc, indexed];\n        }, []);\n        return ResolveOptional(exports.Type.Intersect(resolved));\n    }\n    function TUnion(schema, key) {\n        const resolved = schema.anyOf.map((schema) => Visit(schema, key));\n        return ResolveOptional(exports.Type.Union(resolved));\n    }\n    function TObject(schema, key) {\n        const property = schema.properties[key];\n        return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);\n    }\n    function TTuple(schema, key) {\n        const items = schema.items;\n        if (ValueGuard.IsUndefined(items))\n            return exports.Type.Never();\n        const element = items[key]; //\n        if (ValueGuard.IsUndefined(element))\n            return exports.Type.Never();\n        return element;\n    }\n    function Visit(schema, key) {\n        // prettier-ignore\n        return schema[exports.Kind] === 'Intersect' ? TIntersect(schema, key) :\n            schema[exports.Kind] === 'Union' ? TUnion(schema, key) :\n                schema[exports.Kind] === 'Object' ? TObject(schema, key) :\n                    schema[exports.Kind] === 'Tuple' ? TTuple(schema, key) :\n                        exports.Type.Never();\n    }\n    function Resolve(schema, keys, options = {}) {\n        const resolved = keys.map((key) => Visit(schema, key.toString()));\n        return ResolveOptional(exports.Type.Union(resolved, options));\n    }\n    IndexedAccessor.Resolve = Resolve;\n})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));\n// --------------------------------------------------------------------------\n// Intrinsic\n// --------------------------------------------------------------------------\nvar Intrinsic;\n(function (Intrinsic) {\n    function Uncapitalize(value) {\n        const [first, rest] = [value.slice(0, 1), value.slice(1)];\n        return `${first.toLowerCase()}${rest}`;\n    }\n    function Capitalize(value) {\n        const [first, rest] = [value.slice(0, 1), value.slice(1)];\n        return `${first.toUpperCase()}${rest}`;\n    }\n    function Uppercase(value) {\n        return value.toUpperCase();\n    }\n    function Lowercase(value) {\n        return value.toLowerCase();\n    }\n    function IntrinsicTemplateLiteral(schema, mode) {\n        // note: template literals require special runtime handling as they are encoded in string patterns.\n        // This diverges from the mapped type which would otherwise map on the template literal kind.\n        const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n        const finite = TemplateLiteralFinite.Check(expression);\n        if (!finite)\n            return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };\n        const strings = [...TemplateLiteralGenerator.Generate(expression)];\n        const literals = strings.map((value) => exports.Type.Literal(value));\n        const mapped = IntrinsicRest(literals, mode);\n        const union = exports.Type.Union(mapped);\n        return exports.Type.TemplateLiteral([union]);\n    }\n    function IntrinsicLiteral(value, mode) {\n        // prettier-ignore\n        return typeof value === 'string' ? (mode === 'Uncapitalize' ? Uncapitalize(value) :\n            mode === 'Capitalize' ? Capitalize(value) :\n                mode === 'Uppercase' ? Uppercase(value) :\n                    mode === 'Lowercase' ? Lowercase(value) :\n                        value) : value.toString();\n    }\n    function IntrinsicRest(schema, mode) {\n        if (schema.length === 0)\n            return [];\n        const [L, ...R] = schema;\n        return [Map(L, mode), ...IntrinsicRest(R, mode)];\n    }\n    function Visit(schema, mode) {\n        // prettier-ignore\n        return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) :\n            TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) :\n                TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) :\n                    schema;\n    }\n    /** Applies an intrinsic string manipulation to the given type. */\n    function Map(schema, mode) {\n        return Visit(schema, mode);\n    }\n    Intrinsic.Map = Map;\n})(Intrinsic || (exports.Intrinsic = Intrinsic = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function (ObjectMap) {\n    function TIntersect(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function TUnion(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function TObject(schema, callback) {\n        return callback(schema);\n    }\n    function Visit(schema, callback) {\n        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n        // used for composition, we use explicit checks instead.\n        // prettier-ignore\n        return (schema[exports.Kind] === 'Intersect' ? TIntersect(schema, callback) :\n            schema[exports.Kind] === 'Union' ? TUnion(schema, callback) :\n                schema[exports.Kind] === 'Object' ? TObject(schema, callback) :\n                    schema);\n    }\n    function Map(schema, callback, options) {\n        return { ...Visit(TypeClone.Type(schema), callback), ...options };\n    }\n    ObjectMap.Map = Map;\n})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));\nvar KeyResolver;\n(function (KeyResolver) {\n    function UnwrapPattern(key) {\n        return key[0] === '^' && key[key.length - 1] === '$' ? key.slice(1, key.length - 1) : key;\n    }\n    function TIntersect(schema, options) {\n        return schema.allOf.reduce((acc, schema) => [...acc, ...Visit(schema, options)], []);\n    }\n    function TUnion(schema, options) {\n        const sets = schema.anyOf.map((inner) => Visit(inner, options));\n        return [...sets.reduce((set, outer) => outer.map((key) => (sets.every((inner) => inner.includes(key)) ? set.add(key) : set))[0], new Set())];\n    }\n    function TObject(schema, options) {\n        return Object.getOwnPropertyNames(schema.properties);\n    }\n    function TRecord(schema, options) {\n        return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];\n    }\n    function Visit(schema, options) {\n        // prettier-ignore\n        return (TypeGuard.TIntersect(schema) ? TIntersect(schema, options) :\n            TypeGuard.TUnion(schema) ? TUnion(schema, options) :\n                TypeGuard.TObject(schema) ? TObject(schema, options) :\n                    TypeGuard.TRecord(schema) ? TRecord(schema, options) :\n                        []);\n    }\n    /** Resolves an array of keys in this schema */\n    function ResolveKeys(schema, options) {\n        return [...new Set(Visit(schema, options))];\n    }\n    KeyResolver.ResolveKeys = ResolveKeys;\n    /** Resolves a regular expression pattern matching all keys in this schema */\n    function ResolvePattern(schema) {\n        const keys = ResolveKeys(schema, { includePatterns: true });\n        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);\n        return `^(${pattern.join('|')})$`;\n    }\n    KeyResolver.ResolvePattern = ResolvePattern;\n})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));\n// --------------------------------------------------------------------------\n// KeyArrayResolver\n// --------------------------------------------------------------------------\nclass KeyArrayResolverError extends TypeBoxError {\n}\nexports.KeyArrayResolverError = KeyArrayResolverError;\nvar KeyArrayResolver;\n(function (KeyArrayResolver) {\n    /** Resolves an array of string[] keys from the given schema or array type. */\n    function Resolve(schema) {\n        // prettier-ignore\n        return Array.isArray(schema) ? schema :\n            TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema) => schema.const.toString()) :\n                TypeGuard.TLiteral(schema) ? [schema.const] :\n                    TypeGuard.TTemplateLiteral(schema) ? (() => {\n                        const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n                        if (!TemplateLiteralFinite.Check(expression))\n                            throw new KeyArrayResolverError('Cannot resolve keys from infinite template expression');\n                        return [...TemplateLiteralGenerator.Generate(expression)];\n                    })() : [];\n    }\n    KeyArrayResolver.Resolve = Resolve;\n})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));\n// --------------------------------------------------------------------------\n// UnionResolver\n// --------------------------------------------------------------------------\nvar UnionResolver;\n(function (UnionResolver) {\n    function* TUnion(union) {\n        for (const schema of union.anyOf) {\n            if (schema[exports.Kind] === 'Union') {\n                yield* TUnion(schema);\n            }\n            else {\n                yield schema;\n            }\n        }\n    }\n    /** Returns a resolved union with interior unions flattened */\n    function Resolve(union) {\n        return exports.Type.Union([...TUnion(union)], { ...union });\n    }\n    UnionResolver.Resolve = Resolve;\n})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nclass TemplateLiteralPatternError extends TypeBoxError {\n}\nexports.TemplateLiteralPatternError = TemplateLiteralPatternError;\nvar TemplateLiteralPattern;\n(function (TemplateLiteralPattern) {\n    function Throw(message) {\n        throw new TemplateLiteralPatternError(message);\n    }\n    function Escape(value) {\n        return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    }\n    function Visit(schema, acc) {\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) :\n            TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema) => Visit(schema, acc)).join('|')})` :\n                TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` :\n                    TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` :\n                        TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` :\n                            TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` :\n                                TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` :\n                                    TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` :\n                                        Throw(`Unexpected Kind '${schema[exports.Kind]}'`));\n    }\n    function Create(kinds) {\n        return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n    }\n    TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function (TemplateLiteralResolver) {\n    /** Resolves a template literal as a TUnion */\n    function Resolve(template) {\n        const expression = TemplateLiteralParser.ParseExact(template.pattern);\n        if (!TemplateLiteralFinite.Check(expression))\n            return exports.Type.String();\n        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));\n        return exports.Type.Union(literals);\n    }\n    TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends TypeBoxError {\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function (TemplateLiteralParser) {\n    function IsNonEscaped(pattern, index, char) {\n        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n    }\n    function IsOpenParen(pattern, index) {\n        return IsNonEscaped(pattern, index, '(');\n    }\n    function IsCloseParen(pattern, index) {\n        return IsNonEscaped(pattern, index, ')');\n    }\n    function IsSeparator(pattern, index) {\n        return IsNonEscaped(pattern, index, '|');\n    }\n    function IsGroup(pattern) {\n        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n            return false;\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (count === 0 && index !== pattern.length - 1)\n                return false;\n        }\n        return true;\n    }\n    function InGroup(pattern) {\n        return pattern.slice(1, pattern.length - 1);\n    }\n    function IsPrecedenceOr(pattern) {\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0)\n                return true;\n        }\n        return false;\n    }\n    function IsPrecedenceAnd(pattern) {\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                return true;\n        }\n        return false;\n    }\n    function Or(pattern) {\n        let [count, start] = [0, 0];\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) {\n                const range = pattern.slice(start, index);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                start = index + 1;\n            }\n        }\n        const range = pattern.slice(start);\n        if (range.length > 0)\n            expressions.push(Parse(range));\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'or', expr: expressions };\n    }\n    function And(pattern) {\n        function Group(value, index) {\n            if (!IsOpenParen(value, index))\n                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n            let count = 0;\n            for (let scan = index; scan < value.length; scan++) {\n                if (IsOpenParen(value, scan))\n                    count += 1;\n                if (IsCloseParen(value, scan))\n                    count -= 1;\n                if (count === 0)\n                    return [index, scan];\n            }\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n        }\n        function Range(pattern, index) {\n            for (let scan = index; scan < pattern.length; scan++) {\n                if (IsOpenParen(pattern, scan))\n                    return [index, scan];\n            }\n            return [index, pattern.length];\n        }\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index)) {\n                const [start, end] = Group(pattern, index);\n                const range = pattern.slice(start, end + 1);\n                expressions.push(Parse(range));\n                index = end;\n            }\n            else {\n                const [start, end] = Range(pattern, index);\n                const range = pattern.slice(start, end);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                index = end - 1;\n            }\n        }\n        // prettier-ignore\n        return (expressions.length === 0) ? { type: 'const', const: '' } :\n            (expressions.length === 1) ? expressions[0] :\n                { type: 'and', expr: expressions };\n    }\n    /** Parses a pattern and returns an expression tree */\n    function Parse(pattern) {\n        // prettier-ignore\n        return IsGroup(pattern) ? Parse(InGroup(pattern)) :\n            IsPrecedenceOr(pattern) ? Or(pattern) :\n                IsPrecedenceAnd(pattern) ? And(pattern) :\n                    { type: 'const', const: pattern };\n    }\n    TemplateLiteralParser.Parse = Parse;\n    /** Parses a pattern and strips forward and trailing ^ and $ */\n    function ParseExact(pattern) {\n        return Parse(pattern.slice(1, pattern.length - 1));\n    }\n    TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralFiniteError extends TypeBoxError {\n}\nexports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;\nvar TemplateLiteralFinite;\n(function (TemplateLiteralFinite) {\n    function Throw(message) {\n        throw new TemplateLiteralFiniteError(message);\n    }\n    function IsNumber(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === '0' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === '[1-9][0-9]*');\n    }\n    function IsBoolean(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === 'true' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === 'false');\n    }\n    function IsString(expression) {\n        return expression.type === 'const' && expression.const === '.*';\n    }\n    function Check(expression) {\n        // prettier-ignore\n        return IsBoolean(expression) ? true :\n            IsNumber(expression) || IsString(expression) ? false :\n                (expression.type === 'and') ? expression.expr.every((expr) => Check(expr)) :\n                    (expression.type === 'or') ? expression.expr.every((expr) => Check(expr)) :\n                        (expression.type === 'const') ? true :\n                            Throw(`Unknown expression type`);\n    }\n    TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralGeneratorError extends TypeBoxError {\n}\nexports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;\nvar TemplateLiteralGenerator;\n(function (TemplateLiteralGenerator) {\n    function* Reduce(buffer) {\n        if (buffer.length === 1)\n            return yield* buffer[0];\n        for (const left of buffer[0]) {\n            for (const right of Reduce(buffer.slice(1))) {\n                yield `${left}${right}`;\n            }\n        }\n    }\n    function* And(expression) {\n        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));\n    }\n    function* Or(expression) {\n        for (const expr of expression.expr)\n            yield* Generate(expr);\n    }\n    function* Const(expression) {\n        return yield expression.const;\n    }\n    function* Generate(expression) {\n        // prettier-ignore\n        return (expression.type === 'and' ? yield* And(expression) :\n            expression.type === 'or' ? yield* Or(expression) :\n                expression.type === 'const' ? yield* Const(expression) :\n                    (() => { throw new TemplateLiteralGeneratorError('Unknown expression'); })());\n    }\n    TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));\n// ---------------------------------------------------------------------\n// TemplateLiteralDslParser\n// ---------------------------------------------------------------------\nvar TemplateLiteralDslParser;\n(function (TemplateLiteralDslParser) {\n    function* ParseUnion(template) {\n        const trim = template.trim().replace(/\"|'/g, '');\n        // prettier-ignore\n        return (trim === 'boolean' ? yield exports.Type.Boolean() :\n            trim === 'number' ? yield exports.Type.Number() :\n                trim === 'bigint' ? yield exports.Type.BigInt() :\n                    trim === 'string' ? yield exports.Type.String() :\n                        yield (() => {\n                            const literals = trim.split('|').map((literal) => exports.Type.Literal(literal.trim()));\n                            return (literals.length === 0 ? exports.Type.Never() :\n                                literals.length === 1 ? literals[0] :\n                                    exports.Type.Union(literals));\n                        })());\n    }\n    function* ParseTerminal(template) {\n        if (template[1] !== '{') {\n            const L = exports.Type.Literal('$');\n            const R = ParseLiteral(template.slice(1));\n            return yield* [L, ...R];\n        }\n        for (let i = 2; i < template.length; i++) {\n            if (template[i] === '}') {\n                const L = ParseUnion(template.slice(2, i));\n                const R = ParseLiteral(template.slice(i + 1));\n                return yield* [...L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function* ParseLiteral(template) {\n        for (let i = 0; i < template.length; i++) {\n            if (template[i] === '$') {\n                const L = exports.Type.Literal(template.slice(0, i));\n                const R = ParseTerminal(template.slice(i));\n                return yield* [L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function Parse(template_dsl) {\n        return [...ParseLiteral(template_dsl)];\n    }\n    TemplateLiteralDslParser.Parse = Parse;\n})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));\n// ---------------------------------------------------------------------\n// TransformBuilder\n// ---------------------------------------------------------------------\nclass TransformDecodeBuilder {\n    constructor(schema) {\n        this.schema = schema;\n    }\n    Decode(decode) {\n        return new TransformEncodeBuilder(this.schema, decode);\n    }\n}\nexports.TransformDecodeBuilder = TransformDecodeBuilder;\nclass TransformEncodeBuilder {\n    constructor(schema, decode) {\n        this.schema = schema;\n        this.decode = decode;\n    }\n    Encode(encode) {\n        const schema = TypeClone.Type(this.schema);\n        // prettier-ignore\n        return (TypeGuard.TTransform(schema) ? (() => {\n            const Encode = (value) => schema[exports.Transform].Encode(encode(value));\n            const Decode = (value) => this.decode(schema[exports.Transform].Decode(value));\n            const Codec = { Encode: Encode, Decode: Decode };\n            return { ...schema, [exports.Transform]: Codec };\n        })() : (() => {\n            const Codec = { Decode: this.decode, Encode: encode };\n            return { ...schema, [exports.Transform]: Codec };\n        })());\n    }\n}\nexports.TransformEncodeBuilder = TransformEncodeBuilder;\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilderError extends TypeBoxError {\n}\nexports.TypeBuilderError = TypeBuilderError;\nclass TypeBuilder {\n    /** `[Internal]` Creates a schema without `static` and `params` types */\n    Create(schema) {\n        return schema;\n    }\n    /** `[Internal]` Throws a TypeBuilder error with the given message */\n    Throw(message) {\n        throw new TypeBuilderError(message);\n    }\n    /** `[Internal]` Discards property keys from the given record type */\n    Discard(record, keys) {\n        return keys.reduce((acc, key) => {\n            const { [key]: _, ...rest } = acc;\n            return rest;\n        }, record);\n    }\n    /** `[Json]` Omits compositing symbols from this schema */\n    Strict(schema) {\n        return JSON.parse(JSON.stringify(schema));\n    }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// JsonTypeBuilder\n// --------------------------------------------------------------------------\nclass JsonTypeBuilder extends TypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Json]` Creates a Readonly and Optional property */\n    ReadonlyOptional(schema) {\n        return this.Readonly(this.Optional(schema));\n    }\n    /** `[Json]` Creates a Readonly property */\n    Readonly(schema) {\n        return { ...TypeClone.Type(schema), [exports.Readonly]: 'Readonly' };\n    }\n    /** `[Json]` Creates an Optional property */\n    Optional(schema) {\n        return { ...TypeClone.Type(schema), [exports.Optional]: 'Optional' };\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Json]` Creates an Any type */\n    Any(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Any' });\n    }\n    /** `[Json]` Creates an Array type */\n    Array(schema, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Type(schema) });\n    }\n    /** `[Json]` Creates a Boolean type */\n    Boolean(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });\n    }\n    /** `[Json]` Intrinsic function to Capitalize LiteralString types */\n    Capitalize(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Type(schema), 'Capitalize'), ...options };\n    }\n    /** `[Json]` Creates a Composite object type */\n    Composite(objects, options) {\n        const intersect = exports.Type.Intersect(objects, {});\n        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });\n        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});\n        return exports.Type.Object(properties, options);\n    }\n    /** `[Json]` Creates a Enum type */\n    Enum(item, options = {}) {\n        if (ValueGuard.IsUndefined(item))\n            return this.Throw('Enum undefined or empty');\n        // prettier-ignore\n        const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);\n        const values2 = [...new Set(values1)];\n        const anyOf = values2.map((value) => exports.Type.Literal(value));\n        return this.Union(anyOf, { ...options, [exports.Hint]: 'Enum' });\n    }\n    /** `[Json]` Creates a Conditional type */\n    Extends(left, right, trueType, falseType, options = {}) {\n        switch (TypeExtends.Extends(left, right)) {\n            case TypeExtendsResult.Union:\n                return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);\n            case TypeExtendsResult.True:\n                return TypeClone.Type(trueType, options);\n            case TypeExtendsResult.False:\n                return TypeClone.Type(falseType, options);\n        }\n    }\n    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */\n    Exclude(unionType, excludedMembers, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) :\n            TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) :\n                TypeGuard.TUnion(unionType) ? (() => {\n                    const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);\n                    return (narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options));\n                })() :\n                    TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) :\n                        TypeClone.Type(unionType, options));\n    }\n    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */\n    Extract(type, union, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) :\n            TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) :\n                TypeGuard.TUnion(type) ? (() => {\n                    const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);\n                    return (narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options));\n                })() :\n                    TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) :\n                        this.Never(options));\n    }\n    /** `[Json]` Returns an Indexed property type for the given keys */\n    Index(schema, unresolved, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {\n            return TypeClone.Type(schema.items, options);\n        })() :\n            TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {\n                const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;\n                const cloned = items.map((schema) => TypeClone.Type(schema));\n                return this.Union(cloned, options);\n            })() : (() => {\n                const keys = KeyArrayResolver.Resolve(unresolved);\n                const clone = TypeClone.Type(schema);\n                return IndexedAccessor.Resolve(clone, keys, options);\n            })());\n    }\n    /** `[Json]` Creates an Integer type */\n    Integer(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });\n    }\n    /** `[Json]` Creates an Intersect type */\n    Intersect(allOf, options = {}) {\n        if (allOf.length === 0)\n            return exports.Type.Never();\n        if (allOf.length === 1)\n            return TypeClone.Type(allOf[0], options);\n        if (allOf.some((schema) => TypeGuard.TTransform(schema)))\n            this.Throw('Cannot intersect transform types');\n        const objects = allOf.every((schema) => TypeGuard.TObject(schema));\n        const cloned = TypeClone.Rest(allOf);\n        // prettier-ignore\n        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties)\n            ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) }\n            : {};\n        return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects\n            ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned })\n            : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });\n    }\n    /** `[Json]` Creates a KeyOf type */\n    KeyOf(schema, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TRecord(schema) ? (() => {\n            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n            return (pattern === exports.PatternNumberExact ? this.Number(options) :\n                pattern === exports.PatternStringExact ? this.String(options) :\n                    this.Throw('Unable to resolve key type from Record key pattern'));\n        })() :\n            TypeGuard.TTuple(schema) ? (() => {\n                const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;\n                const literals = items.map((_, index) => exports.Type.Literal(index.toString()));\n                return this.Union(literals, options);\n            })() :\n                TypeGuard.TArray(schema) ? (() => {\n                    return this.Number(options);\n                })() : (() => {\n                    const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });\n                    if (keys.length === 0)\n                        return this.Never(options);\n                    const literals = keys.map((key) => this.Literal(key));\n                    return this.Union(literals, options);\n                })());\n    }\n    /** `[Json]` Creates a Literal type */\n    Literal(value, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });\n    }\n    /** `[Json]` Intrinsic function to Lowercase LiteralString types */\n    Lowercase(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Type(schema), 'Lowercase'), ...options };\n    }\n    /** `[Json]` Creates a Never type */\n    Never(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });\n    }\n    /** `[Json]` Creates a Not type */\n    Not(schema, options) {\n        return this.Create({ ...options, [exports.Kind]: 'Not', not: TypeClone.Type(schema) });\n    }\n    /** `[Json]` Creates a Null type */\n    Null(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });\n    }\n    /** `[Json]` Creates a Number type */\n    Number(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });\n    }\n    /** `[Json]` Creates an Object type */\n    Object(properties, options = {}) {\n        const propertyKeys = Object.getOwnPropertyNames(properties);\n        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));\n        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));\n        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};\n        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});\n        return requiredKeys.length > 0\n            ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys })\n            : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });\n    }\n    /** `[Json]` Constructs a type whose keys are omitted from the given type */\n    Omit(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), (object) => {\n            if (ValueGuard.IsArray(object.required)) {\n                object.required = object.required.filter((key) => !keys.includes(key));\n                if (object.required.length === 0)\n                    delete object.required;\n            }\n            for (const key of Object.getOwnPropertyNames(object.properties)) {\n                if (keys.includes(key))\n                    delete object.properties[key];\n            }\n            return this.Create(object);\n        }, options);\n    }\n    /** `[Json]` Constructs a type where all properties are optional */\n    Partial(schema, options = {}) {\n        // prettier-ignore\n        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), (object) => {\n            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {\n                return { ...acc, [key]: this.Optional(object.properties[key]) };\n            }, {});\n            return this.Object(properties, this.Discard(object, ['required']) /* object used as options to retain other constraints */);\n        }, options);\n    }\n    /** `[Json]` Constructs a type whose keys are picked from the given type */\n    Pick(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), (object) => {\n            if (ValueGuard.IsArray(object.required)) {\n                object.required = object.required.filter((key) => keys.includes(key));\n                if (object.required.length === 0)\n                    delete object.required;\n            }\n            for (const key of Object.getOwnPropertyNames(object.properties)) {\n                if (!keys.includes(key))\n                    delete object.properties[key];\n            }\n            return this.Create(object);\n        }, options);\n    }\n    /** `[Json]` Creates a Record type */\n    Record(key, schema, options = {}) {\n        // prettier-ignore\n        return (TypeGuard.TTemplateLiteral(key) ? (() => {\n            const expression = TemplateLiteralParser.ParseExact(key.pattern);\n            // prettier-ignore\n            return TemplateLiteralFinite.Check(expression)\n                ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(schema) }), {}), options))\n                : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Type(schema) } });\n        })() :\n            TypeGuard.TUnion(key) ? (() => {\n                const union = UnionResolver.Resolve(key);\n                if (TypeGuard.TUnionLiteral(union)) {\n                    const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});\n                    return this.Object(properties, { ...options, [exports.Hint]: 'Record' });\n                }\n                else\n                    this.Throw('Record key of type union contains non-literal types');\n            })() :\n                TypeGuard.TLiteral(key) ? (() => {\n                    // prettier-ignore\n                    return (ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const))\n                        ? this.Object({ [key.const]: TypeClone.Type(schema) }, options)\n                        : this.Throw('Record key of type literal is not of type string or number');\n                })() :\n                    TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {\n                        return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });\n                    })() :\n                        TypeGuard.TString(key) ? (() => {\n                            const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;\n                            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Type(schema) } });\n                        })() :\n                            this.Never());\n    }\n    /** `[Json]` Creates a Recursive type */\n    Recursive(callback, options = {}) {\n        if (ValueGuard.IsUndefined(options.$id))\n            options.$id = `T${TypeOrdinal++}`;\n        const thisType = callback({ [exports.Kind]: 'This', $ref: `${options.$id}` });\n        thisType.$id = options.$id;\n        return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });\n    }\n    /** `[Json]` Creates a Ref type. */\n    Ref(unresolved, options = {}) {\n        if (ValueGuard.IsString(unresolved))\n            return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: unresolved });\n        if (ValueGuard.IsUndefined(unresolved.$id))\n            this.Throw('Reference target type must specify an $id');\n        return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: unresolved.$id });\n    }\n    /** `[Json]` Constructs a type where all properties are required */\n    Required(schema, options = {}) {\n        // prettier-ignore\n        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ['$id', exports.Transform]), (object) => {\n            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {\n                return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };\n            }, {});\n            return this.Object(properties, object /* object used as options to retain other constraints  */);\n        }, options);\n    }\n    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */\n    Rest(schema) {\n        return (TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : []);\n    }\n    /** `[Json]` Creates a String type */\n    String(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });\n    }\n    /** `[Json]` Creates a TemplateLiteral type */\n    TemplateLiteral(unresolved, options = {}) {\n        // prettier-ignore\n        const pattern = ValueGuard.IsString(unresolved)\n            ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved))\n            : TemplateLiteralPattern.Create(unresolved);\n        return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });\n    }\n    /** `[Json]` Creates a Transform type */\n    Transform(schema) {\n        return new TransformDecodeBuilder(schema);\n    }\n    /** `[Json]` Creates a Tuple type */\n    Tuple(items, options = {}) {\n        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n        const clonedItems = TypeClone.Rest(items);\n        // prettier-ignore\n        const schema = (items.length > 0 ?\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });\n        return this.Create(schema);\n    }\n    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */\n    Uncapitalize(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Type(schema), 'Uncapitalize'), ...options };\n    }\n    /** `[Json]` Creates a Union type */\n    Union(union, options = {}) {\n        // prettier-ignore\n        return TypeGuard.TTemplateLiteral(union)\n            ? TemplateLiteralResolver.Resolve(union)\n            : (() => {\n                const anyOf = union;\n                if (anyOf.length === 0)\n                    return this.Never(options);\n                if (anyOf.length === 1)\n                    return this.Create(TypeClone.Type(anyOf[0], options));\n                const clonedAnyOf = TypeClone.Rest(anyOf);\n                return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });\n            })();\n    }\n    /** `[Json]` Creates an Unknown type */\n    Unknown(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Unknown' });\n    }\n    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */\n    Unsafe(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });\n    }\n    /** `[Json]` Intrinsic function to Uppercase LiteralString types */\n    Uppercase(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Type(schema), 'Uppercase'), ...options };\n    }\n}\nexports.JsonTypeBuilder = JsonTypeBuilder;\n// --------------------------------------------------------------------------\n// JavaScriptTypeBuilder\n// --------------------------------------------------------------------------\nclass JavaScriptTypeBuilder extends JsonTypeBuilder {\n    /** `[JavaScript]` Creates a AsyncIterator type */\n    AsyncIterator(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'AsyncIterator', type: 'AsyncIterator', items: TypeClone.Type(items) });\n    }\n    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */\n    Awaited(schema, options = {}) {\n        // prettier-ignore\n        const Unwrap = (rest) => rest.length > 0 ? (() => {\n            const [L, ...R] = rest;\n            return [this.Awaited(L), ...Unwrap(R)];\n        })() : rest;\n        // prettier-ignore\n        return (TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) :\n            TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) :\n                TypeGuard.TPromise(schema) ? this.Awaited(schema.item) :\n                    TypeClone.Type(schema, options));\n    }\n    /** `[JavaScript]` Creates a BigInt type */\n    BigInt(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'bigint' });\n    }\n    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */\n    ConstructorParameters(schema, options = {}) {\n        return this.Tuple([...schema.parameters], { ...options });\n    }\n    /** `[JavaScript]` Creates a Constructor type */\n    Constructor(parameters, returns, options) {\n        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];\n        return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'Constructor', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[JavaScript]` Creates a Date type */\n    Date(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Date', type: 'Date' });\n    }\n    /** `[JavaScript]` Creates a Function type */\n    Function(parameters, returns, options) {\n        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];\n        return this.Create({ ...options, [exports.Kind]: 'Function', type: 'Function', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */\n    InstanceType(schema, options = {}) {\n        return TypeClone.Type(schema.returns, options);\n    }\n    /** `[JavaScript]` Creates an Iterator type */\n    Iterator(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Iterator', type: 'Iterator', items: TypeClone.Type(items) });\n    }\n    /** `[JavaScript]` Extracts the Parameters from the given Function type */\n    Parameters(schema, options = {}) {\n        return this.Tuple(schema.parameters, { ...options });\n    }\n    /** `[JavaScript]` Creates a Promise type */\n    Promise(item, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'Promise', item: TypeClone.Type(item) });\n    }\n    /** `[Extended]` Creates a String type */\n    RegExp(unresolved, options = {}) {\n        const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern });\n    }\n    /**\n     * @deprecated Use `Type.RegExp`\n     */\n    RegEx(regex, options = {}) {\n        return this.RegExp(regex, options);\n    }\n    /** `[JavaScript]` Extracts the ReturnType from the given Function type */\n    ReturnType(schema, options = {}) {\n        return TypeClone.Type(schema.returns, options);\n    }\n    /** `[JavaScript]` Creates a Symbol type */\n    Symbol(options) {\n        return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'symbol' });\n    }\n    /** `[JavaScript]` Creates a Undefined type */\n    Undefined(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'undefined' });\n    }\n    /** `[JavaScript]` Creates a Uint8Array type */\n    Uint8Array(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'Uint8Array' });\n    }\n    /** `[JavaScript]` Creates a Void type */\n    Void(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Void', type: 'void' });\n    }\n}\nexports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;\n/** Json Type Builder with Static Resolution for TypeScript */\nexports.JsonType = new JsonTypeBuilder();\n/** JavaScript Type Builder with Static Resolution for TypeScript */\nexports.Type = new JavaScriptTypeBuilder();\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/system\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultErrorFunction = exports.TypeSystemPolicy = exports.TypeSystemErrorFunction = exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;\nconst guard_1 = require(\"../value/guard\");\nconst errors_1 = require(\"../errors/errors\");\nconst Types = require(\"../typebox\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass TypeSystemDuplicateTypeKind extends Types.TypeBoxError {\n    constructor(kind) {\n        super(`Duplicate type kind '${kind}' detected`);\n    }\n}\nexports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;\nclass TypeSystemDuplicateFormat extends Types.TypeBoxError {\n    constructor(kind) {\n        super(`Duplicate string format '${kind}' detected`);\n    }\n}\nexports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;\n// -------------------------------------------------------------------------------------------\n// TypeSystem\n// -------------------------------------------------------------------------------------------\n/** Creates user defined types and formats and provides overrides for value checking behaviours */\nvar TypeSystem;\n(function (TypeSystem) {\n    /** Creates a new type */\n    function Type(kind, check) {\n        if (Types.TypeRegistry.Has(kind))\n            throw new TypeSystemDuplicateTypeKind(kind);\n        Types.TypeRegistry.Set(kind, check);\n        return (options = {}) => Types.Type.Unsafe({ ...options, [Types.Kind]: kind });\n    }\n    TypeSystem.Type = Type;\n    /** Creates a new string format */\n    function Format(format, check) {\n        if (Types.FormatRegistry.Has(format))\n            throw new TypeSystemDuplicateFormat(format);\n        Types.FormatRegistry.Set(format, check);\n        return format;\n    }\n    TypeSystem.Format = Format;\n})(TypeSystem || (exports.TypeSystem = TypeSystem = {}));\n// --------------------------------------------------------------------------\n// TypeSystemErrorFunction\n// --------------------------------------------------------------------------\n/** Manages error message providers */\nvar TypeSystemErrorFunction;\n(function (TypeSystemErrorFunction) {\n    let errorMessageFunction = DefaultErrorFunction;\n    /** Resets the error message function to en-us */\n    function Reset() {\n        errorMessageFunction = DefaultErrorFunction;\n    }\n    TypeSystemErrorFunction.Reset = Reset;\n    /** Sets the error message function used to generate error messages */\n    function Set(callback) {\n        errorMessageFunction = callback;\n    }\n    TypeSystemErrorFunction.Set = Set;\n    /** Gets the error message function */\n    function Get() {\n        return errorMessageFunction;\n    }\n    TypeSystemErrorFunction.Get = Get;\n})(TypeSystemErrorFunction || (exports.TypeSystemErrorFunction = TypeSystemErrorFunction = {}));\n// --------------------------------------------------------------------------\n// TypeSystemPolicy\n// --------------------------------------------------------------------------\n/** Shared assertion routines used by the value and errors modules */\nvar TypeSystemPolicy;\n(function (TypeSystemPolicy) {\n    /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */\n    TypeSystemPolicy.ExactOptionalPropertyTypes = false;\n    /** Sets whether arrays should be treated as a kind of objects. The default is `false` */\n    TypeSystemPolicy.AllowArrayObject = false;\n    /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */\n    TypeSystemPolicy.AllowNaN = false;\n    /** Sets whether `null` should validate for void types. The default is `false` */\n    TypeSystemPolicy.AllowNullVoid = false;\n    /** Asserts this value using the ExactOptionalPropertyTypes policy */\n    function IsExactOptionalProperty(value, key) {\n        return TypeSystemPolicy.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;\n    }\n    TypeSystemPolicy.IsExactOptionalProperty = IsExactOptionalProperty;\n    /** Asserts this value using the AllowArrayObjects policy */\n    function IsObjectLike(value) {\n        const isObject = (0, guard_1.IsObject)(value);\n        return TypeSystemPolicy.AllowArrayObject ? isObject : isObject && !(0, guard_1.IsArray)(value);\n    }\n    TypeSystemPolicy.IsObjectLike = IsObjectLike;\n    /** Asserts this value as a record using the AllowArrayObjects policy */\n    function IsRecordLike(value) {\n        return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);\n    }\n    TypeSystemPolicy.IsRecordLike = IsRecordLike;\n    /** Asserts this value using the AllowNaN policy */\n    function IsNumberLike(value) {\n        const isNumber = (0, guard_1.IsNumber)(value);\n        return TypeSystemPolicy.AllowNaN ? isNumber : isNumber && Number.isFinite(value);\n    }\n    TypeSystemPolicy.IsNumberLike = IsNumberLike;\n    /** Asserts this value using the AllowVoidNull policy */\n    function IsVoidLike(value) {\n        const isUndefined = (0, guard_1.IsUndefined)(value);\n        return TypeSystemPolicy.AllowNullVoid ? isUndefined || value === null : isUndefined;\n    }\n    TypeSystemPolicy.IsVoidLike = IsVoidLike;\n})(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));\n// --------------------------------------------------------------------------\n// DefaultErrorFunction\n// --------------------------------------------------------------------------\n/** Creates an error message using en-US as the default locale */\nfunction DefaultErrorFunction(schema, errorType) {\n    switch (errorType) {\n        case errors_1.ValueErrorType.ArrayContains:\n            return 'Expected array to contain at least one matching value';\n        case errors_1.ValueErrorType.ArrayMaxContains:\n            return `Expected array to contain no more than ${schema.maxContains} matching values`;\n        case errors_1.ValueErrorType.ArrayMinContains:\n            return `Expected array to contain at least ${schema.minContains} matching values`;\n        case errors_1.ValueErrorType.ArrayMaxItems:\n            return `Expected array length to be less or equal to ${schema.maxItems}`;\n        case errors_1.ValueErrorType.ArrayMinItems:\n            return `Expected array length to be greater or equal to ${schema.minItems}`;\n        case errors_1.ValueErrorType.ArrayUniqueItems:\n            return 'Expected array elements to be unique';\n        case errors_1.ValueErrorType.Array:\n            return 'Expected array';\n        case errors_1.ValueErrorType.AsyncIterator:\n            return 'Expected AsyncIterator';\n        case errors_1.ValueErrorType.BigIntExclusiveMaximum:\n            return `Expected bigint to be less than ${schema.exclusiveMaximum}`;\n        case errors_1.ValueErrorType.BigIntExclusiveMinimum:\n            return `Expected bigint to be greater than ${schema.exclusiveMinimum}`;\n        case errors_1.ValueErrorType.BigIntMaximum:\n            return `Expected bigint to be less or equal to ${schema.maximum}`;\n        case errors_1.ValueErrorType.BigIntMinimum:\n            return `Expected bigint to be greater or equal to ${schema.minimum}`;\n        case errors_1.ValueErrorType.BigIntMultipleOf:\n            return `Expected bigint to be a multiple of ${schema.multipleOf}`;\n        case errors_1.ValueErrorType.BigInt:\n            return 'Expected bigint';\n        case errors_1.ValueErrorType.Boolean:\n            return 'Expected boolean';\n        case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:\n            return `Expected Date timestamp to be greater than ${schema.exclusiveMinimumTimestamp}`;\n        case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:\n            return `Expected Date timestamp to be less than ${schema.exclusiveMaximumTimestamp}`;\n        case errors_1.ValueErrorType.DateMinimumTimestamp:\n            return `Expected Date timestamp to be greater or equal to ${schema.minimumTimestamp}`;\n        case errors_1.ValueErrorType.DateMaximumTimestamp:\n            return `Expected Date timestamp to be less or equal to ${schema.maximumTimestamp}`;\n        case errors_1.ValueErrorType.DateMultipleOfTimestamp:\n            return `Expected Date timestamp to be a multiple of ${schema.multipleOfTimestamp}`;\n        case errors_1.ValueErrorType.Date:\n            return 'Expected Date';\n        case errors_1.ValueErrorType.Function:\n            return 'Expected function';\n        case errors_1.ValueErrorType.IntegerExclusiveMaximum:\n            return `Expected integer to be less than ${schema.exclusiveMaximum}`;\n        case errors_1.ValueErrorType.IntegerExclusiveMinimum:\n            return `Expected integer to be greater than ${schema.exclusiveMinimum}`;\n        case errors_1.ValueErrorType.IntegerMaximum:\n            return `Expected integer to be less or equal to ${schema.maximum}`;\n        case errors_1.ValueErrorType.IntegerMinimum:\n            return `Expected integer to be greater or equal to ${schema.minimum}`;\n        case errors_1.ValueErrorType.IntegerMultipleOf:\n            return `Expected integer to be a multiple of ${schema.multipleOf}`;\n        case errors_1.ValueErrorType.Integer:\n            return 'Expected integer';\n        case errors_1.ValueErrorType.IntersectUnevaluatedProperties:\n            return 'Unexpected property';\n        case errors_1.ValueErrorType.Intersect:\n            return 'Expected all values to match';\n        case errors_1.ValueErrorType.Iterator:\n            return 'Expected Iterator';\n        case errors_1.ValueErrorType.Literal:\n            return `Expected ${typeof schema.const === 'string' ? `'${schema.const}'` : schema.const}`;\n        case errors_1.ValueErrorType.Never:\n            return 'Never';\n        case errors_1.ValueErrorType.Not:\n            return 'Value should not match';\n        case errors_1.ValueErrorType.Null:\n            return 'Expected null';\n        case errors_1.ValueErrorType.NumberExclusiveMaximum:\n            return `Expected number to be less than ${schema.exclusiveMaximum}`;\n        case errors_1.ValueErrorType.NumberExclusiveMinimum:\n            return `Expected number to be greater than ${schema.exclusiveMinimum}`;\n        case errors_1.ValueErrorType.NumberMaximum:\n            return `Expected number to be less or equal to ${schema.maximum}`;\n        case errors_1.ValueErrorType.NumberMinimum:\n            return `Expected number to be greater or equal to ${schema.minimum}`;\n        case errors_1.ValueErrorType.NumberMultipleOf:\n            return `Expected number to be a multiple of ${schema.multipleOf}`;\n        case errors_1.ValueErrorType.Number:\n            return 'Expected number';\n        case errors_1.ValueErrorType.Object:\n            return 'Expected object';\n        case errors_1.ValueErrorType.ObjectAdditionalProperties:\n            return 'Unexpected property';\n        case errors_1.ValueErrorType.ObjectMaxProperties:\n            return `Expected object to have no more than ${schema.maxProperties} properties`;\n        case errors_1.ValueErrorType.ObjectMinProperties:\n            return `Expected object to have at least ${schema.minProperties} properties`;\n        case errors_1.ValueErrorType.ObjectRequiredProperty:\n            return 'Required property';\n        case errors_1.ValueErrorType.Promise:\n            return 'Expected Promise';\n        case errors_1.ValueErrorType.StringFormatUnknown:\n            return `Unknown format '${schema.format}'`;\n        case errors_1.ValueErrorType.StringFormat:\n            return `Expected string to match '${schema.format}' format`;\n        case errors_1.ValueErrorType.StringMaxLength:\n            return `Expected string length less or equal to ${schema.maxLength}`;\n        case errors_1.ValueErrorType.StringMinLength:\n            return `Expected string length greater or equal to ${schema.minLength}`;\n        case errors_1.ValueErrorType.StringPattern:\n            return `Expected string to match '${schema.pattern}'`;\n        case errors_1.ValueErrorType.String:\n            return 'Expected string';\n        case errors_1.ValueErrorType.Symbol:\n            return 'Expected symbol';\n        case errors_1.ValueErrorType.TupleLength:\n            return `Expected tuple to have ${schema.maxItems || 0} elements`;\n        case errors_1.ValueErrorType.Tuple:\n            return 'Expected tuple';\n        case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:\n            return `Expected byte length less or equal to ${schema.maxByteLength}`;\n        case errors_1.ValueErrorType.Uint8ArrayMinByteLength:\n            return `Expected byte length greater or equal to ${schema.minByteLength}`;\n        case errors_1.ValueErrorType.Uint8Array:\n            return 'Expected Uint8Array';\n        case errors_1.ValueErrorType.Undefined:\n            return 'Expected undefined';\n        case errors_1.ValueErrorType.Union:\n            return 'Expected union value';\n        case errors_1.ValueErrorType.Void:\n            return 'Expected void';\n        case errors_1.ValueErrorType.Kind:\n            return `Expected kind '${schema[Types.Kind]}'`;\n        default:\n            return 'Unknown error type';\n    }\n}\nexports.DefaultErrorFunction = DefaultErrorFunction;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Deref = exports.TypeDereferenceError = void 0;\nconst typebox_1 = require(\"../typebox\");\nclass TypeDereferenceError extends typebox_1.TypeBoxError {\n    constructor(schema) {\n        super(`Unable to dereference schema with $id '${schema.$id}'`);\n        this.schema = schema;\n    }\n}\nexports.TypeDereferenceError = TypeDereferenceError;\n/** Dereferences a schema from the references array or throws if not found */\nfunction Deref(schema, references) {\n    const index = references.findIndex((target) => target.$id === schema.$ref);\n    if (index === -1)\n        throw new TypeDereferenceError(schema);\n    return references[index];\n}\nexports.Deref = Deref;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hash = exports.ByteMarker = exports.ValueHashError = void 0;\nconst guard_1 = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueHashError extends Error {\n    constructor(value) {\n        super(`Unable to hash value`);\n        this.value = value;\n    }\n}\nexports.ValueHashError = ValueHashError;\n// --------------------------------------------------------------------------\n// ByteMarker\n// --------------------------------------------------------------------------\nvar ByteMarker;\n(function (ByteMarker) {\n    ByteMarker[ByteMarker[\"Undefined\"] = 0] = \"Undefined\";\n    ByteMarker[ByteMarker[\"Null\"] = 1] = \"Null\";\n    ByteMarker[ByteMarker[\"Boolean\"] = 2] = \"Boolean\";\n    ByteMarker[ByteMarker[\"Number\"] = 3] = \"Number\";\n    ByteMarker[ByteMarker[\"String\"] = 4] = \"String\";\n    ByteMarker[ByteMarker[\"Object\"] = 5] = \"Object\";\n    ByteMarker[ByteMarker[\"Array\"] = 6] = \"Array\";\n    ByteMarker[ByteMarker[\"Date\"] = 7] = \"Date\";\n    ByteMarker[ByteMarker[\"Uint8Array\"] = 8] = \"Uint8Array\";\n    ByteMarker[ByteMarker[\"Symbol\"] = 9] = \"Symbol\";\n    ByteMarker[ByteMarker[\"BigInt\"] = 10] = \"BigInt\";\n})(ByteMarker || (exports.ByteMarker = ByteMarker = {}));\n// --------------------------------------------------------------------------\n// State\n// --------------------------------------------------------------------------\nlet Accumulator = BigInt('14695981039346656037');\nconst [Prime, Size] = [BigInt('1099511628211'), BigInt('2') ** BigInt('64')];\nconst Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));\nconst F64 = new Float64Array(1);\nconst F64In = new DataView(F64.buffer);\nconst F64Out = new Uint8Array(F64.buffer);\n// --------------------------------------------------------------------------\n// NumberToBytes\n// --------------------------------------------------------------------------\nfunction* NumberToBytes(value) {\n    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);\n    for (let i = 0; i < byteCount; i++) {\n        yield (value >> (8 * (byteCount - 1 - i))) & 0xff;\n    }\n}\n// --------------------------------------------------------------------------\n// Hashing Functions\n// --------------------------------------------------------------------------\nfunction ArrayType(value) {\n    FNV1A64(ByteMarker.Array);\n    for (const item of value) {\n        Visit(item);\n    }\n}\nfunction BooleanType(value) {\n    FNV1A64(ByteMarker.Boolean);\n    FNV1A64(value ? 1 : 0);\n}\nfunction BigIntType(value) {\n    FNV1A64(ByteMarker.BigInt);\n    F64In.setBigInt64(0, value);\n    for (const byte of F64Out) {\n        FNV1A64(byte);\n    }\n}\nfunction DateType(value) {\n    FNV1A64(ByteMarker.Date);\n    Visit(value.getTime());\n}\nfunction NullType(value) {\n    FNV1A64(ByteMarker.Null);\n}\nfunction NumberType(value) {\n    FNV1A64(ByteMarker.Number);\n    F64In.setFloat64(0, value);\n    for (const byte of F64Out) {\n        FNV1A64(byte);\n    }\n}\nfunction ObjectType(value) {\n    FNV1A64(ByteMarker.Object);\n    for (const key of globalThis.Object.keys(value).sort()) {\n        Visit(key);\n        Visit(value[key]);\n    }\n}\nfunction StringType(value) {\n    FNV1A64(ByteMarker.String);\n    for (let i = 0; i < value.length; i++) {\n        for (const byte of NumberToBytes(value.charCodeAt(i))) {\n            FNV1A64(byte);\n        }\n    }\n}\nfunction SymbolType(value) {\n    FNV1A64(ByteMarker.Symbol);\n    Visit(value.description);\n}\nfunction Uint8ArrayType(value) {\n    FNV1A64(ByteMarker.Uint8Array);\n    for (let i = 0; i < value.length; i++) {\n        FNV1A64(value[i]);\n    }\n}\nfunction UndefinedType(value) {\n    return FNV1A64(ByteMarker.Undefined);\n}\nfunction Visit(value) {\n    if ((0, guard_1.IsArray)(value))\n        return ArrayType(value);\n    if ((0, guard_1.IsBoolean)(value))\n        return BooleanType(value);\n    if ((0, guard_1.IsBigInt)(value))\n        return BigIntType(value);\n    if ((0, guard_1.IsDate)(value))\n        return DateType(value);\n    if ((0, guard_1.IsNull)(value))\n        return NullType(value);\n    if ((0, guard_1.IsNumber)(value))\n        return NumberType(value);\n    if ((0, guard_1.IsPlainObject)(value))\n        return ObjectType(value);\n    if ((0, guard_1.IsString)(value))\n        return StringType(value);\n    if ((0, guard_1.IsSymbol)(value))\n        return SymbolType(value);\n    if ((0, guard_1.IsUint8Array)(value))\n        return Uint8ArrayType(value);\n    if ((0, guard_1.IsUndefined)(value))\n        return UndefinedType(value);\n    throw new ValueHashError(value);\n}\nfunction FNV1A64(byte) {\n    Accumulator = Accumulator ^ Bytes[byte];\n    Accumulator = (Accumulator * Prime) % Size;\n}\n// --------------------------------------------------------------------------\n// Hash\n// --------------------------------------------------------------------------\n/** Creates a FNV1A-64 non cryptographic hash of the given value */\nfunction Hash(value) {\n    Accumulator = BigInt('14695981039346656037');\n    Visit(value);\n    return Accumulator;\n}\nexports.Hash = Hash;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/errors\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Errors = exports.ValueErrorIterator = exports.EscapeKey = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;\nconst guard_1 = require(\"../value/guard\");\nconst system_1 = require(\"../system/system\");\nconst deref_1 = require(\"../value/deref\");\nconst hash_1 = require(\"../value/hash\");\nconst Types = require(\"../typebox\");\n// --------------------------------------------------------------------------\n// ValueErrorType\n// --------------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 48] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 49] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 50] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 51] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 52] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"String\"] = 53] = \"String\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 54] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 55] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Tuple\"] = 56] = \"Tuple\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 57] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 58] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 59] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 60] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 61] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 62] = \"Void\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// --------------------------------------------------------------------------\n// ValueErrors\n// --------------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\n// --------------------------------------------------------------------------\n// EscapeKey\n// --------------------------------------------------------------------------\nfunction EscapeKey(key) {\n    return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\nexports.EscapeKey = EscapeKey;\n// --------------------------------------------------------------------------\n// Guards\n// --------------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// --------------------------------------------------------------------------\n// ValueErrorIterator\n// --------------------------------------------------------------------------\nclass ValueErrorIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(type, schema, path, value) {\n    return { type, schema, path, value, message: system_1.TypeSystemErrorFunction.Get()(schema, type) };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* TAny(schema, references, path, value) { }\nfunction* TArray(schema, references, path, value) {\n    if (!(0, guard_1.IsArray)(value)) {\n        return yield Create(ValueErrorType.Array, schema, path, value);\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = (0, hash_1.Hash)(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield Create(ValueErrorType.ArrayContains, schema, path, value);\n    }\n    if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n    }\n    if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n    }\n}\nfunction* TAsyncIterator(schema, references, path, value) {\n    if (!(0, guard_1.IsAsyncIterator)(value))\n        yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* TBigInt(schema, references, path, value) {\n    if (!(0, guard_1.IsBigInt)(value))\n        return yield Create(ValueErrorType.BigInt, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n    }\n}\nfunction* TBoolean(schema, references, path, value) {\n    if (!(0, guard_1.IsBoolean)(value))\n        yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* TConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* TDate(schema, references, path, value) {\n    if (!(0, guard_1.IsDate)(value))\n        return yield Create(ValueErrorType.Date, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n    }\n}\nfunction* TFunction(schema, references, path, value) {\n    if (!(0, guard_1.IsFunction)(value))\n        yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* TInteger(schema, references, path, value) {\n    if (!(0, guard_1.IsInteger)(value))\n        return yield Create(ValueErrorType.Integer, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n    }\n}\nfunction* TIntersect(schema, references, path, value) {\n    for (const inner of schema.allOf) {\n        const next = Visit(inner, references, path, value).next();\n        if (!next.done) {\n            yield Create(ValueErrorType.Intersect, schema, path, value);\n            yield next.value;\n        }\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done)\n                    yield next.value; // yield interior\n            }\n        }\n    }\n}\nfunction* TIterator(schema, references, path, value) {\n    if (!(0, guard_1.IsIterator)(value))\n        yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* TLiteral(schema, references, path, value) {\n    if (!(value === schema.const))\n        yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* TNever(schema, references, path, value) {\n    yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* TNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true)\n        yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* TNull(schema, references, path, value) {\n    if (!(0, guard_1.IsNull)(value))\n        yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* TNumber(schema, references, path, value) {\n    if (!system_1.TypeSystemPolicy.IsNumberLike(value))\n        return yield Create(ValueErrorType.Number, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n    }\n}\nfunction* TObject(schema, references, path, value) {\n    if (!system_1.TypeSystemPolicy.IsObjectLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n        }\n    }\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {\n                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n            }\n        }\n        else {\n            if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            }\n        }\n    }\n}\nfunction* TPromise(schema, references, path, value) {\n    if (!(0, guard_1.IsPromise)(value))\n        yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* TRecord(schema, references, path, value) {\n    if (!system_1.TypeSystemPolicy.IsRecordLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey))\n            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (!regex.test(propertyKey))\n                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n    if (schema.additionalProperties === false) {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (regex.test(propertyKey))\n                continue;\n            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n}\nfunction* TRef(schema, references, path, value) {\n    yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);\n}\nfunction* TString(schema, references, path, value) {\n    if (!(0, guard_1.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    if ((0, guard_1.IsString)(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield Create(ValueErrorType.StringPattern, schema, path, value);\n        }\n    }\n    if ((0, guard_1.IsString)(schema.format)) {\n        if (!Types.FormatRegistry.Has(schema.format)) {\n            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n        }\n        else {\n            const format = Types.FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield Create(ValueErrorType.StringFormat, schema, path, value);\n            }\n        }\n    }\n}\nfunction* TSymbol(schema, references, path, value) {\n    if (!(0, guard_1.IsSymbol)(value))\n        yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* TTemplateLiteral(schema, references, path, value) {\n    if (!(0, guard_1.IsString)(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n}\nfunction* TThis(schema, references, path, value) {\n    yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);\n}\nfunction* TTuple(schema, references, path, value) {\n    if (!(0, guard_1.IsArray)(value))\n        return yield Create(ValueErrorType.Tuple, schema, path, value);\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!(value.length === schema.maxItems)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* TUndefined(schema, references, path, value) {\n    if (!(0, guard_1.IsUndefined)(value))\n        yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* TUnion(schema, references, path, value) {\n    let count = 0;\n    for (const subschema of schema.anyOf) {\n        const errors = [...Visit(subschema, references, path, value)];\n        if (errors.length === 0)\n            return; // matched\n        count += errors.length;\n    }\n    if (count > 0) {\n        yield Create(ValueErrorType.Union, schema, path, value);\n    }\n}\nfunction* TUint8Array(schema, references, path, value) {\n    if (!(0, guard_1.IsUint8Array)(value))\n        return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n    }\n}\nfunction* TUnknown(schema, references, path, value) { }\nfunction* TVoid(schema, references, path, value) {\n    if (!system_1.TypeSystemPolicy.IsVoidLike(value))\n        yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* TKind(schema, references, path, value) {\n    const check = Types.TypeRegistry.Get(schema[Types.Kind]);\n    if (!check(schema, value))\n        yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Types.Kind]) {\n        case 'Any':\n            return yield* TAny(schema_, references_, path, value);\n        case 'Array':\n            return yield* TArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* TAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* TBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* TBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* TConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* TDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* TFunction(schema_, references_, path, value);\n        case 'Integer':\n            return yield* TInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* TIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* TIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* TLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* TNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* TNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* TNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* TNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* TObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* TPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* TRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* TRef(schema_, references_, path, value);\n        case 'String':\n            return yield* TString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* TSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* TTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* TThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* TTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* TUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* TUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* TUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* TUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* TVoid(schema_, references_, path, value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* TKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\nexports.Errors = Errors;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/errors\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./errors\"), exports);\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValuePointer = exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = void 0;\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValuePointerRootSetError extends Error {\n    constructor(value, path, update) {\n        super('Cannot set root value');\n        this.value = value;\n        this.path = path;\n        this.update = update;\n    }\n}\nexports.ValuePointerRootSetError = ValuePointerRootSetError;\nclass ValuePointerRootDeleteError extends Error {\n    constructor(value, path) {\n        super('Cannot delete root value');\n        this.value = value;\n        this.path = path;\n    }\n}\nexports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;\n// --------------------------------------------------------------------------\n// ValuePointer\n// --------------------------------------------------------------------------\n/** Provides functionality to update values through RFC6901 string pointers */\nvar ValuePointer;\n(function (ValuePointer) {\n    function Escape(component) {\n        return component.indexOf('~') === -1 ? component : component.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n    /** Formats the given pointer into navigable key components */\n    function* Format(pointer) {\n        if (pointer === '')\n            return;\n        let [start, end] = [0, 0];\n        for (let i = 0; i < pointer.length; i++) {\n            const char = pointer.charAt(i);\n            if (char === '/') {\n                if (i === 0) {\n                    start = i + 1;\n                }\n                else {\n                    end = i;\n                    yield Escape(pointer.slice(start, end));\n                    start = i + 1;\n                }\n            }\n            else {\n                end = i;\n            }\n        }\n        yield Escape(pointer.slice(start));\n    }\n    ValuePointer.Format = Format;\n    /** Sets the value at the given pointer. If the value at the pointer does not exist it is created */\n    function Set(value, pointer, update) {\n        if (pointer === '')\n            throw new ValuePointerRootSetError(value, pointer, update);\n        let [owner, next, key] = [null, value, ''];\n        for (const component of Format(pointer)) {\n            if (next[component] === undefined)\n                next[component] = {};\n            owner = next;\n            next = next[component];\n            key = component;\n        }\n        owner[key] = update;\n    }\n    ValuePointer.Set = Set;\n    /** Deletes a value at the given pointer */\n    function Delete(value, pointer) {\n        if (pointer === '')\n            throw new ValuePointerRootDeleteError(value, pointer);\n        let [owner, next, key] = [null, value, ''];\n        for (const component of Format(pointer)) {\n            if (next[component] === undefined || next[component] === null)\n                return;\n            owner = next;\n            next = next[component];\n            key = component;\n        }\n        if (Array.isArray(owner)) {\n            const index = parseInt(key);\n            owner.splice(index, 1);\n        }\n        else {\n            delete owner[key];\n        }\n    }\n    ValuePointer.Delete = Delete;\n    /** Returns true if a value exists at the given pointer */\n    function Has(value, pointer) {\n        if (pointer === '')\n            return true;\n        let [owner, next, key] = [null, value, ''];\n        for (const component of Format(pointer)) {\n            if (next[component] === undefined)\n                return false;\n            owner = next;\n            next = next[component];\n            key = component;\n        }\n        return Object.getOwnPropertyNames(owner).includes(key);\n    }\n    ValuePointer.Has = Has;\n    /** Gets the value at the given pointer */\n    function Get(value, pointer) {\n        if (pointer === '')\n            return value;\n        let current = value;\n        for (const component of Format(pointer)) {\n            if (current[component] === undefined)\n                return undefined;\n            current = current[component];\n        }\n        return current;\n    }\n    ValuePointer.Get = Get;\n})(ValuePointer || (exports.ValuePointer = ValuePointer = {}));\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Clone = void 0;\nconst guard_1 = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Clonable\n// --------------------------------------------------------------------------\nfunction ObjectType(value) {\n    const keys = [...Object.getOwnPropertyNames(value), ...Object.getOwnPropertySymbols(value)];\n    return keys.reduce((acc, key) => ({ ...acc, [key]: Clone(value[key]) }), {});\n}\nfunction ArrayType(value) {\n    return value.map((element) => Clone(element));\n}\nfunction TypedArrayType(value) {\n    return value.slice();\n}\nfunction DateType(value) {\n    return new Date(value.toISOString());\n}\nfunction ValueType(value) {\n    return value;\n}\n// --------------------------------------------------------------------------\n// Clone\n// --------------------------------------------------------------------------\n/** Returns a clone of the given value */\nfunction Clone(value) {\n    if ((0, guard_1.IsArray)(value))\n        return ArrayType(value);\n    if ((0, guard_1.IsDate)(value))\n        return DateType(value);\n    if ((0, guard_1.IsPlainObject)(value))\n        return ObjectType(value);\n    if ((0, guard_1.IsTypedArray)(value))\n        return TypedArrayType(value);\n    if ((0, guard_1.IsValueType)(value))\n        return ValueType(value);\n    throw new Error('ValueClone: Unable to clone value');\n}\nexports.Clone = Clone;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Patch = exports.Diff = exports.ValueDeltaUnableToDiffUnknownValue = exports.ValueDeltaObjectWithSymbolKeyError = exports.Edit = exports.Delete = exports.Update = exports.Insert = void 0;\nconst guard_1 = require(\"./guard\");\nconst typebox_1 = require(\"../typebox\");\nconst pointer_1 = require(\"./pointer\");\nconst clone_1 = require(\"./clone\");\nexports.Insert = typebox_1.Type.Object({\n    type: typebox_1.Type.Literal('insert'),\n    path: typebox_1.Type.String(),\n    value: typebox_1.Type.Unknown(),\n});\nexports.Update = typebox_1.Type.Object({\n    type: typebox_1.Type.Literal('update'),\n    path: typebox_1.Type.String(),\n    value: typebox_1.Type.Unknown(),\n});\nexports.Delete = typebox_1.Type.Object({\n    type: typebox_1.Type.Literal('delete'),\n    path: typebox_1.Type.String(),\n});\nexports.Edit = typebox_1.Type.Union([exports.Insert, exports.Update, exports.Delete]);\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueDeltaObjectWithSymbolKeyError extends Error {\n    constructor(key) {\n        super('Cannot diff objects with symbol keys');\n        this.key = key;\n    }\n}\nexports.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;\nclass ValueDeltaUnableToDiffUnknownValue extends Error {\n    constructor(value) {\n        super('Unable to create diff edits for unknown value');\n        this.value = value;\n    }\n}\nexports.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;\n// --------------------------------------------------------------------------\n// Command Factory\n// --------------------------------------------------------------------------\nfunction CreateUpdate(path, value) {\n    return { type: 'update', path, value };\n}\nfunction CreateInsert(path, value) {\n    return { type: 'insert', path, value };\n}\nfunction CreateDelete(path) {\n    return { type: 'delete', path };\n}\n// --------------------------------------------------------------------------\n// Diffing Generators\n// --------------------------------------------------------------------------\nfunction* ObjectType(path, current, next) {\n    if (!(0, guard_1.IsPlainObject)(next))\n        return yield CreateUpdate(path, next);\n    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];\n    const nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];\n    for (const key of currentKeys) {\n        if ((0, guard_1.IsSymbol)(key))\n            throw new ValueDeltaObjectWithSymbolKeyError(key);\n        if ((0, guard_1.IsUndefined)(next[key]) && nextKeys.includes(key))\n            yield CreateUpdate(`${path}/${String(key)}`, undefined);\n    }\n    for (const key of nextKeys) {\n        if ((0, guard_1.IsUndefined)(current[key]) || (0, guard_1.IsUndefined)(next[key]))\n            continue;\n        if ((0, guard_1.IsSymbol)(key))\n            throw new ValueDeltaObjectWithSymbolKeyError(key);\n        yield* Visit(`${path}/${String(key)}`, current[key], next[key]);\n    }\n    for (const key of nextKeys) {\n        if ((0, guard_1.IsSymbol)(key))\n            throw new ValueDeltaObjectWithSymbolKeyError(key);\n        if ((0, guard_1.IsUndefined)(current[key]))\n            yield CreateInsert(`${path}/${String(key)}`, next[key]);\n    }\n    for (const key of currentKeys.reverse()) {\n        if ((0, guard_1.IsSymbol)(key))\n            throw new ValueDeltaObjectWithSymbolKeyError(key);\n        if ((0, guard_1.IsUndefined)(next[key]) && !nextKeys.includes(key))\n            yield CreateDelete(`${path}/${String(key)}`);\n    }\n}\nfunction* ArrayType(path, current, next) {\n    if (!(0, guard_1.IsArray)(next))\n        return yield CreateUpdate(path, next);\n    for (let i = 0; i < Math.min(current.length, next.length); i++) {\n        yield* Visit(`${path}/${i}`, current[i], next[i]);\n    }\n    for (let i = 0; i < next.length; i++) {\n        if (i < current.length)\n            continue;\n        yield CreateInsert(`${path}/${i}`, next[i]);\n    }\n    for (let i = current.length - 1; i >= 0; i--) {\n        if (i < next.length)\n            continue;\n        yield CreateDelete(`${path}/${i}`);\n    }\n}\nfunction* TypedArrayType(path, current, next) {\n    if (!(0, guard_1.IsTypedArray)(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name)\n        return yield CreateUpdate(path, next);\n    for (let i = 0; i < Math.min(current.length, next.length); i++) {\n        yield* Visit(`${path}/${i}`, current[i], next[i]);\n    }\n}\nfunction* ValueType(path, current, next) {\n    if (current === next)\n        return;\n    yield CreateUpdate(path, next);\n}\nfunction* Visit(path, current, next) {\n    if ((0, guard_1.IsPlainObject)(current))\n        return yield* ObjectType(path, current, next);\n    if ((0, guard_1.IsArray)(current))\n        return yield* ArrayType(path, current, next);\n    if ((0, guard_1.IsTypedArray)(current))\n        return yield* TypedArrayType(path, current, next);\n    if ((0, guard_1.IsValueType)(current))\n        return yield* ValueType(path, current, next);\n    throw new ValueDeltaUnableToDiffUnknownValue(current);\n}\n// ---------------------------------------------------------------------\n// Diff\n// ---------------------------------------------------------------------\nfunction Diff(current, next) {\n    return [...Visit('', current, next)];\n}\nexports.Diff = Diff;\n// ---------------------------------------------------------------------\n// Patch\n// ---------------------------------------------------------------------\nfunction IsRootUpdate(edits) {\n    return edits.length > 0 && edits[0].path === '' && edits[0].type === 'update';\n}\nfunction IsIdentity(edits) {\n    return edits.length === 0;\n}\nfunction Patch(current, edits) {\n    if (IsRootUpdate(edits)) {\n        return (0, clone_1.Clone)(edits[0].value);\n    }\n    if (IsIdentity(edits)) {\n        return (0, clone_1.Clone)(current);\n    }\n    const clone = (0, clone_1.Clone)(current);\n    for (const edit of edits) {\n        switch (edit.type) {\n            case 'insert': {\n                pointer_1.ValuePointer.Set(clone, edit.path, edit.value);\n                break;\n            }\n            case 'update': {\n                pointer_1.ValuePointer.Set(clone, edit.path, edit.value);\n                break;\n            }\n            case 'delete': {\n                pointer_1.ValuePointer.Delete(clone, edit.path);\n                break;\n            }\n        }\n    }\n    return clone;\n}\nexports.Patch = Patch;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Mutate = exports.ValueMutateInvalidRootMutationError = exports.ValueMutateTypeMismatchError = void 0;\nconst guard_1 = require(\"./guard\");\nconst pointer_1 = require(\"./pointer\");\nconst clone_1 = require(\"./clone\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueMutateTypeMismatchError extends Error {\n    constructor() {\n        super('Cannot assign due type mismatch of assignable values');\n    }\n}\nexports.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;\nclass ValueMutateInvalidRootMutationError extends Error {\n    constructor() {\n        super('Only object and array types can be mutated at the root level');\n    }\n}\nexports.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;\nfunction ObjectType(root, path, current, next) {\n    if (!(0, guard_1.IsPlainObject)(current)) {\n        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));\n    }\n    else {\n        const currentKeys = Object.keys(current);\n        const nextKeys = Object.keys(next);\n        for (const currentKey of currentKeys) {\n            if (!nextKeys.includes(currentKey)) {\n                delete current[currentKey];\n            }\n        }\n        for (const nextKey of nextKeys) {\n            if (!currentKeys.includes(nextKey)) {\n                current[nextKey] = null;\n            }\n        }\n        for (const nextKey of nextKeys) {\n            Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);\n        }\n    }\n}\nfunction ArrayType(root, path, current, next) {\n    if (!(0, guard_1.IsArray)(current)) {\n        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));\n    }\n    else {\n        for (let index = 0; index < next.length; index++) {\n            Visit(root, `${path}/${index}`, current[index], next[index]);\n        }\n        current.splice(next.length);\n    }\n}\nfunction TypedArrayType(root, path, current, next) {\n    if ((0, guard_1.IsTypedArray)(current) && current.length === next.length) {\n        for (let i = 0; i < current.length; i++) {\n            current[i] = next[i];\n        }\n    }\n    else {\n        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));\n    }\n}\nfunction ValueType(root, path, current, next) {\n    if (current === next)\n        return;\n    pointer_1.ValuePointer.Set(root, path, next);\n}\nfunction Visit(root, path, current, next) {\n    if ((0, guard_1.IsArray)(next))\n        return ArrayType(root, path, current, next);\n    if ((0, guard_1.IsTypedArray)(next))\n        return TypedArrayType(root, path, current, next);\n    if ((0, guard_1.IsPlainObject)(next))\n        return ObjectType(root, path, current, next);\n    if ((0, guard_1.IsValueType)(next))\n        return ValueType(root, path, current, next);\n}\n// --------------------------------------------------------------------------\n// Mutate\n// --------------------------------------------------------------------------\nfunction IsNonMutableValue(value) {\n    return (0, guard_1.IsTypedArray)(value) || (0, guard_1.IsValueType)(value);\n}\nfunction IsMismatchedValue(current, next) {\n    // prettier-ignore\n    return (((0, guard_1.IsPlainObject)(current) && (0, guard_1.IsArray)(next)) ||\n        ((0, guard_1.IsArray)(current) && (0, guard_1.IsPlainObject)(next)));\n}\n// --------------------------------------------------------------------------\n// Mutate\n// --------------------------------------------------------------------------\n/** Performs a deep mutable value assignment while retaining internal references */\nfunction Mutate(current, next) {\n    if (IsNonMutableValue(current) || IsNonMutableValue(next))\n        throw new ValueMutateInvalidRootMutationError();\n    if (IsMismatchedValue(current, next))\n        throw new ValueMutateTypeMismatchError();\n    Visit(current, '', current, next);\n}\nexports.Mutate = Mutate;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Equal = void 0;\nconst guard_1 = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Equality Checks\n// --------------------------------------------------------------------------\nfunction ObjectType(left, right) {\n    if (!(0, guard_1.IsPlainObject)(right))\n        return false;\n    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];\n    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];\n    if (leftKeys.length !== rightKeys.length)\n        return false;\n    return leftKeys.every((key) => Equal(left[key], right[key]));\n}\nfunction DateType(left, right) {\n    return (0, guard_1.IsDate)(right) && left.getTime() === right.getTime();\n}\nfunction ArrayType(left, right) {\n    if (!(0, guard_1.IsArray)(right) || left.length !== right.length)\n        return false;\n    return left.every((value, index) => Equal(value, right[index]));\n}\nfunction TypedArrayType(left, right) {\n    if (!(0, guard_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)\n        return false;\n    return left.every((value, index) => Equal(value, right[index]));\n}\nfunction ValueType(left, right) {\n    return left === right;\n}\n// --------------------------------------------------------------------------\n// Equal\n// --------------------------------------------------------------------------\n/** Returns true if the left value deep-equals the right */\nfunction Equal(left, right) {\n    if ((0, guard_1.IsPlainObject)(left))\n        return ObjectType(left, right);\n    if ((0, guard_1.IsDate)(left))\n        return DateType(left, right);\n    if ((0, guard_1.IsTypedArray)(left))\n        return TypedArrayType(left, right);\n    if ((0, guard_1.IsArray)(left))\n        return ArrayType(left, right);\n    if ((0, guard_1.IsValueType)(left))\n        return ValueType(left, right);\n    throw new Error('ValueEquals: Unable to compare value');\n}\nexports.Equal = Equal;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/system\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueErrorType = void 0;\nvar errors_1 = require(\"../errors/errors\");\nObject.defineProperty(exports, \"ValueErrorType\", { enumerable: true, get: function () { return errors_1.ValueErrorType; } });\n__exportStar(require(\"./system\"), exports);\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Check = exports.ValueCheckUnknownTypeError = void 0;\nconst guard_1 = require(\"./guard\");\nconst index_1 = require(\"../system/index\");\nconst deref_1 = require(\"./deref\");\nconst hash_1 = require(\"./hash\");\nconst Types = require(\"../typebox\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueCheckUnknownTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super(`Unknown type`);\n        this.schema = schema;\n    }\n}\nexports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;\n// --------------------------------------------------------------------------\n// TypeGuards\n// --------------------------------------------------------------------------\nfunction IsAnyOrUnknown(schema) {\n    return schema[Types.Kind] === 'Any' || schema[Types.Kind] === 'Unknown';\n}\n// --------------------------------------------------------------------------\n// Guards\n// --------------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction TAny(schema, references, value) {\n    return true;\n}\nfunction TArray(schema, references, value) {\n    if (!(0, guard_1.IsArray)(value))\n        return false;\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        return false;\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        return false;\n    }\n    if (!value.every((value) => Visit(schema.items, references, value))) {\n        return false;\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = (0, hash_1.Hash)(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        return false;\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains))) {\n        return true; // exit\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();\n    const containsCount = value.reduce((acc, value) => (Visit(containsSchema, references, value) ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        return false;\n    }\n    if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {\n        return false;\n    }\n    if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {\n        return false;\n    }\n    return true;\n}\nfunction TAsyncIterator(schema, references, value) {\n    return (0, guard_1.IsAsyncIterator)(value);\n}\nfunction TBigInt(schema, references, value) {\n    if (!(0, guard_1.IsBigInt)(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        return false;\n    }\n    return true;\n}\nfunction TBoolean(schema, references, value) {\n    return (0, guard_1.IsBoolean)(value);\n}\nfunction TConstructor(schema, references, value) {\n    return Visit(schema.returns, references, value.prototype);\n}\nfunction TDate(schema, references, value) {\n    if (!(0, guard_1.IsDate)(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction TFunction(schema, references, value) {\n    return (0, guard_1.IsFunction)(value);\n}\nfunction TInteger(schema, references, value) {\n    if (!(0, guard_1.IsInteger)(value)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction TIntersect(schema, references, value) {\n    const check1 = schema.allOf.every((schema) => Visit(schema, references, value));\n    if (schema.unevaluatedProperties === false) {\n        const keyPattern = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));\n        return check1 && check2;\n    }\n    else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {\n        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));\n        return check1 && check2;\n    }\n    else {\n        return check1;\n    }\n}\nfunction TIterator(schema, references, value) {\n    return (0, guard_1.IsIterator)(value);\n}\nfunction TLiteral(schema, references, value) {\n    return value === schema.const;\n}\nfunction TNever(schema, references, value) {\n    return false;\n}\nfunction TNot(schema, references, value) {\n    return !Visit(schema.not, references, value);\n}\nfunction TNull(schema, references, value) {\n    return (0, guard_1.IsNull)(value);\n}\nfunction TNumber(schema, references, value) {\n    if (!index_1.TypeSystemPolicy.IsNumberLike(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction TObject(schema, references, value) {\n    if (!index_1.TypeSystemPolicy.IsObjectLike(value))\n        return false;\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            if (!Visit(property, references, value[knownKey])) {\n                return false;\n            }\n            if ((Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {\n                return false;\n            }\n        }\n        else {\n            if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {\n                return false;\n            }\n        }\n    }\n    if (schema.additionalProperties === false) {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        // optimization: value is valid if schemaKey length matches the valueKey length\n        if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {\n            return true;\n        }\n        else {\n            return valueKeys.every((valueKey) => knownKeys.includes(valueKey));\n        }\n    }\n    else if (typeof schema.additionalProperties === 'object') {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));\n    }\n    else {\n        return true;\n    }\n}\nfunction TPromise(schema, references, value) {\n    return (0, guard_1.IsPromise)(value);\n}\nfunction TRecord(schema, references, value) {\n    if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    // prettier-ignore\n    const check1 = Object.entries(value).every(([key, value]) => {\n        return (regex.test(key)) ? Visit(patternSchema, references, value) : true;\n    });\n    // prettier-ignore\n    const check2 = typeof schema.additionalProperties === 'object' ? Object.entries(value).every(([key, value]) => {\n        return (!regex.test(key)) ? Visit(schema.additionalProperties, references, value) : true;\n    }) : true;\n    const check3 = schema.additionalProperties === false\n        ? Object.getOwnPropertyNames(value).every((key) => {\n            return regex.test(key);\n        })\n        : true;\n    return check1 && check2 && check3;\n}\nfunction TRef(schema, references, value) {\n    return Visit((0, deref_1.Deref)(schema, references), references, value);\n}\nfunction TString(schema, references, value) {\n    if (!(0, guard_1.IsString)(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minLength)) {\n        if (!(value.length >= schema.minLength))\n            return false;\n    }\n    if (IsDefined(schema.maxLength)) {\n        if (!(value.length <= schema.maxLength))\n            return false;\n    }\n    if (IsDefined(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value))\n            return false;\n    }\n    if (IsDefined(schema.format)) {\n        if (!Types.FormatRegistry.Has(schema.format))\n            return false;\n        const func = Types.FormatRegistry.Get(schema.format);\n        return func(value);\n    }\n    return true;\n}\nfunction TSymbol(schema, references, value) {\n    return (0, guard_1.IsSymbol)(value);\n}\nfunction TTemplateLiteral(schema, references, value) {\n    return (0, guard_1.IsString)(value) && new RegExp(schema.pattern).test(value);\n}\nfunction TThis(schema, references, value) {\n    return Visit((0, deref_1.Deref)(schema, references), references, value);\n}\nfunction TTuple(schema, references, value) {\n    if (!(0, guard_1.IsArray)(value)) {\n        return false;\n    }\n    if (schema.items === undefined && !(value.length === 0)) {\n        return false;\n    }\n    if (!(value.length === schema.maxItems)) {\n        return false;\n    }\n    if (!schema.items) {\n        return true;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        if (!Visit(schema.items[i], references, value[i]))\n            return false;\n    }\n    return true;\n}\nfunction TUndefined(schema, references, value) {\n    return (0, guard_1.IsUndefined)(value);\n}\nfunction TUnion(schema, references, value) {\n    return schema.anyOf.some((inner) => Visit(inner, references, value));\n}\nfunction TUint8Array(schema, references, value) {\n    if (!(0, guard_1.IsUint8Array)(value)) {\n        return false;\n    }\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        return false;\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        return false;\n    }\n    return true;\n}\nfunction TUnknown(schema, references, value) {\n    return true;\n}\nfunction TVoid(schema, references, value) {\n    return index_1.TypeSystemPolicy.IsVoidLike(value);\n}\nfunction TKind(schema, references, value) {\n    if (!Types.TypeRegistry.Has(schema[Types.Kind]))\n        return false;\n    const func = Types.TypeRegistry.Get(schema[Types.Kind]);\n    return func(schema, value);\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Types.Kind]) {\n        case 'Any':\n            return TAny(schema_, references_, value);\n        case 'Array':\n            return TArray(schema_, references_, value);\n        case 'AsyncIterator':\n            return TAsyncIterator(schema_, references_, value);\n        case 'BigInt':\n            return TBigInt(schema_, references_, value);\n        case 'Boolean':\n            return TBoolean(schema_, references_, value);\n        case 'Constructor':\n            return TConstructor(schema_, references_, value);\n        case 'Date':\n            return TDate(schema_, references_, value);\n        case 'Function':\n            return TFunction(schema_, references_, value);\n        case 'Integer':\n            return TInteger(schema_, references_, value);\n        case 'Intersect':\n            return TIntersect(schema_, references_, value);\n        case 'Iterator':\n            return TIterator(schema_, references_, value);\n        case 'Literal':\n            return TLiteral(schema_, references_, value);\n        case 'Never':\n            return TNever(schema_, references_, value);\n        case 'Not':\n            return TNot(schema_, references_, value);\n        case 'Null':\n            return TNull(schema_, references_, value);\n        case 'Number':\n            return TNumber(schema_, references_, value);\n        case 'Object':\n            return TObject(schema_, references_, value);\n        case 'Promise':\n            return TPromise(schema_, references_, value);\n        case 'Record':\n            return TRecord(schema_, references_, value);\n        case 'Ref':\n            return TRef(schema_, references_, value);\n        case 'String':\n            return TString(schema_, references_, value);\n        case 'Symbol':\n            return TSymbol(schema_, references_, value);\n        case 'TemplateLiteral':\n            return TTemplateLiteral(schema_, references_, value);\n        case 'This':\n            return TThis(schema_, references_, value);\n        case 'Tuple':\n            return TTuple(schema_, references_, value);\n        case 'Undefined':\n            return TUndefined(schema_, references_, value);\n        case 'Union':\n            return TUnion(schema_, references_, value);\n        case 'Uint8Array':\n            return TUint8Array(schema_, references_, value);\n        case 'Unknown':\n            return TUnknown(schema_, references_, value);\n        case 'Void':\n            return TVoid(schema_, references_, value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueCheckUnknownTypeError(schema_);\n            return TKind(schema_, references_, value);\n    }\n}\n/** Returns true if the value matches the given type. */\nfunction Check(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\nexports.Check = Check;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Create = exports.ValueCreateRecursiveInstantiationError = exports.ValueCreateTempateLiteralTypeError = exports.ValueCreateIntersectTypeError = exports.ValueCreateNotTypeError = exports.ValueCreateNeverTypeError = exports.ValueCreateUnknownTypeError = void 0;\nconst guard_1 = require(\"./guard\");\nconst check_1 = require(\"./check\");\nconst deref_1 = require(\"./deref\");\nconst Types = require(\"../typebox\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueCreateUnknownTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;\nclass ValueCreateNeverTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Never types cannot be created');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;\nclass ValueCreateNotTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Not types must have a default value');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateNotTypeError = ValueCreateNotTypeError;\nclass ValueCreateIntersectTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Intersect produced invalid value. Consider using a default value.');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;\nclass ValueCreateTempateLiteralTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Can only create template literal values from patterns that produce finite sequences. Consider using a default value.');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;\nclass ValueCreateRecursiveInstantiationError extends Types.TypeBoxError {\n    constructor(schema, recursiveMaxDepth) {\n        super('Value cannot be created as recursive type may produce value of infinite size. Consider using a default.');\n        this.schema = schema;\n        this.recursiveMaxDepth = recursiveMaxDepth;\n    }\n}\nexports.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction TAny(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return {};\n    }\n}\nfunction TArray(schema, references) {\n    if (schema.uniqueItems === true && !(0, guard_1.HasPropertyKey)(schema, 'default')) {\n        throw new Error('ValueCreate.Array: Array with the uniqueItems constraint requires a default value');\n    }\n    else if ('contains' in schema && !(0, guard_1.HasPropertyKey)(schema, 'default')) {\n        throw new Error('ValueCreate.Array: Array with the contains constraint requires a default value');\n    }\n    else if ('default' in schema) {\n        return schema.default;\n    }\n    else if (schema.minItems !== undefined) {\n        return Array.from({ length: schema.minItems }).map((item) => {\n            return Visit(schema.items, references);\n        });\n    }\n    else {\n        return [];\n    }\n}\nfunction TAsyncIterator(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return (async function* () { })();\n    }\n}\nfunction TBigInt(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return BigInt(0);\n    }\n}\nfunction TBoolean(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return false;\n    }\n}\nfunction TConstructor(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        const value = Visit(schema.returns, references);\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            return class {\n                constructor() {\n                    for (const [key, val] of Object.entries(value)) {\n                        const self = this;\n                        self[key] = val;\n                    }\n                }\n            };\n        }\n        else {\n            return class {\n            };\n        }\n    }\n}\nfunction TDate(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimumTimestamp !== undefined) {\n        return new Date(schema.minimumTimestamp);\n    }\n    else {\n        return new Date(0);\n    }\n}\nfunction TFunction(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return () => Visit(schema.returns, references);\n    }\n}\nfunction TInteger(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction TIntersect(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        // Note: The best we can do here is attempt to instance each sub type and apply through object assign. For non-object\n        // sub types, we just escape the assignment and just return the value. In the latter case, this is typically going to\n        // be a consequence of an illogical intersection.\n        const value = schema.allOf.reduce((acc, schema) => {\n            const next = Visit(schema, references);\n            return typeof next === 'object' ? { ...acc, ...next } : next;\n        }, {});\n        if (!(0, check_1.Check)(schema, references, value))\n            throw new ValueCreateIntersectTypeError(schema);\n        return value;\n    }\n}\nfunction TIterator(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return (function* () { })();\n    }\n}\nfunction TLiteral(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return schema.const;\n    }\n}\nfunction TNever(schema, references) {\n    throw new ValueCreateNeverTypeError(schema);\n}\nfunction TNot(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        throw new ValueCreateNotTypeError(schema);\n    }\n}\nfunction TNull(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return null;\n    }\n}\nfunction TNumber(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction TObject(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        const required = new Set(schema.required);\n        return (schema.default ||\n            Object.entries(schema.properties).reduce((acc, [key, schema]) => {\n                return required.has(key) ? { ...acc, [key]: Visit(schema, references) } : { ...acc };\n            }, {}));\n    }\n}\nfunction TPromise(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return Promise.resolve(Visit(schema.item, references));\n    }\n}\nfunction TRecord(schema, references) {\n    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else if (!(keyPattern === Types.PatternStringExact || keyPattern === Types.PatternNumberExact)) {\n        const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split('|');\n        return propertyKeys.reduce((acc, key) => {\n            return { ...acc, [key]: Visit(valueSchema, references) };\n        }, {});\n    }\n    else {\n        return {};\n    }\n}\nfunction TRef(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return Visit((0, deref_1.Deref)(schema, references), references);\n    }\n}\nfunction TString(schema, references) {\n    if (schema.pattern !== undefined) {\n        if (!(0, guard_1.HasPropertyKey)(schema, 'default')) {\n            throw new Error('ValueCreate.String: String types with patterns must specify a default value');\n        }\n        else {\n            return schema.default;\n        }\n    }\n    else if (schema.format !== undefined) {\n        if (!(0, guard_1.HasPropertyKey)(schema, 'default')) {\n            throw new Error('ValueCreate.String: String types with formats must specify a default value');\n        }\n        else {\n            return schema.default;\n        }\n    }\n    else {\n        if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n            return schema.default;\n        }\n        else if (schema.minLength !== undefined) {\n            return Array.from({ length: schema.minLength })\n                .map(() => '.')\n                .join('');\n        }\n        else {\n            return '';\n        }\n    }\n}\nfunction TSymbol(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else if ('value' in schema) {\n        return Symbol.for(schema.value);\n    }\n    else {\n        return Symbol();\n    }\n}\nfunction TTemplateLiteral(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    const expression = Types.TemplateLiteralParser.ParseExact(schema.pattern);\n    if (!Types.TemplateLiteralFinite.Check(expression))\n        throw new ValueCreateTempateLiteralTypeError(schema);\n    const sequence = Types.TemplateLiteralGenerator.Generate(expression);\n    return sequence.next().value;\n}\nfunction TThis(schema, references) {\n    if (recursiveDepth++ > recursiveMaxDepth)\n        throw new ValueCreateRecursiveInstantiationError(schema, recursiveMaxDepth);\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return Visit((0, deref_1.Deref)(schema, references), references);\n    }\n}\nfunction TTuple(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    if (schema.items === undefined) {\n        return [];\n    }\n    else {\n        return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));\n    }\n}\nfunction TUndefined(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction TUnion(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.anyOf.length === 0) {\n        throw new Error('ValueCreate.Union: Cannot create Union with zero variants');\n    }\n    else {\n        return Visit(schema.anyOf[0], references);\n    }\n}\nfunction TUint8Array(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minByteLength !== undefined) {\n        return new Uint8Array(schema.minByteLength);\n    }\n    else {\n        return new Uint8Array(0);\n    }\n}\nfunction TUnknown(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return {};\n    }\n}\nfunction TVoid(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return void 0;\n    }\n}\nfunction TKind(schema, references) {\n    if ((0, guard_1.HasPropertyKey)(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        throw new Error('User defined types must specify a default value');\n    }\n}\nfunction Visit(schema, references) {\n    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Types.Kind]) {\n        case 'Any':\n            return TAny(schema_, references_);\n        case 'Array':\n            return TArray(schema_, references_);\n        case 'AsyncIterator':\n            return TAsyncIterator(schema_, references_);\n        case 'BigInt':\n            return TBigInt(schema_, references_);\n        case 'Boolean':\n            return TBoolean(schema_, references_);\n        case 'Constructor':\n            return TConstructor(schema_, references_);\n        case 'Date':\n            return TDate(schema_, references_);\n        case 'Function':\n            return TFunction(schema_, references_);\n        case 'Integer':\n            return TInteger(schema_, references_);\n        case 'Intersect':\n            return TIntersect(schema_, references_);\n        case 'Iterator':\n            return TIterator(schema_, references_);\n        case 'Literal':\n            return TLiteral(schema_, references_);\n        case 'Never':\n            return TNever(schema_, references_);\n        case 'Not':\n            return TNot(schema_, references_);\n        case 'Null':\n            return TNull(schema_, references_);\n        case 'Number':\n            return TNumber(schema_, references_);\n        case 'Object':\n            return TObject(schema_, references_);\n        case 'Promise':\n            return TPromise(schema_, references_);\n        case 'Record':\n            return TRecord(schema_, references_);\n        case 'Ref':\n            return TRef(schema_, references_);\n        case 'String':\n            return TString(schema_, references_);\n        case 'Symbol':\n            return TSymbol(schema_, references_);\n        case 'TemplateLiteral':\n            return TTemplateLiteral(schema_, references_);\n        case 'This':\n            return TThis(schema_, references_);\n        case 'Tuple':\n            return TTuple(schema_, references_);\n        case 'Undefined':\n            return TUndefined(schema_, references_);\n        case 'Union':\n            return TUnion(schema_, references_);\n        case 'Uint8Array':\n            return TUint8Array(schema_, references_);\n        case 'Unknown':\n            return TUnknown(schema_, references_);\n        case 'Void':\n            return TVoid(schema_, references_);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueCreateUnknownTypeError(schema_);\n            return TKind(schema_, references_);\n    }\n}\n// --------------------------------------------------------------------------\n// State\n// --------------------------------------------------------------------------\nconst recursiveMaxDepth = 512;\nlet recursiveDepth = 0;\n/** Creates a value from the given schema */\nfunction Create(...args) {\n    recursiveDepth = 0;\n    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);\n}\nexports.Create = Create;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Cast = exports.Default = exports.DefaultClone = exports.ValueCastUnknownTypeError = exports.ValueCastRecursiveTypeError = exports.ValueCastNeverTypeError = exports.ValueCastArrayUniqueItemsTypeError = void 0;\nconst guard_1 = require(\"./guard\");\nconst create_1 = require(\"./create\");\nconst check_1 = require(\"./check\");\nconst clone_1 = require(\"./clone\");\nconst deref_1 = require(\"./deref\");\nconst Types = require(\"../typebox\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueCastArrayUniqueItemsTypeError extends Types.TypeBoxError {\n    constructor(schema, value) {\n        super('Array cast produced invalid data due to uniqueItems constraint');\n        this.schema = schema;\n        this.value = value;\n    }\n}\nexports.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;\nclass ValueCastNeverTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Never types cannot be cast');\n        this.schema = schema;\n    }\n}\nexports.ValueCastNeverTypeError = ValueCastNeverTypeError;\nclass ValueCastRecursiveTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Cannot cast recursive schemas');\n        this.schema = schema;\n    }\n}\nexports.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;\nclass ValueCastUnknownTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueCastUnknownTypeError = ValueCastUnknownTypeError;\n// --------------------------------------------------------------------------\n// The following will score a schema against a value. For objects, the score\n// is the tally of points awarded for each property of the value. Property\n// points are (1.0 / propertyCount) to prevent large property counts biasing\n// results. Properties that match literal values are maximally awarded as\n// literals are typically used as union discriminator fields.\n// --------------------------------------------------------------------------\nvar UnionCastCreate;\n(function (UnionCastCreate) {\n    function Score(schema, references, value) {\n        if (schema[Types.Kind] === 'Object' && typeof value === 'object' && !(0, guard_1.IsNull)(value)) {\n            const object = schema;\n            const keys = Object.getOwnPropertyNames(value);\n            const entries = Object.entries(object.properties);\n            const [point, max] = [1 / entries.length, entries.length];\n            return entries.reduce((acc, [key, schema]) => {\n                const literal = schema[Types.Kind] === 'Literal' && schema.const === value[key] ? max : 0;\n                const checks = (0, check_1.Check)(schema, references, value[key]) ? point : 0;\n                const exists = keys.includes(key) ? point : 0;\n                return acc + (literal + checks + exists);\n            }, 0);\n        }\n        else {\n            return (0, check_1.Check)(schema, references, value) ? 1 : 0;\n        }\n    }\n    function Select(union, references, value) {\n        let [select, best] = [union.anyOf[0], 0];\n        for (const schema of union.anyOf) {\n            const score = Score(schema, references, value);\n            if (score > best) {\n                select = schema;\n                best = score;\n            }\n        }\n        return select;\n    }\n    function Create(union, references, value) {\n        if ('default' in union) {\n            return union.default;\n        }\n        else {\n            const schema = Select(union, references, value);\n            return Cast(schema, references, value);\n        }\n    }\n    UnionCastCreate.Create = Create;\n})(UnionCastCreate || (UnionCastCreate = {}));\n// --------------------------------------------------------------------------\n// Default\n// --------------------------------------------------------------------------\nfunction DefaultClone(schema, references, value) {\n    return (0, check_1.Check)(schema, references, value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema, references);\n}\nexports.DefaultClone = DefaultClone;\nfunction Default(schema, references, value) {\n    return (0, check_1.Check)(schema, references, value) ? value : (0, create_1.Create)(schema, references);\n}\nexports.Default = Default;\n// --------------------------------------------------------------------------\n// Cast\n// --------------------------------------------------------------------------\nfunction TArray(schema, references, value) {\n    if ((0, check_1.Check)(schema, references, value))\n        return (0, clone_1.Clone)(value);\n    const created = (0, guard_1.IsArray)(value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema, references);\n    const minimum = (0, guard_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;\n    const maximum = (0, guard_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;\n    const casted = maximum.map((value) => Visit(schema.items, references, value));\n    if (schema.uniqueItems !== true)\n        return casted;\n    const unique = [...new Set(casted)];\n    if (!(0, check_1.Check)(schema, references, unique))\n        throw new ValueCastArrayUniqueItemsTypeError(schema, unique);\n    return unique;\n}\nfunction TConstructor(schema, references, value) {\n    if ((0, check_1.Check)(schema, references, value))\n        return (0, create_1.Create)(schema, references);\n    const required = new Set(schema.returns.required || []);\n    const result = function () { };\n    for (const [key, property] of Object.entries(schema.returns.properties)) {\n        if (!required.has(key) && value.prototype[key] === undefined)\n            continue;\n        result.prototype[key] = Visit(property, references, value.prototype[key]);\n    }\n    return result;\n}\nfunction TIntersect(schema, references, value) {\n    const created = (0, create_1.Create)(schema, references);\n    const mapped = (0, guard_1.IsPlainObject)(created) && (0, guard_1.IsPlainObject)(value) ? { ...created, ...value } : value;\n    return (0, check_1.Check)(schema, references, mapped) ? mapped : (0, create_1.Create)(schema, references);\n}\nfunction TNever(schema, references, value) {\n    throw new ValueCastNeverTypeError(schema);\n}\nfunction TObject(schema, references, value) {\n    if ((0, check_1.Check)(schema, references, value))\n        return value;\n    if (value === null || typeof value !== 'object')\n        return (0, create_1.Create)(schema, references);\n    const required = new Set(schema.required || []);\n    const result = {};\n    for (const [key, property] of Object.entries(schema.properties)) {\n        if (!required.has(key) && value[key] === undefined)\n            continue;\n        result[key] = Visit(property, references, value[key]);\n    }\n    // additional schema properties\n    if (typeof schema.additionalProperties === 'object') {\n        const propertyNames = Object.getOwnPropertyNames(schema.properties);\n        for (const propertyName of Object.getOwnPropertyNames(value)) {\n            if (propertyNames.includes(propertyName))\n                continue;\n            result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);\n        }\n    }\n    return result;\n}\nfunction TRecord(schema, references, value) {\n    if ((0, check_1.Check)(schema, references, value))\n        return (0, clone_1.Clone)(value);\n    if (value === null || typeof value !== 'object' || Array.isArray(value) || value instanceof Date)\n        return (0, create_1.Create)(schema, references);\n    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const subschema = schema.patternProperties[subschemaPropertyName];\n    const result = {};\n    for (const [propKey, propValue] of Object.entries(value)) {\n        result[propKey] = Visit(subschema, references, propValue);\n    }\n    return result;\n}\nfunction TRef(schema, references, value) {\n    return Visit((0, deref_1.Deref)(schema, references), references, value);\n}\nfunction TThis(schema, references, value) {\n    return Visit((0, deref_1.Deref)(schema, references), references, value);\n}\nfunction TTuple(schema, references, value) {\n    if ((0, check_1.Check)(schema, references, value))\n        return (0, clone_1.Clone)(value);\n    if (!(0, guard_1.IsArray)(value))\n        return (0, create_1.Create)(schema, references);\n    if (schema.items === undefined)\n        return [];\n    return schema.items.map((schema, index) => Visit(schema, references, value[index]));\n}\nfunction TUnion(schema, references, value) {\n    return (0, check_1.Check)(schema, references, value) ? (0, clone_1.Clone)(value) : UnionCastCreate.Create(schema, references, value);\n}\nfunction Visit(schema, references, value) {\n    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema[Types.Kind]) {\n        // ------------------------------------------------------\n        // Structural\n        // ------------------------------------------------------\n        case 'Array':\n            return TArray(schema_, references_, value);\n        case 'Constructor':\n            return TConstructor(schema_, references_, value);\n        case 'Intersect':\n            return TIntersect(schema_, references_, value);\n        case 'Never':\n            return TNever(schema_, references_, value);\n        case 'Object':\n            return TObject(schema_, references_, value);\n        case 'Record':\n            return TRecord(schema_, references_, value);\n        case 'Ref':\n            return TRef(schema_, references_, value);\n        case 'This':\n            return TThis(schema_, references_, value);\n        case 'Tuple':\n            return TTuple(schema_, references_, value);\n        case 'Union':\n            return TUnion(schema_, references_, value);\n        // ------------------------------------------------------\n        // DefaultClone\n        // ------------------------------------------------------\n        case 'Date':\n        case 'Symbol':\n        case 'Uint8Array':\n            return DefaultClone(schema, references, value);\n        // ------------------------------------------------------\n        // Default\n        // ------------------------------------------------------\n        case 'Any':\n        case 'AsyncIterator':\n        case 'BigInt':\n        case 'Boolean':\n        case 'Function':\n        case 'Integer':\n        case 'Iterator':\n        case 'Literal':\n        case 'Not':\n        case 'Null':\n        case 'Number':\n        case 'Promise':\n        case 'String':\n        case 'TemplateLiteral':\n        case 'Undefined':\n        case 'Unknown':\n        case 'Void':\n            return Default(schema_, references_, value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueCastUnknownTypeError(schema_);\n            return Default(schema_, references_, value);\n    }\n}\n/** Casts a value into a given type. The return value will retain as much information of the original value as possible. */\nfunction Cast(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\nexports.Cast = Cast;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Convert = exports.Default = exports.ValueConvertUnknownTypeError = void 0;\nconst guard_1 = require(\"./guard\");\nconst clone_1 = require(\"./clone\");\nconst check_1 = require(\"./check\");\nconst deref_1 = require(\"./deref\");\nconst Types = require(\"../typebox\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueConvertUnknownTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;\n// --------------------------------------------------------------------------\n// Conversions\n// --------------------------------------------------------------------------\nfunction IsStringNumeric(value) {\n    return (0, guard_1.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));\n}\nfunction IsValueToString(value) {\n    return (0, guard_1.IsBigInt)(value) || (0, guard_1.IsBoolean)(value) || (0, guard_1.IsNumber)(value);\n}\nfunction IsValueTrue(value) {\n    return value === true || ((0, guard_1.IsNumber)(value) && value === 1) || ((0, guard_1.IsBigInt)(value) && value === BigInt('1')) || ((0, guard_1.IsString)(value) && (value.toLowerCase() === 'true' || value === '1'));\n}\nfunction IsValueFalse(value) {\n    return value === false || ((0, guard_1.IsNumber)(value) && (value === 0 || Object.is(value, -0))) || ((0, guard_1.IsBigInt)(value) && value === BigInt('0')) || ((0, guard_1.IsString)(value) && (value.toLowerCase() === 'false' || value === '0' || value === '-0'));\n}\nfunction IsTimeStringWithTimeZone(value) {\n    return (0, guard_1.IsString)(value) && /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i.test(value);\n}\nfunction IsTimeStringWithoutTimeZone(value) {\n    return (0, guard_1.IsString)(value) && /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)?$/i.test(value);\n}\nfunction IsDateTimeStringWithTimeZone(value) {\n    return (0, guard_1.IsString)(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i.test(value);\n}\nfunction IsDateTimeStringWithoutTimeZone(value) {\n    return (0, guard_1.IsString)(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)?$/i.test(value);\n}\nfunction IsDateString(value) {\n    return (0, guard_1.IsString)(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/i.test(value);\n}\n// --------------------------------------------------------------------------\n// Convert\n// --------------------------------------------------------------------------\nfunction TryConvertLiteralString(value, target) {\n    const conversion = TryConvertString(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteralNumber(value, target) {\n    const conversion = TryConvertNumber(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteralBoolean(value, target) {\n    const conversion = TryConvertBoolean(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteral(schema, value) {\n    if (typeof schema.const === 'string') {\n        return TryConvertLiteralString(value, schema.const);\n    }\n    else if (typeof schema.const === 'number') {\n        return TryConvertLiteralNumber(value, schema.const);\n    }\n    else if (typeof schema.const === 'boolean') {\n        return TryConvertLiteralBoolean(value, schema.const);\n    }\n    else {\n        return (0, clone_1.Clone)(value);\n    }\n}\nfunction TryConvertBoolean(value) {\n    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;\n}\nfunction TryConvertBigInt(value) {\n    return IsStringNumeric(value) ? BigInt(parseInt(value)) : (0, guard_1.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;\n}\nfunction TryConvertString(value) {\n    return IsValueToString(value) ? value.toString() : (0, guard_1.IsSymbol)(value) && value.description !== undefined ? value.description.toString() : value;\n}\nfunction TryConvertNumber(value) {\n    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;\n}\nfunction TryConvertInteger(value) {\n    return IsStringNumeric(value) ? parseInt(value) : (0, guard_1.IsNumber)(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;\n}\nfunction TryConvertNull(value) {\n    return (0, guard_1.IsString)(value) && value.toLowerCase() === 'null' ? null : value;\n}\nfunction TryConvertUndefined(value) {\n    return (0, guard_1.IsString)(value) && value === 'undefined' ? undefined : value;\n}\nfunction TryConvertDate(value) {\n    // --------------------------------------------------------------------------\n    // note: this function may return an invalid dates for the regex tests\n    // above. Invalid dates will however be checked during the casting function\n    // and will return a epoch date if invalid. Consider better string parsing\n    // for the iso dates in future revisions.\n    // --------------------------------------------------------------------------\n    return (0, guard_1.IsDate)(value)\n        ? value\n        : (0, guard_1.IsNumber)(value)\n            ? new Date(value)\n            : IsValueTrue(value)\n                ? new Date(1)\n                : IsValueFalse(value)\n                    ? new Date(0)\n                    : IsStringNumeric(value)\n                        ? new Date(parseInt(value))\n                        : IsTimeStringWithoutTimeZone(value)\n                            ? new Date(`1970-01-01T${value}.000Z`)\n                            : IsTimeStringWithTimeZone(value)\n                                ? new Date(`1970-01-01T${value}`)\n                                : IsDateTimeStringWithoutTimeZone(value)\n                                    ? new Date(`${value}.000Z`)\n                                    : IsDateTimeStringWithTimeZone(value)\n                                        ? new Date(value)\n                                        : IsDateString(value)\n                                            ? new Date(`${value}T00:00:00.000Z`)\n                                            : value;\n}\n// --------------------------------------------------------------------------\n// Default\n// --------------------------------------------------------------------------\nfunction Default(value) {\n    return value;\n}\nexports.Default = Default;\n// --------------------------------------------------------------------------\n// Convert\n// --------------------------------------------------------------------------\nfunction TArray(schema, references, value) {\n    if ((0, guard_1.IsArray)(value)) {\n        return value.map((value) => Visit(schema.items, references, value));\n    }\n    return value;\n}\nfunction TBigInt(schema, references, value) {\n    return TryConvertBigInt(value);\n}\nfunction TBoolean(schema, references, value) {\n    return TryConvertBoolean(value);\n}\nfunction TDate(schema, references, value) {\n    return TryConvertDate(value);\n}\nfunction TInteger(schema, references, value) {\n    return TryConvertInteger(value);\n}\nfunction TIntersect(schema, references, value) {\n    // prettier-ignore\n    return (schema.allOf.every(schema => Types.TypeGuard.TObject(schema)))\n        ? Visit(Types.Type.Composite(schema.allOf), references, value)\n        : Visit(schema.allOf[0], references, value);\n}\nfunction TLiteral(schema, references, value) {\n    return TryConvertLiteral(schema, value);\n}\nfunction TNull(schema, references, value) {\n    return TryConvertNull(value);\n}\nfunction TNumber(schema, references, value) {\n    return TryConvertNumber(value);\n}\nfunction TObject(schema, references, value) {\n    if ((0, guard_1.IsObject)(value))\n        return Object.getOwnPropertyNames(schema.properties).reduce((acc, key) => {\n            return value[key] !== undefined ? { ...acc, [key]: Visit(schema.properties[key], references, value[key]) } : { ...acc };\n        }, value);\n    return value;\n}\nfunction TRecord(schema, references, value) {\n    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const property = schema.patternProperties[propertyKey];\n    const result = {};\n    for (const [propKey, propValue] of Object.entries(value)) {\n        result[propKey] = Visit(property, references, propValue);\n    }\n    return result;\n}\nfunction TRef(schema, references, value) {\n    return Visit((0, deref_1.Deref)(schema, references), references, value);\n}\nfunction TString(schema, references, value) {\n    return TryConvertString(value);\n}\nfunction TSymbol(schema, references, value) {\n    return (0, guard_1.IsString)(value) || (0, guard_1.IsNumber)(value) ? Symbol(value) : value;\n}\nfunction TThis(schema, references, value) {\n    return Visit((0, deref_1.Deref)(schema, references), references, value);\n}\nfunction TTuple(schema, references, value) {\n    if ((0, guard_1.IsArray)(value) && !(0, guard_1.IsUndefined)(schema.items)) {\n        return value.map((value, index) => {\n            return index < schema.items.length ? Visit(schema.items[index], references, value) : value;\n        });\n    }\n    return value;\n}\nfunction TUndefined(schema, references, value) {\n    return TryConvertUndefined(value);\n}\nfunction TUnion(schema, references, value) {\n    for (const subschema of schema.anyOf) {\n        const converted = Visit(subschema, references, value);\n        if ((0, check_1.Check)(subschema, references, converted)) {\n            return converted;\n        }\n    }\n    return value;\n}\nfunction Visit(schema, references, value) {\n    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema[Types.Kind]) {\n        // ------------------------------------------------------\n        // Structural\n        // ------------------------------------------------------\n        case 'Array':\n            return TArray(schema_, references_, value);\n        case 'BigInt':\n            return TBigInt(schema_, references_, value);\n        case 'Boolean':\n            return TBoolean(schema_, references_, value);\n        case 'Date':\n            return TDate(schema_, references_, value);\n        case 'Integer':\n            return TInteger(schema_, references_, value);\n        case 'Intersect':\n            return TIntersect(schema_, references_, value);\n        case 'Literal':\n            return TLiteral(schema_, references_, value);\n        case 'Null':\n            return TNull(schema_, references_, value);\n        case 'Number':\n            return TNumber(schema_, references_, value);\n        case 'Object':\n            return TObject(schema_, references_, value);\n        case 'Record':\n            return TRecord(schema_, references_, value);\n        case 'Ref':\n            return TRef(schema_, references_, value);\n        case 'String':\n            return TString(schema_, references_, value);\n        case 'Symbol':\n            return TSymbol(schema_, references_, value);\n        case 'This':\n            return TThis(schema_, references_, value);\n        case 'Tuple':\n            return TTuple(schema_, references_, value);\n        case 'Undefined':\n            return TUndefined(schema_, references_, value);\n        case 'Union':\n            return TUnion(schema_, references_, value);\n        // ------------------------------------------------------\n        // Default\n        // ------------------------------------------------------\n        case 'Any':\n        case 'AsyncIterator':\n        case 'Constructor':\n        case 'Function':\n        case 'Iterator':\n        case 'Never':\n        case 'Promise':\n        case 'TemplateLiteral':\n        case 'Uint8Array':\n        case 'Unknown':\n        case 'Void':\n            return Default(value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueConvertUnknownTypeError(schema_);\n            return Default(value);\n    }\n}\n/** Converts any type mismatched values to their target type if a reasonable conversion is possible. */\nfunction Convert(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\nexports.Convert = Convert;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EncodeTransform = exports.DecodeTransform = exports.HasTransform = exports.TransformEncodeError = exports.TransformDecodeError = exports.TransformEncodeCheckError = exports.TransformDecodeCheckError = exports.TransformUnknownTypeError = void 0;\nconst guard_1 = require(\"./guard\");\nconst deref_1 = require(\"./deref\");\nconst Types = require(\"../typebox\");\n// -------------------------------------------------------------------------\n// Errors\n// -------------------------------------------------------------------------\nclass TransformUnknownTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super(`Unknown type`);\n        this.schema = schema;\n    }\n}\nexports.TransformUnknownTypeError = TransformUnknownTypeError;\nclass TransformDecodeCheckError extends Types.TypeBoxError {\n    constructor(schema, value, error) {\n        super(`Unable to decode due to invalid value`);\n        this.schema = schema;\n        this.value = value;\n        this.error = error;\n    }\n}\nexports.TransformDecodeCheckError = TransformDecodeCheckError;\nclass TransformEncodeCheckError extends Types.TypeBoxError {\n    constructor(schema, value, error) {\n        super(`Unable to encode due to invalid value`);\n        this.schema = schema;\n        this.value = value;\n        this.error = error;\n    }\n}\nexports.TransformEncodeCheckError = TransformEncodeCheckError;\nclass TransformDecodeError extends Types.TypeBoxError {\n    constructor(schema, value, error) {\n        super(`${error instanceof Error ? error.message : 'Unknown error'}`);\n        this.schema = schema;\n        this.value = value;\n    }\n}\nexports.TransformDecodeError = TransformDecodeError;\nclass TransformEncodeError extends Types.TypeBoxError {\n    constructor(schema, value, error) {\n        super(`${error instanceof Error ? error.message : 'Unknown error'}`);\n        this.schema = schema;\n        this.value = value;\n    }\n}\nexports.TransformEncodeError = TransformEncodeError;\n// -------------------------------------------------------------------------\n// HasTransform\n// -------------------------------------------------------------------------\n/** Recursively checks a schema for transform codecs */\nvar HasTransform;\n(function (HasTransform) {\n    function TArray(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);\n    }\n    function TAsyncIterator(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);\n    }\n    function TConstructor(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));\n    }\n    function TFunction(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));\n    }\n    function TIntersect(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || Types.TypeGuard.TTransform(schema.unevaluatedProperties) || schema.allOf.some((schema) => Visit(schema, references));\n    }\n    function TIterator(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);\n    }\n    function TNot(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || Visit(schema.not, references);\n    }\n    function TObject(schema, references) {\n        // prettier-ignore\n        return (Types.TypeGuard.TTransform(schema) || Object.values(schema.properties).some((schema) => Visit(schema, references)) || Types.TypeGuard.TSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references));\n    }\n    function TPromise(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || Visit(schema.item, references);\n    }\n    function TRecord(schema, references) {\n        const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n        const property = schema.patternProperties[pattern];\n        return Types.TypeGuard.TTransform(schema) || Visit(property, references) || (Types.TypeGuard.TSchema(schema.additionalProperties) && Types.TypeGuard.TTransform(schema.additionalProperties));\n    }\n    function TRef(schema, references) {\n        if (Types.TypeGuard.TTransform(schema))\n            return true;\n        return Visit((0, deref_1.Deref)(schema, references), references);\n    }\n    function TThis(schema, references) {\n        if (Types.TypeGuard.TTransform(schema))\n            return true;\n        return Visit((0, deref_1.Deref)(schema, references), references);\n    }\n    function TTuple(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || (Types.TypeGuard.TSchema(schema.items) && schema.items.some((schema) => Visit(schema, references)));\n    }\n    function TUnion(schema, references) {\n        return Types.TypeGuard.TTransform(schema) || schema.anyOf.some((schema) => Visit(schema, references));\n    }\n    function Visit(schema, references) {\n        const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;\n        const schema_ = schema;\n        if (schema.$id && visited.has(schema.$id))\n            return false;\n        if (schema.$id)\n            visited.add(schema.$id);\n        switch (schema[Types.Kind]) {\n            // ------------------------------------------------------\n            // Structural\n            // ------------------------------------------------------\n            case 'Array':\n                return TArray(schema_, references_);\n            case 'AsyncIterator':\n                return TAsyncIterator(schema_, references_);\n            case 'Constructor':\n                return TConstructor(schema_, references_);\n            case 'Function':\n                return TFunction(schema_, references_);\n            case 'Intersect':\n                return TIntersect(schema_, references_);\n            case 'Iterator':\n                return TIterator(schema_, references_);\n            case 'Not':\n                return TNot(schema_, references_);\n            case 'Object':\n                return TObject(schema_, references_);\n            case 'Promise':\n                return TPromise(schema_, references_);\n            case 'Record':\n                return TRecord(schema_, references_);\n            case 'Ref':\n                return TRef(schema_, references_);\n            case 'This':\n                return TThis(schema_, references_);\n            case 'Tuple':\n                return TTuple(schema_, references_);\n            case 'Union':\n                return TUnion(schema_, references_);\n            // ------------------------------------------------------\n            // Default\n            // ------------------------------------------------------\n            case 'Any':\n            case 'BigInt':\n            case 'Boolean':\n            case 'Date':\n            case 'Integer':\n            case 'Literal':\n            case 'Never':\n            case 'Null':\n            case 'Number':\n            case 'String':\n            case 'Symbol':\n            case 'TemplateLiteral':\n            case 'Undefined':\n            case 'Uint8Array':\n            case 'Unknown':\n            case 'Void':\n                return Types.TypeGuard.TTransform(schema);\n            default:\n                if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                    throw new TransformUnknownTypeError(schema_);\n                return Types.TypeGuard.TTransform(schema);\n        }\n    }\n    const visited = new Set();\n    /** Returns true if this schema contains a transform codec */\n    function Has(schema, references) {\n        visited.clear();\n        return Visit(schema, references);\n    }\n    HasTransform.Has = Has;\n})(HasTransform || (exports.HasTransform = HasTransform = {}));\n// -------------------------------------------------------------------------\n// DecodeTransform\n// -------------------------------------------------------------------------\n/** Decodes a value using transform decoders if available. Does not ensure correct results. */\nvar DecodeTransform;\n(function (DecodeTransform) {\n    function Default(schema, value) {\n        try {\n            return Types.TypeGuard.TTransform(schema) ? schema[Types.Transform].Decode(value) : value;\n        }\n        catch (error) {\n            throw new TransformDecodeError(schema, value, error);\n        }\n    }\n    function TArray(schema, references, value) {\n        const elements1 = value.map((value) => Visit(schema.items, references, value));\n        return Default(schema, elements1);\n    }\n    function TIntersect(schema, references, value) {\n        if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))\n            return Default(schema, value);\n        const keys = Types.KeyResolver.ResolveKeys(schema, { includePatterns: false });\n        const properties1 = Object.entries(value).reduce((acc, [key, value]) => {\n            return !keys.includes(key) ? { ...acc, [key]: value } : { ...acc, [key]: Default(Types.IndexedAccessor.Resolve(schema, [key]), value) };\n        }, {});\n        if (!Types.TypeGuard.TTransform(schema.unevaluatedProperties))\n            return Default(schema, properties1);\n        const properties2 = Object.entries(properties1).reduce((acc, [key, value]) => {\n            return keys.includes(key) ? { ...acc, [key]: value } : { ...acc, [key]: Default(schema.unevaluatedProperties, value) };\n        }, {});\n        return Default(schema, properties2);\n    }\n    function TNot(schema, references, value) {\n        const value1 = Visit(schema.not, references, value);\n        return Default(schema, value1);\n    }\n    function TObject(schema, references, value) {\n        if (!(0, guard_1.IsPlainObject)(value))\n            return Default(schema, value);\n        const properties1 = Object.entries(value).reduce((acc, [key, value]) => {\n            return !(key in schema.properties) ? { ...acc, [key]: value } : { ...acc, [key]: Visit(schema.properties[key], references, value) };\n        }, {});\n        if (!Types.TypeGuard.TSchema(schema.additionalProperties))\n            return Default(schema, properties1);\n        const additionalProperties = schema.additionalProperties;\n        const properties2 = Object.entries(properties1).reduce((acc, [key, value]) => {\n            return key in schema.properties ? { ...acc, [key]: value } : { ...acc, [key]: Visit(additionalProperties, references, value) };\n        }, {});\n        return Default(schema, properties2);\n    }\n    function TRecord(schema, references, value) {\n        if (!(0, guard_1.IsPlainObject)(value))\n            return Default(schema, value);\n        const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n        const property = schema.patternProperties[pattern];\n        const regex = new RegExp(pattern);\n        const properties1 = Object.entries(value).reduce((acc, [key, value]) => {\n            return !regex.test(key) ? { ...acc, [key]: value } : { ...acc, [key]: Visit(property, references, value) };\n        }, {});\n        if (!Types.TypeGuard.TSchema(schema.additionalProperties))\n            return Default(schema, properties1);\n        const additionalProperties = schema.additionalProperties;\n        const properties2 = Object.entries(properties1).reduce((acc, [key, value]) => {\n            return regex.test(key) ? { ...acc, [key]: value } : { ...acc, [key]: Visit(additionalProperties, references, value) };\n        }, {});\n        return Default(schema, properties2);\n    }\n    function TRef(schema, references, value) {\n        const target = (0, deref_1.Deref)(schema, references);\n        const resolved = Visit(target, references, value);\n        return Default(schema, resolved);\n    }\n    function TThis(schema, references, value) {\n        const target = (0, deref_1.Deref)(schema, references);\n        const resolved = Visit(target, references, value);\n        return Default(schema, resolved);\n    }\n    function TTuple(schema, references, value) {\n        const value1 = (0, guard_1.IsArray)(schema.items) ? schema.items.map((schema, index) => Visit(schema, references, value[index])) : [];\n        return Default(schema, value1);\n    }\n    function TUnion(schema, references, value) {\n        const value1 = Default(schema, value);\n        for (const subschema of schema.anyOf) {\n            if (!checkFunction(subschema, references, value1))\n                continue;\n            return Visit(subschema, references, value1);\n        }\n        return value1;\n    }\n    function Visit(schema, references, value) {\n        const references_ = typeof schema.$id === 'string' ? [...references, schema] : references;\n        const schema_ = schema;\n        switch (schema[Types.Kind]) {\n            // ------------------------------------------------------\n            // Structural\n            // ------------------------------------------------------\n            case 'Array':\n                return TArray(schema_, references_, value);\n            case 'Intersect':\n                return TIntersect(schema_, references_, value);\n            case 'Not':\n                return TNot(schema_, references_, value);\n            case 'Object':\n                return TObject(schema_, references_, value);\n            case 'Record':\n                return TRecord(schema_, references_, value);\n            case 'Ref':\n                return TRef(schema_, references_, value);\n            case 'Symbol':\n                return Default(schema_, value);\n            case 'This':\n                return TThis(schema_, references_, value);\n            case 'Tuple':\n                return TTuple(schema_, references_, value);\n            case 'Union':\n                return TUnion(schema_, references_, value);\n            // ------------------------------------------------------\n            // Default\n            // ------------------------------------------------------\n            case 'Any':\n            case 'AsyncIterator':\n            case 'BigInt':\n            case 'Boolean':\n            case 'Constructor':\n            case 'Date':\n            case 'Function':\n            case 'Integer':\n            case 'Iterator':\n            case 'Literal':\n            case 'Never':\n            case 'Null':\n            case 'Number':\n            case 'Promise':\n            case 'String':\n            case 'TemplateLiteral':\n            case 'Undefined':\n            case 'Uint8Array':\n            case 'Unknown':\n            case 'Void':\n                return Default(schema_, value);\n            default:\n                if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                    throw new TransformUnknownTypeError(schema_);\n                return Default(schema_, value);\n        }\n    }\n    let checkFunction = () => false;\n    function Decode(schema, references, value, check) {\n        checkFunction = check;\n        return Visit(schema, references, value);\n    }\n    DecodeTransform.Decode = Decode;\n})(DecodeTransform || (exports.DecodeTransform = DecodeTransform = {}));\n// -------------------------------------------------------------------------\n// DecodeTransform\n// -------------------------------------------------------------------------\n/** Encodes a value using transform encoders if available. Does not ensure correct results. */\nvar EncodeTransform;\n(function (EncodeTransform) {\n    function Default(schema, value) {\n        try {\n            return Types.TypeGuard.TTransform(schema) ? schema[Types.Transform].Encode(value) : value;\n        }\n        catch (error) {\n            throw new TransformEncodeError(schema, value, error);\n        }\n    }\n    function TArray(schema, references, value) {\n        const elements1 = Default(schema, value);\n        return elements1.map((value) => Visit(schema.items, references, value));\n    }\n    function TIntersect(schema, references, value) {\n        const properties1 = Default(schema, value);\n        if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))\n            return properties1;\n        const keys = Types.KeyResolver.ResolveKeys(schema, { includePatterns: false });\n        const properties2 = Object.entries(properties1).reduce((acc, [key, value]) => {\n            return !keys.includes(key) ? { ...acc, [key]: value } : { ...acc, [key]: Default(Types.IndexedAccessor.Resolve(schema, [key]), value) };\n        }, {});\n        if (!Types.TypeGuard.TTransform(schema.unevaluatedProperties))\n            return Default(schema, properties2);\n        return Object.entries(properties2).reduce((acc, [key, value]) => {\n            return keys.includes(key) ? { ...acc, [key]: value } : { ...acc, [key]: Default(schema.unevaluatedProperties, value) };\n        }, {});\n    }\n    function TNot(schema, references, value) {\n        const value1 = Default(schema, value);\n        return Default(schema.not, value1);\n    }\n    function TObject(schema, references, value) {\n        const properties1 = Default(schema, value);\n        if (!(0, guard_1.IsPlainObject)(value))\n            return properties1;\n        const properties2 = Object.entries(properties1).reduce((acc, [key, value]) => {\n            return !(key in schema.properties) ? { ...acc, [key]: value } : { ...acc, [key]: Visit(schema.properties[key], references, value) };\n        }, {});\n        if (!Types.TypeGuard.TSchema(schema.additionalProperties))\n            return properties2;\n        const additionalProperties = schema.additionalProperties;\n        return Object.entries(properties2).reduce((acc, [key, value]) => {\n            return key in schema.properties ? { ...acc, [key]: value } : { ...acc, [key]: Visit(additionalProperties, references, value) };\n        }, {});\n    }\n    function TRecord(schema, references, value) {\n        const properties1 = Default(schema, value);\n        if (!(0, guard_1.IsPlainObject)(value))\n            return properties1;\n        const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n        const property = schema.patternProperties[pattern];\n        const regex = new RegExp(pattern);\n        const properties2 = Object.entries(properties1).reduce((acc, [key, value]) => {\n            return !regex.test(key) ? { ...acc, [key]: value } : { ...acc, [key]: Visit(property, references, value) };\n        }, {});\n        if (!Types.TypeGuard.TSchema(schema.additionalProperties))\n            return Default(schema, properties2);\n        const additionalProperties = schema.additionalProperties;\n        return Object.entries(properties2).reduce((acc, [key, value]) => {\n            return regex.test(key) ? { ...acc, [key]: value } : { ...acc, [key]: Visit(additionalProperties, references, value) };\n        }, {});\n    }\n    function TRef(schema, references, value) {\n        const target = (0, deref_1.Deref)(schema, references);\n        const resolved = Visit(target, references, value);\n        return Default(schema, resolved);\n    }\n    function TThis(schema, references, value) {\n        const target = (0, deref_1.Deref)(schema, references);\n        const resolved = Visit(target, references, value);\n        return Default(schema, resolved);\n    }\n    function TTuple(schema, references, value) {\n        const value1 = Default(schema, value);\n        return (0, guard_1.IsArray)(schema.items) ? schema.items.map((schema, index) => Visit(schema, references, value1[index])) : [];\n    }\n    function TUnion(schema, references, value) {\n        // test value against union variants\n        for (const subschema of schema.anyOf) {\n            if (!checkFunction(subschema, references, value))\n                continue;\n            const value1 = Visit(subschema, references, value);\n            return Default(schema, value1);\n        }\n        // test transformed value against union variants\n        for (const subschema of schema.anyOf) {\n            const value1 = Visit(subschema, references, value);\n            if (!checkFunction(schema, references, value1))\n                continue;\n            return Default(schema, value1);\n        }\n        return Default(schema, value);\n    }\n    function Visit(schema, references, value) {\n        const references_ = typeof schema.$id === 'string' ? [...references, schema] : references;\n        const schema_ = schema;\n        switch (schema[Types.Kind]) {\n            // ------------------------------------------------------\n            // Structural\n            // ------------------------------------------------------\n            case 'Array':\n                return TArray(schema_, references_, value);\n            case 'Intersect':\n                return TIntersect(schema_, references_, value);\n            case 'Not':\n                return TNot(schema_, references_, value);\n            case 'Object':\n                return TObject(schema_, references_, value);\n            case 'Record':\n                return TRecord(schema_, references_, value);\n            case 'Ref':\n                return TRef(schema_, references_, value);\n            case 'This':\n                return TThis(schema_, references_, value);\n            case 'Tuple':\n                return TTuple(schema_, references_, value);\n            case 'Union':\n                return TUnion(schema_, references_, value);\n            // ------------------------------------------------------\n            // Apply\n            // ------------------------------------------------------\n            case 'Any':\n            case 'AsyncIterator':\n            case 'BigInt':\n            case 'Boolean':\n            case 'Constructor':\n            case 'Date':\n            case 'Function':\n            case 'Integer':\n            case 'Iterator':\n            case 'Literal':\n            case 'Never':\n            case 'Null':\n            case 'Number':\n            case 'Promise':\n            case 'String':\n            case 'Symbol':\n            case 'TemplateLiteral':\n            case 'Undefined':\n            case 'Uint8Array':\n            case 'Unknown':\n            case 'Void':\n                return Default(schema_, value);\n            default:\n                if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                    throw new TransformUnknownTypeError(schema_);\n                return Default(schema_, value);\n        }\n    }\n    let checkFunction = () => false;\n    function Encode(schema, references, value, check) {\n        checkFunction = check;\n        return Visit(schema, references, value);\n    }\n    EncodeTransform.Encode = Encode;\n})(EncodeTransform || (exports.EncodeTransform = EncodeTransform = {}));\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Value = void 0;\nconst ValueErrors = require(\"../errors/index\");\nconst ValueMutate = require(\"./mutate\");\nconst ValueHash = require(\"./hash\");\nconst ValueEqual = require(\"./equal\");\nconst ValueCast = require(\"./cast\");\nconst ValueClone = require(\"./clone\");\nconst ValueConvert = require(\"./convert\");\nconst ValueCreate = require(\"./create\");\nconst ValueCheck = require(\"./check\");\nconst ValueDelta = require(\"./delta\");\nconst ValueTransform = require(\"./transform\");\n/** Functions to perform structural operations on JavaScript values */\nvar Value;\n(function (Value) {\n    /** Casts a value into a given type. The return value will retain as much information of the original value as possible. */\n    function Cast(...args) {\n        return ValueCast.Cast.apply(ValueCast, args);\n    }\n    Value.Cast = Cast;\n    /** Creates a value from the given type */\n    function Create(...args) {\n        return ValueCreate.Create.apply(ValueCreate, args);\n    }\n    Value.Create = Create;\n    /** Returns true if the value matches the given type */\n    function Check(...args) {\n        return ValueCheck.Check.apply(ValueCheck, args);\n    }\n    Value.Check = Check;\n    /** Converts any type mismatched values to their target type if a reasonable conversion is possible */\n    function Convert(...args) {\n        return ValueConvert.Convert.apply(ValueConvert, args);\n    }\n    Value.Convert = Convert;\n    /** Returns a structural clone of the given value */\n    function Clone(value) {\n        return ValueClone.Clone(value);\n    }\n    Value.Clone = Clone;\n    /** Decodes a value or throws if error */\n    function Decode(...args) {\n        const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];\n        if (!Check(schema, references, value))\n            throw new ValueTransform.TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());\n        return ValueTransform.DecodeTransform.Decode(schema, references, value, ValueCheck.Check);\n    }\n    Value.Decode = Decode;\n    /** Encodes a value or throws if error */\n    function Encode(...args) {\n        const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];\n        const encoded = ValueTransform.EncodeTransform.Encode(schema, references, value, ValueCheck.Check);\n        if (!Check(schema, references, encoded))\n            throw new ValueTransform.TransformEncodeCheckError(schema, value, Errors(schema, references, value).First());\n        return encoded;\n    }\n    Value.Encode = Encode;\n    /** Returns an iterator for each error in this value. */\n    function Errors(...args) {\n        return ValueErrors.Errors.apply(ValueErrors, args);\n    }\n    Value.Errors = Errors;\n    /** Returns true if left and right values are structurally equal */\n    function Equal(left, right) {\n        return ValueEqual.Equal(left, right);\n    }\n    Value.Equal = Equal;\n    /** Returns edits to transform the current value into the next value */\n    function Diff(current, next) {\n        return ValueDelta.Diff(current, next);\n    }\n    Value.Diff = Diff;\n    /** Returns a FNV1A-64 non cryptographic hash of the given value */\n    function Hash(value) {\n        return ValueHash.Hash(value);\n    }\n    Value.Hash = Hash;\n    /** Returns a new value with edits applied to the given value */\n    function Patch(current, edits) {\n        return ValueDelta.Patch(current, edits);\n    }\n    Value.Patch = Patch;\n    /** Performs a deep mutable value assignment while retaining internal references. */\n    function Mutate(current, next) {\n        ValueMutate.Mutate(current, next);\n    }\n    Value.Mutate = Mutate;\n})(Value || (exports.Value = Value = {}));\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Value = exports.ValuePointer = exports.Delete = exports.Update = exports.Insert = exports.Edit = exports.ValueErrorIterator = exports.ValueErrorType = void 0;\nvar index_1 = require(\"../errors/index\");\nObject.defineProperty(exports, \"ValueErrorType\", { enumerable: true, get: function () { return index_1.ValueErrorType; } });\nObject.defineProperty(exports, \"ValueErrorIterator\", { enumerable: true, get: function () { return index_1.ValueErrorIterator; } });\nvar delta_1 = require(\"./delta\");\nObject.defineProperty(exports, \"Edit\", { enumerable: true, get: function () { return delta_1.Edit; } });\nObject.defineProperty(exports, \"Insert\", { enumerable: true, get: function () { return delta_1.Insert; } });\nObject.defineProperty(exports, \"Update\", { enumerable: true, get: function () { return delta_1.Update; } });\nObject.defineProperty(exports, \"Delete\", { enumerable: true, get: function () { return delta_1.Delete; } });\nvar pointer_1 = require(\"./pointer\");\nObject.defineProperty(exports, \"ValuePointer\", { enumerable: true, get: function () { return pointer_1.ValuePointer; } });\nvar value_1 = require(\"./value\");\nObject.defineProperty(exports, \"Value\", { enumerable: true, get: function () { return value_1.Value; } });\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/compiler\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;\nconst transform_1 = require(\"../value/transform\");\nconst guard_1 = require(\"../value/guard\");\nconst errors_1 = require(\"../errors/errors\");\nconst index_1 = require(\"../system/index\");\nconst deref_1 = require(\"../value/deref\");\nconst hash_1 = require(\"../value/hash\");\nconst Types = require(\"../typebox\");\n// -------------------------------------------------------------------\n// TypeCheck\n// -------------------------------------------------------------------\nclass TypeCheck {\n    constructor(schema, references, checkFunc, code) {\n        this.schema = schema;\n        this.references = references;\n        this.checkFunc = checkFunc;\n        this.code = code;\n        this.hasTransform = transform_1.HasTransform.Has(schema, references);\n    }\n    /** Returns the generated assertion code used to validate this type. */\n    Code() {\n        return this.code;\n    }\n    /** Returns an iterator for each error in this value. */\n    Errors(value) {\n        return (0, errors_1.Errors)(this.schema, this.references, value);\n    }\n    /** Returns true if the value matches the compiled type. */\n    Check(value) {\n        return this.checkFunc(value);\n    }\n    /** Decodes a value or throws if error */\n    Decode(value) {\n        if (!this.checkFunc(value))\n            throw new transform_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());\n        return this.hasTransform ? transform_1.DecodeTransform.Decode(this.schema, this.references, value, (_, __, value) => this.Check(value)) : value;\n    }\n    /** Encodes a value or throws if error */\n    Encode(value) {\n        const encoded = this.hasTransform ? transform_1.EncodeTransform.Encode(this.schema, this.references, value, (_, __, value) => this.Check(value)) : value;\n        if (!this.checkFunc(encoded))\n            throw new transform_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());\n        return encoded;\n    }\n}\nexports.TypeCheck = TypeCheck;\n// -------------------------------------------------------------------\n// Character\n// -------------------------------------------------------------------\nvar Character;\n(function (Character) {\n    function DollarSign(code) {\n        return code === 36;\n    }\n    Character.DollarSign = DollarSign;\n    function IsUnderscore(code) {\n        return code === 95;\n    }\n    Character.IsUnderscore = IsUnderscore;\n    function IsAlpha(code) {\n        return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);\n    }\n    Character.IsAlpha = IsAlpha;\n    function IsNumeric(code) {\n        return code >= 48 && code <= 57;\n    }\n    Character.IsNumeric = IsNumeric;\n})(Character || (Character = {}));\n// -------------------------------------------------------------------\n// MemberExpression\n// -------------------------------------------------------------------\nvar MemberExpression;\n(function (MemberExpression) {\n    function IsFirstCharacterNumeric(value) {\n        if (value.length === 0)\n            return false;\n        return Character.IsNumeric(value.charCodeAt(0));\n    }\n    function IsAccessor(value) {\n        if (IsFirstCharacterNumeric(value))\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);\n            if (!check)\n                return false;\n        }\n        return true;\n    }\n    function EscapeHyphen(key) {\n        return key.replace(/'/g, \"\\\\'\");\n    }\n    function Encode(object, key) {\n        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;\n    }\n    MemberExpression.Encode = Encode;\n})(MemberExpression || (MemberExpression = {}));\n// -------------------------------------------------------------------\n// Identifier\n// -------------------------------------------------------------------\nvar Identifier;\n(function (Identifier) {\n    function Encode($id) {\n        const buffer = [];\n        for (let i = 0; i < $id.length; i++) {\n            const code = $id.charCodeAt(i);\n            if (Character.IsNumeric(code) || Character.IsAlpha(code)) {\n                buffer.push($id.charAt(i));\n            }\n            else {\n                buffer.push(`_${code}_`);\n            }\n        }\n        return buffer.join('').replace(/__/g, '_');\n    }\n    Identifier.Encode = Encode;\n})(Identifier || (Identifier = {}));\n// -------------------------------------------------------------------\n// LiteralString\n// -------------------------------------------------------------------\nvar LiteralString;\n(function (LiteralString) {\n    function Escape(content) {\n        return content.replace(/'/g, \"\\\\'\");\n    }\n    LiteralString.Escape = Escape;\n})(LiteralString || (LiteralString = {}));\n// -------------------------------------------------------------------\n// Errors\n// -------------------------------------------------------------------\nclass TypeCompilerUnknownTypeError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;\nclass TypeCompilerTypeGuardError extends Types.TypeBoxError {\n    constructor(schema) {\n        super('Preflight validation check failed to guard for the given schema');\n        this.schema = schema;\n    }\n}\nexports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;\n// -------------------------------------------------------------------\n// Policy\n// -------------------------------------------------------------------\nvar Policy;\n(function (Policy) {\n    function IsExactOptionalProperty(value, key, expression) {\n        return index_1.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;\n    }\n    Policy.IsExactOptionalProperty = IsExactOptionalProperty;\n    function IsObjectLike(value) {\n        return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;\n    }\n    Policy.IsObjectLike = IsObjectLike;\n    function IsRecordLike(value) {\n        return !index_1.TypeSystemPolicy.AllowArrayObject\n            ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`\n            : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;\n    }\n    Policy.IsRecordLike = IsRecordLike;\n    function IsNumberLike(value) {\n        return !index_1.TypeSystemPolicy.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;\n    }\n    Policy.IsNumberLike = IsNumberLike;\n    function IsVoidLike(value) {\n        return index_1.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;\n    }\n    Policy.IsVoidLike = IsVoidLike;\n})(Policy || (exports.Policy = Policy = {}));\n/** Compiles Types for Runtime Type Checking */\nvar TypeCompiler;\n(function (TypeCompiler) {\n    // ----------------------------------------------------------------------\n    // Guards\n    // ----------------------------------------------------------------------\n    function IsAnyOrUnknown(schema) {\n        return schema[Types.Kind] === 'Any' || schema[Types.Kind] === 'Unknown';\n    }\n    // -------------------------------------------------------------------\n    // Types\n    // -------------------------------------------------------------------\n    function* TAny(schema, references, value) {\n        yield 'true';\n    }\n    function* TArray(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        const [parameter, accumulator] = [CreateParameter('value', 'any'), CreateParameter('acc', 'number')];\n        if ((0, guard_1.IsNumber)(schema.maxItems))\n            yield `${value}.length <= ${schema.maxItems}`;\n        if ((0, guard_1.IsNumber)(schema.minItems))\n            yield `${value}.length >= ${schema.minItems}`;\n        const elementExpression = CreateExpression(schema.items, references, 'value');\n        yield `${value}.every((${parameter}) => ${elementExpression})`;\n        if (Types.TypeGuard.TSchema(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains)) {\n            const containsSchema = Types.TypeGuard.TSchema(schema.contains) ? schema.contains : Types.Type.Never();\n            const checkExpression = CreateExpression(containsSchema, references, 'value');\n            const checkMinContains = (0, guard_1.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];\n            const checkMaxContains = (0, guard_1.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];\n            const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;\n            const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(' && ');\n            yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;\n        }\n        if (schema.uniqueItems === true) {\n            const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;\n            const block = `const set = new Set(); for(const element of value) { ${check} }`;\n            yield `((${parameter}) => { ${block} )(${value})`;\n        }\n    }\n    function* TAsyncIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;\n    }\n    function* TBigInt(schema, references, value) {\n        yield `(typeof ${value} === 'bigint')`;\n        if ((0, guard_1.IsBigInt)(schema.exclusiveMaximum))\n            yield `${value} < BigInt(${schema.exclusiveMaximum})`;\n        if ((0, guard_1.IsBigInt)(schema.exclusiveMinimum))\n            yield `${value} > BigInt(${schema.exclusiveMinimum})`;\n        if ((0, guard_1.IsBigInt)(schema.maximum))\n            yield `${value} <= BigInt(${schema.maximum})`;\n        if ((0, guard_1.IsBigInt)(schema.minimum))\n            yield `${value} >= BigInt(${schema.minimum})`;\n        if ((0, guard_1.IsBigInt)(schema.multipleOf))\n            yield `(${value} % BigInt(${schema.multipleOf})) === 0`;\n    }\n    function* TBoolean(schema, references, value) {\n        yield `(typeof ${value} === 'boolean')`;\n    }\n    function* TConstructor(schema, references, value) {\n        yield* Visit(schema.returns, references, `${value}.prototype`);\n    }\n    function* TDate(schema, references, value) {\n        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;\n        if ((0, guard_1.IsNumber)(schema.exclusiveMaximumTimestamp))\n            yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;\n        if ((0, guard_1.IsNumber)(schema.exclusiveMinimumTimestamp))\n            yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;\n        if ((0, guard_1.IsNumber)(schema.maximumTimestamp))\n            yield `${value}.getTime() <= ${schema.maximumTimestamp}`;\n        if ((0, guard_1.IsNumber)(schema.minimumTimestamp))\n            yield `${value}.getTime() >= ${schema.minimumTimestamp}`;\n        if ((0, guard_1.IsNumber)(schema.multipleOfTimestamp))\n            yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;\n    }\n    function* TFunction(schema, references, value) {\n        yield `(typeof ${value} === 'function')`;\n    }\n    function* TInteger(schema, references, value) {\n        yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;\n        if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if ((0, guard_1.IsNumber)(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n        if ((0, guard_1.IsNumber)(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if ((0, guard_1.IsNumber)(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n    }\n    function* TIntersect(schema, references, value) {\n        const check1 = schema.allOf.map((schema) => CreateExpression(schema, references, value)).join(' && ');\n        if (schema.unevaluatedProperties === false) {\n            const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;\n            yield `(${check1} && ${check2})`;\n        }\n        else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {\n            const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;\n            yield `(${check1} && ${check2})`;\n        }\n        else {\n            yield `(${check1})`;\n        }\n    }\n    function* TIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;\n    }\n    function* TLiteral(schema, references, value) {\n        if (typeof schema.const === 'number' || typeof schema.const === 'boolean') {\n            yield `(${value} === ${schema.const})`;\n        }\n        else {\n            yield `(${value} === '${LiteralString.Escape(schema.const)}')`;\n        }\n    }\n    function* TNever(schema, references, value) {\n        yield `false`;\n    }\n    function* TNot(schema, references, value) {\n        const expression = CreateExpression(schema.not, references, value);\n        yield `(!${expression})`;\n    }\n    function* TNull(schema, references, value) {\n        yield `(${value} === null)`;\n    }\n    function* TNumber(schema, references, value) {\n        yield Policy.IsNumberLike(value);\n        if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if ((0, guard_1.IsNumber)(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n        if ((0, guard_1.IsNumber)(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if ((0, guard_1.IsNumber)(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n    }\n    function* TObject(schema, references, value) {\n        yield Policy.IsObjectLike(value);\n        if ((0, guard_1.IsNumber)(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if ((0, guard_1.IsNumber)(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const knownKeys = Object.getOwnPropertyNames(schema.properties);\n        for (const knownKey of knownKeys) {\n            const memberExpression = MemberExpression.Encode(value, knownKey);\n            const property = schema.properties[knownKey];\n            if (schema.required && schema.required.includes(knownKey)) {\n                yield* Visit(property, references, memberExpression);\n                if (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property))\n                    yield `('${knownKey}' in ${value})`;\n            }\n            else {\n                const expression = CreateExpression(property, references, memberExpression);\n                yield Policy.IsExactOptionalProperty(value, knownKey, expression);\n            }\n        }\n        if (schema.additionalProperties === false) {\n            if (schema.required && schema.required.length === knownKeys.length) {\n                yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;\n            }\n            else {\n                const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n                yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;\n            }\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);\n            const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n            yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;\n        }\n    }\n    function* TPromise(schema, references, value) {\n        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;\n    }\n    function* TRecord(schema, references, value) {\n        yield Policy.IsRecordLike(value);\n        if ((0, guard_1.IsNumber)(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if ((0, guard_1.IsNumber)(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n        const variable = CreateVariable(`${new RegExp(patternKey)}`);\n        const check1 = CreateExpression(patternSchema, references, 'value');\n        const check2 = Types.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? 'false' : 'true';\n        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;\n        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;\n    }\n    function* TRef(schema, references, value) {\n        const target = (0, deref_1.Deref)(schema, references);\n        // Reference: If we have seen this reference before we can just yield and return the function call.\n        // If this isn't the case we defer to visit to generate and set the function for subsequent passes.\n        if (state.functions.has(schema.$ref))\n            return yield `${CreateFunctionName(schema.$ref)}(${value})`;\n        yield* Visit(target, references, value);\n    }\n    function* TString(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        if ((0, guard_1.IsNumber)(schema.maxLength))\n            yield `${value}.length <= ${schema.maxLength}`;\n        if ((0, guard_1.IsNumber)(schema.minLength))\n            yield `${value}.length >= ${schema.minLength}`;\n        if (schema.pattern !== undefined) {\n            const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n            yield `${variable}.test(${value})`;\n        }\n        if (schema.format !== undefined) {\n            yield `format('${schema.format}', ${value})`;\n        }\n    }\n    function* TSymbol(schema, references, value) {\n        yield `(typeof ${value} === 'symbol')`;\n    }\n    function* TTemplateLiteral(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n        yield `${variable}.test(${value})`;\n    }\n    function* TThis(schema, references, value) {\n        // Note: This types are assured to be hoisted prior to this call. Just yield the function.\n        yield `${CreateFunctionName(schema.$ref)}(${value})`;\n    }\n    function* TTuple(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        if (schema.items === undefined)\n            return yield `${value}.length === 0`;\n        yield `(${value}.length === ${schema.maxItems})`;\n        for (let i = 0; i < schema.items.length; i++) {\n            const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);\n            yield `${expression}`;\n        }\n    }\n    function* TUndefined(schema, references, value) {\n        yield `${value} === undefined`;\n    }\n    function* TUnion(schema, references, value) {\n        const expressions = schema.anyOf.map((schema) => CreateExpression(schema, references, value));\n        yield `(${expressions.join(' || ')})`;\n    }\n    function* TUint8Array(schema, references, value) {\n        yield `${value} instanceof Uint8Array`;\n        if ((0, guard_1.IsNumber)(schema.maxByteLength))\n            yield `(${value}.length <= ${schema.maxByteLength})`;\n        if ((0, guard_1.IsNumber)(schema.minByteLength))\n            yield `(${value}.length >= ${schema.minByteLength})`;\n    }\n    function* TUnknown(schema, references, value) {\n        yield 'true';\n    }\n    function* TVoid(schema, references, value) {\n        yield Policy.IsVoidLike(value);\n    }\n    function* TKind(schema, references, value) {\n        const instance = state.instances.size;\n        state.instances.set(instance, schema);\n        yield `kind('${schema[Types.Kind]}', ${instance}, ${value})`;\n    }\n    function* Visit(schema, references, value, useHoisting = true) {\n        const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;\n        const schema_ = schema;\n        // ----------------------------------------------------------------------------------\n        // Hoisting\n        // ----------------------------------------------------------------------------------\n        if (useHoisting && (0, guard_1.IsString)(schema.$id)) {\n            const functionName = CreateFunctionName(schema.$id);\n            if (state.functions.has(functionName)) {\n                return yield `${functionName}(${value})`;\n            }\n            else {\n                const functionCode = CreateFunction(functionName, schema, references, 'value', false);\n                state.functions.set(functionName, functionCode);\n                return yield `${functionName}(${value})`;\n            }\n        }\n        switch (schema_[Types.Kind]) {\n            case 'Any':\n                return yield* TAny(schema_, references_, value);\n            case 'Array':\n                return yield* TArray(schema_, references_, value);\n            case 'AsyncIterator':\n                return yield* TAsyncIterator(schema_, references_, value);\n            case 'BigInt':\n                return yield* TBigInt(schema_, references_, value);\n            case 'Boolean':\n                return yield* TBoolean(schema_, references_, value);\n            case 'Constructor':\n                return yield* TConstructor(schema_, references_, value);\n            case 'Date':\n                return yield* TDate(schema_, references_, value);\n            case 'Function':\n                return yield* TFunction(schema_, references_, value);\n            case 'Integer':\n                return yield* TInteger(schema_, references_, value);\n            case 'Intersect':\n                return yield* TIntersect(schema_, references_, value);\n            case 'Iterator':\n                return yield* TIterator(schema_, references_, value);\n            case 'Literal':\n                return yield* TLiteral(schema_, references_, value);\n            case 'Never':\n                return yield* TNever(schema_, references_, value);\n            case 'Not':\n                return yield* TNot(schema_, references_, value);\n            case 'Null':\n                return yield* TNull(schema_, references_, value);\n            case 'Number':\n                return yield* TNumber(schema_, references_, value);\n            case 'Object':\n                return yield* TObject(schema_, references_, value);\n            case 'Promise':\n                return yield* TPromise(schema_, references_, value);\n            case 'Record':\n                return yield* TRecord(schema_, references_, value);\n            case 'Ref':\n                return yield* TRef(schema_, references_, value);\n            case 'String':\n                return yield* TString(schema_, references_, value);\n            case 'Symbol':\n                return yield* TSymbol(schema_, references_, value);\n            case 'TemplateLiteral':\n                return yield* TTemplateLiteral(schema_, references_, value);\n            case 'This':\n                return yield* TThis(schema_, references_, value);\n            case 'Tuple':\n                return yield* TTuple(schema_, references_, value);\n            case 'Undefined':\n                return yield* TUndefined(schema_, references_, value);\n            case 'Union':\n                return yield* TUnion(schema_, references_, value);\n            case 'Uint8Array':\n                return yield* TUint8Array(schema_, references_, value);\n            case 'Unknown':\n                return yield* TUnknown(schema_, references_, value);\n            case 'Void':\n                return yield* TVoid(schema_, references_, value);\n            default:\n                if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                    throw new TypeCompilerUnknownTypeError(schema);\n                return yield* TKind(schema_, references_, value);\n        }\n    }\n    // -------------------------------------------------------------------\n    // Compiler State\n    // -------------------------------------------------------------------\n    // prettier-ignore\n    const state = {\n        language: 'javascript',\n        functions: new Map(),\n        variables: new Map(),\n        instances: new Map() // exterior kind instances\n    };\n    // -------------------------------------------------------------------\n    // Compiler Factory\n    // -------------------------------------------------------------------\n    function CreateExpression(schema, references, value, useHoisting = true) {\n        return `(${[...Visit(schema, references, value, useHoisting)].join(' && ')})`;\n    }\n    function CreateFunctionName($id) {\n        return `check_${Identifier.Encode($id)}`;\n    }\n    function CreateVariable(expression) {\n        const variableName = `local_${state.variables.size}`;\n        state.variables.set(variableName, `const ${variableName} = ${expression}`);\n        return variableName;\n    }\n    function CreateFunction(name, schema, references, value, useHoisting = true) {\n        const [newline, pad] = ['\\n', (length) => ''.padStart(length, ' ')];\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const expression = [...Visit(schema, references, value, useHoisting)].map((expression) => `${pad(4)}${expression}`).join(` &&${newline}`);\n        return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\\n}`;\n    }\n    function CreateParameter(name, type) {\n        const annotation = state.language === 'typescript' ? `: ${type}` : '';\n        return `${name}${annotation}`;\n    }\n    function CreateReturns(type) {\n        return state.language === 'typescript' ? `: ${type}` : '';\n    }\n    // -------------------------------------------------------------------\n    // Compile\n    // -------------------------------------------------------------------\n    function Build(schema, references, options) {\n        const functionCode = CreateFunction('check', schema, references, 'value'); // will populate functions and variables\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const functions = [...state.functions.values()];\n        const variables = [...state.variables.values()];\n        // prettier-ignore\n        const checkFunction = (0, guard_1.IsString)(schema.$id) // ensure top level schemas with $id's are hoisted\n            ? `return function check(${parameter})${returns} {\\n  return ${CreateFunctionName(schema.$id)}(value)\\n}`\n            : `return ${functionCode}`;\n        return [...variables, ...functions, checkFunction].join('\\n');\n    }\n    /** Generates the code used to assert this type and returns it as a string */\n    function Code(...args) {\n        const defaults = { language: 'javascript' };\n        // prettier-ignore\n        const [schema, references, options] = (args.length === 2 && (0, guard_1.IsArray)(args[1]) ? [args[0], args[1], defaults] :\n            args.length === 2 && !(0, guard_1.IsArray)(args[1]) ? [args[0], [], args[1]] :\n                args.length === 3 ? [args[0], args[1], args[2]] :\n                    args.length === 1 ? [args[0], [], defaults] :\n                        [null, [], defaults]);\n        // compiler-reset\n        state.language = options.language;\n        state.variables.clear();\n        state.functions.clear();\n        state.instances.clear();\n        if (!Types.TypeGuard.TSchema(schema))\n            throw new TypeCompilerTypeGuardError(schema);\n        for (const schema of references)\n            if (!Types.TypeGuard.TSchema(schema))\n                throw new TypeCompilerTypeGuardError(schema);\n        return Build(schema, references, options);\n    }\n    TypeCompiler.Code = Code;\n    /** Compiles a TypeBox type for optimal runtime type checking. Types must be valid TypeBox types of TSchema */\n    function Compile(schema, references = []) {\n        const generatedCode = Code(schema, references, { language: 'javascript' });\n        const compiledFunction = globalThis.Function('kind', 'format', 'hash', generatedCode);\n        const instances = new Map(state.instances);\n        function typeRegistryFunction(kind, instance, value) {\n            if (!Types.TypeRegistry.Has(kind) || !instances.has(instance))\n                return false;\n            const checkFunc = Types.TypeRegistry.Get(kind);\n            const schema = instances.get(instance);\n            return checkFunc(schema, value);\n        }\n        function formatRegistryFunction(format, value) {\n            if (!Types.FormatRegistry.Has(format))\n                return false;\n            const checkFunc = Types.FormatRegistry.Get(format);\n            return checkFunc(value);\n        }\n        function hashFunction(value) {\n            return (0, hash_1.Hash)(value);\n        }\n        const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);\n        return new TypeCheck(schema, references, checkFunction, generatedCode);\n    }\n    TypeCompiler.Compile = Compile;\n})(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/compiler\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueErrorIterator = exports.ValueErrorType = void 0;\nvar index_1 = require(\"../errors/index\");\nObject.defineProperty(exports, \"ValueErrorType\", { enumerable: true, get: function () { return index_1.ValueErrorType; } });\nObject.defineProperty(exports, \"ValueErrorIterator\", { enumerable: true, get: function () { return index_1.ValueErrorIterator; } });\n__exportStar(require(\"./compiler\"), exports);\n",
  "'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n",
  "\"use strict\";\n\nconst fastDecode = require(\"fast-decode-uri-component\");\n\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = Object.create(null);\n\n/**\n * @callback parse\n * @param {string} input\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  let inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex);\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = fastDecode(key) || key;\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n\n          if (shouldDecodeValue) {\n            value = fastDecode(value) || value;\n          }\n        }\n        const currentValue = result[key];\n\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = parse;\n",
  "// This file is taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n);\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// rome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127\n]);\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len) break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2);\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = { encodeString };\n",
  "\"use strict\";\n\nconst { encodeString } = require(\"./internals/querystring\");\n\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\") {\n    return value.toString();\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n\n  return \"\";\n}\n\n/**\n * @param {Record<string, string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} input\n * @returns {string}\n */\nfunction stringify(input) {\n  let result = \"\";\n\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n\n    if (i) {\n      result += separator;\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = stringify;\n",
  "\"use strict\";\n\nconst parse = require(\"./parse\");\nconst stringify = require(\"./stringify\");\n\nconst fastQuerystring = {\n  parse,\n  stringify,\n};\n\n/**\n * Enable TS and JS support\n *\n * - `const qs = require('fast-querystring')`\n * - `import qs from 'fast-querystring'`\n */\nmodule.exports = fastQuerystring;\nmodule.exports.default = fastQuerystring;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n",
  "let e=(e,t)=>({part:e,store:null,inert:void 0!==t?new Map(t.map(e=>[e.part.charCodeAt(0),e])):null,params:null,wildcardStore:null}),t=(e,t)=>({...e,part:t}),r=e=>({paramName:e,store:null,inert:null});export class Memoirist{root={};history=[];static regex={static:/:.+?(?=\\/|$)/,params:/:.+?(?=\\/|$)/g};add(a,l,i){let s;if(\"string\"!=typeof l)throw TypeError(\"Route path must be a string\");\"\"===l?l=\"/\":\"/\"!==l[0]&&(l=`/${l}`),this.history.push([a,l,i]);let n=\"*\"===l[l.length-1];n&&(l=l.slice(0,-1));let o=l.split(Memoirist.regex.static),u=l.match(Memoirist.regex.params)||[];\"\"===o[o.length-1]&&o.pop(),s=this.root[a]?this.root[a]:this.root[a]=e(\"/\");let p=0;for(let a=0;a<o.length;++a){let i=o[a];if(a>0){let t=u[p++].slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route \"${l}\" with parameter \"${t}\" because a route already exists with a different parameter name (\"${s.params.paramName}\") in the same location`);let a=s.params;if(null===a.inert){s=a.inert=e(i);continue}s=a.inert}for(let r=0;;){if(r===i.length){if(r<s.part.length){let a=t(s,s.part.slice(r));Object.assign(s,e(i,[a]))}break}if(r===s.part.length){if(null===s.inert)s.inert=new Map;else if(s.inert.has(i.charCodeAt(r))){s=s.inert.get(i.charCodeAt(r)),i=i.slice(r),r=0;continue}let t=e(i.slice(r));s.inert.set(i.charCodeAt(r),t),s=t;break}if(i[r]!==s.part[r]){let a=t(s,s.part.slice(r)),l=e(i.slice(r));Object.assign(s,e(s.part.slice(0,r),[a,l])),s=l;break}++r}}if(p<u.length){let e=u[p],t=e.slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route \"${l}\" with parameter \"${t}\" because a route already exists with a different parameter name (\"${s.params.paramName}\") in the same location`);return null===s.params.store&&(s.params.store=i),s.params.store}return n?(null===s.wildcardStore&&(s.wildcardStore=i),s.wildcardStore):(null===s.store&&(s.store=i),s.store)}find(e,t){let r=this.root[e];return r?a(t,t.length,r,0):null}}let a=(e,t,r,l)=>{let i=r?.part,s=l+i.length;if(i.length>1){if(s>t)return null;if(i.length<15){for(let t=1,r=l+1;t<i.length;++t,++r)if(i.charCodeAt(t)!==e.charCodeAt(r))return null}else if(e.substring(l,s)!==i)return null}if(s===t)return null!==r.store?{store:r.store,params:{}}:null!==r.wildcardStore?{store:r.wildcardStore,params:{\"*\":\"\"}}:null;if(null!==r.inert){let l=r.inert.get(e.charCodeAt(s));if(void 0!==l){let r=a(e,t,l,s);if(null!==r)return r}}if(null!==r.params){let l=r.params,i=e.indexOf(\"/\",s);if(i!==s){if(-1===i||i>=t){if(null!==l.store){let r={};return r[l.paramName]=e.substring(s,t),{store:l.store,params:r}}}else if(null!==l.inert){let r=a(e,t,l.inert,i);if(null!==r)return r.params[l.paramName]=e.substring(s,i),r}}}return null!==r.wildcardStore?{store:r.wildcardStore,params:{\"*\":e.substring(s,t)}}:null};export default Memoirist;",
  "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n",
  "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n",
  "import type {\n\tTraceHandler,\n\tTraceProcess,\n\tTraceReporter,\n\tTraceStream\n} from './types'\n\nconst resolver = <T>() => {\n\tlet resolve: (a: T) => any\n\tconst promise = new Promise<T>((r) => {\n\t\tresolve = r\n\t})\n\n\treturn [promise, resolve!] as const\n}\n\ntype TraceResolver = [\n\tstart: (value: TraceProcess<'begin'>) => any,\n\tend: (value: TraceProcess<'end'>) => any\n]\n\nconst createSignal = () => {\n\tconst [start, resolveStart] = resolver<TraceProcess<'begin'>>()\n\tconst [end, resolveEnd] = resolver<TraceProcess<'end'>>()\n\n\tconst children: Promise<TraceProcess<'begin'>>[] = []\n\tconst resolvers: TraceResolver[] = []\n\n\treturn {\n\t\tsignal: start,\n\t\tconsume: (trace: TraceStream) => {\n\t\t\tswitch (trace.type) {\n\t\t\t\tcase 'begin':\n\t\t\t\t\tif (trace.unit && children.length === 0)\n\t\t\t\t\t\tfor (let i = 0; i < trace.unit; i++) {\n\t\t\t\t\t\t\tconst [start, resolveStart] =\n\t\t\t\t\t\t\t\tresolver<TraceProcess<'begin'>>()\n\t\t\t\t\t\t\tconst [end, resolveEnd] =\n\t\t\t\t\t\t\t\tresolver<TraceProcess<'end'>>()\n\n\t\t\t\t\t\t\tchildren.push(start)\n\t\t\t\t\t\t\tresolvers.push([\n\t\t\t\t\t\t\t\t(trace) => {\n\t\t\t\t\t\t\t\t\tresolveStart({\n\t\t\t\t\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(time) => {\n\t\t\t\t\t\t\t\t\tresolveEnd(time)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t}\n\n\t\t\t\t\tresolveStart({\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\tend,\n\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'end':\n\t\t\t\t\tresolveEnd(trace.time)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t},\n\t\tconsumeChild(trace: TraceStream) {\n\t\t\tswitch (trace.type) {\n\t\t\t\tcase 'begin':\n\t\t\t\t\tif (!resolvers[0]) return\n\t\t\t\t\tconst [resolveStart] = resolvers[0]\n\n\t\t\t\t\tresolveStart({\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\tend,\n\t\t\t\t\t\tname: trace.name ?? '',\n\t\t\t\t\t\tskip: false,\n\t\t\t\t\t\ttime: trace.time\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'end':\n\t\t\t\t\tconst child = resolvers.shift()\n\t\t\t\t\tif (!child) return\n\n\t\t\t\t\tchild[1](trace.time)\n\t\t\t}\n\t\t},\n\t\tresolve() {\n\t\t\tresolveStart({\n\t\t\t\tchildren: [],\n\t\t\t\tend: new Promise((resolve) => resolve(0)),\n\t\t\t\tname: '',\n\t\t\t\tskip: true,\n\t\t\t\ttime: 0\n\t\t\t})\n\n\t\t\tfor (const [resolveStart, resolveEnd] of resolvers) {\n\t\t\t\tresolveStart({\n\t\t\t\t\tchildren: [],\n\t\t\t\t\tend: new Promise((resolve) => resolve(0)),\n\t\t\t\t\tname: '',\n\t\t\t\t\tskip: true,\n\t\t\t\t\ttime: 0\n\t\t\t\t})\n\n\t\t\t\tresolveEnd(0)\n\t\t\t}\n\n\t\t\tresolveEnd(0)\n\t\t}\n\t}\n}\n\nexport const createTraceListener = (\n\tgetReporter: () => TraceReporter,\n\ttotalListener: number,\n\thandler: TraceHandler<any, any>\n) => {\n\treturn async function trace(trace: TraceStream) {\n\t\tif (trace.event !== 'request' || trace.type !== 'begin') return\n\n\t\tconst id = trace.id\n\t\tconst reporter = getReporter()\n\n\t\tconst request = createSignal()\n\t\tconst parse = createSignal()\n\t\tconst transform = createSignal()\n\t\tconst beforeHandle = createSignal()\n\t\tconst handle = createSignal()\n\t\tconst afterHandle = createSignal()\n\t\tconst error = createSignal()\n\t\tconst response = createSignal()\n\n\t\trequest.consume(trace)\n\n\t\tconst reducer = (event: TraceStream) => {\n\t\t\tif (event.id === id)\n\t\t\t\tswitch (event.event) {\n\t\t\t\t\tcase 'request':\n\t\t\t\t\t\trequest.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'request.unit':\n\t\t\t\t\t\trequest.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'parse':\n\t\t\t\t\t\tparse.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'parse.unit':\n\t\t\t\t\t\tparse.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'transform':\n\t\t\t\t\t\ttransform.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'transform.unit':\n\t\t\t\t\t\ttransform.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\t\tbeforeHandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'beforeHandle.unit':\n\t\t\t\t\t\tbeforeHandle.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'handle':\n\t\t\t\t\t\thandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'afterHandle':\n\t\t\t\t\t\tafterHandle.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'afterHandle.unit':\n\t\t\t\t\t\tafterHandle.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\terror.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'error.unit':\n\t\t\t\t\t\terror.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'response':\n\t\t\t\t\t\tif (event.type === 'begin') {\n\t\t\t\t\t\t\trequest.resolve()\n\t\t\t\t\t\t\tparse.resolve()\n\t\t\t\t\t\t\ttransform.resolve()\n\t\t\t\t\t\t\tbeforeHandle.resolve()\n\t\t\t\t\t\t\thandle.resolve()\n\t\t\t\t\t\t\tafterHandle.resolve()\n\t\t\t\t\t\t\terror.resolve()\n\t\t\t\t\t\t} else reporter.off('event', reducer)\n\n\t\t\t\t\t\tresponse.consume(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'response.unit':\n\t\t\t\t\t\tresponse.consumeChild(event)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'exit':\n\t\t\t\t\t\trequest.resolve()\n\t\t\t\t\t\tparse.resolve()\n\t\t\t\t\t\ttransform.resolve()\n\t\t\t\t\t\tbeforeHandle.resolve()\n\t\t\t\t\t\thandle.resolve()\n\t\t\t\t\t\tafterHandle.resolve()\n\t\t\t\t\t\terror.resolve()\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t}\n\n\t\treporter.on('event', reducer)\n\n\t\tawait handler({\n\t\t\tid,\n\t\t\t// @ts-ignore\n\t\t\tcontext: trace.ctx,\n\t\t\t// @ts-ignore\n\t\t\tset: trace.ctx?.set,\n\t\t\t// @ts-ignore\n\t\t\tstore: trace.ctx?.store,\n\t\t\ttime: trace.time,\n\t\t\trequest: request.signal as any,\n\t\t\tparse: parse.signal as any,\n\t\t\ttransform: transform.signal as any,\n\t\t\tbeforeHandle: beforeHandle.signal as any,\n\t\t\thandle: handle.signal as any,\n\t\t\tafterHandle: afterHandle.signal as any,\n\t\t\terror: error.signal,\n\t\t\tresponse: response.signal as any\n\t\t})\n\n\t\treporter.emit(`res${id}.${totalListener}`, undefined)\n\t}\n}\n",
  "import { Value } from '@sinclair/typebox/value'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\nimport { TSchema } from '@sinclair/typebox'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t? process?.env\n\t\t: undefined\n\nexport const ERROR_CODE = Symbol('ErrorCode')\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\t| InvalidCookieSignature\n\nexport class InternalServerError extends Error {\n\tcode = 'INTERNAL_SERVER_ERROR'\n\tstatus = 500\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'PARSE')\n\t}\n}\n\nexport class InvalidCookieSignature extends Error {\n\tcode = 'INVALID_COOKIE_SIGNATURE'\n\tstatus = 400\n\n\tconstructor(public key: string, message?: string) {\n\t\tsuper(message ?? `\"${key}\" has invalid cookie signature`)\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 400\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TSchema | TypeCheck<any>,\n\t\tpublic value: unknown\n\t) {\n\t\tconst error = isProduction\n\t\t\t? undefined\n\t\t\t: 'Errors' in validator\n\t\t\t? validator.Errors(value).First()\n\t\t\t: Value.Errors(validator, value).First()\n\n\t\tconst customError = error?.schema.error\n\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t? error.schema.error(type, validator, value)\n\t\t\t\t: error.schema.error\n\t\t\t: undefined\n\n\t\tconst message = isProduction\n\t\t\t? customError ??\n\t\t\t  `Invalid ${type ?? error?.schema.error ?? error?.message}`\n\t\t\t: customError ??\n\t\t\t  `Invalid ${type}, '${error?.path?.slice(1) || 'type'}': ${\n\t\t\t\t\terror?.message\n\t\t\t  }` +\n\t\t\t\t\t'\\n\\n' +\n\t\t\t\t\t'Expected: ' +\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\tValidationError.simplifyModel(validator),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2\n\t\t\t\t\t) +\n\t\t\t\t\t'\\n\\n' +\n\t\t\t\t\t'Found: ' +\n\t\t\t\t\tJSON.stringify(value, null, 2)\n\t\t// +\n\t\t// '\\n\\n' +\n\t\t// 'Schema: ' +\n\t\t// // @ts-ignore\n\t\t// JSON.stringify(validator.schema, null, 2) +\n\t\t// '\\n'\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn [...this.validator.Errors(this.value)]\n\t}\n\n\tstatic simplifyModel(validator: TSchema | TypeCheck<any>) {\n\t\t// @ts-ignore\n\t\tconst model = 'schema' in validator ? validator.schema : validator\n\n\t\ttry {\n\t\t\treturn Value.Create(model)\n\t\t} catch {\n\t\t\treturn model\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn ValidationError.simplifyModel(this.validator)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders\n\t\t})\n\t}\n}\n",
  "import type { ServerWebSocket, WebSocketHandler } from 'bun'\n\nimport type { TSchema } from '@sinclair/typebox'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\n\nimport { ValidationError } from '../error'\nimport type { Context } from '../context'\n\nimport type { DecoratorBase, RouteSchema } from '../types'\n\nexport const websocket: WebSocketHandler<any> = {\n\topen(ws) {\n\t\tws.data.open?.(ws)\n\t},\n\tmessage(ws, message) {\n\t\tws.data.message?.(ws, message)\n\t},\n\tdrain(ws) {\n\t\tws.data.drain?.(ws)\n\t},\n\tclose(ws, code, reason) {\n\t\tws.data.close?.(ws, code, reason)\n\t}\n}\n\nexport class ElysiaWS<\n\tWS extends ServerWebSocket<{\n\t\tvalidator?: TypeCheck<TSchema>\n\t}>,\n\tRoute extends RouteSchema = RouteSchema,\n\tDecorators extends DecoratorBase = {\n\t\trequest: {}\n\t\tstore: {}\n\t}\n> {\n\tid: number\n\tvalidator?: TypeCheck<TSchema>\n\n\tconstructor(public raw: WS, public data: Context<Route, Decorators>) {\n\t\tthis.validator = raw.data.validator\n\t\tthis.id = Date.now()\n\t}\n\n\tget publish() {\n\t\treturn (\n\t\t\ttopic: string,\n\t\t\tdata: Route['response'] = undefined,\n\t\t\tcompress?: boolean\n\t\t) => {\n\t\t\tif (this.validator?.Check(data) === false)\n\t\t\t\tthrow new ValidationError('message', this.validator, data)\n\n\t\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\t\tthis.raw.publish(topic, data as unknown as string, compress)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget send() {\n\t\treturn (data: Route['response']) => {\n\t\t\tif (this.validator?.Check(data) === false)\n\t\t\t\tthrow new ValidationError('message', this.validator, data)\n\n\t\t\tif (Buffer.isBuffer(data)) {\n\t\t\t\tthis.raw.send(data as unknown as Buffer)\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\t\tthis.raw.send(data as unknown as string)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget subscribe() {\n\t\treturn (room: string) => {\n\t\t\tthis.raw.subscribe(room)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget unsubscribe() {\n\t\treturn (room: string) => {\n\t\t\tthis.raw.unsubscribe(room)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget cork() {\n\t\treturn (callback: (ws: WS) => this) => {\n\t\t\tthis.raw.cork(callback as any)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget close() {\n\t\treturn () => {\n\t\t\tthis.raw.close()\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget terminate() {\n\t\treturn this.raw.terminate.bind(this.raw)\n\t}\n\n\tget isSubscribed() {\n\t\treturn this.raw.isSubscribed.bind(this.raw)\n\t}\n\n\tget remoteAddress() {\n\t\treturn this.raw.remoteAddress\n\t}\n}\n",
  "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var dec = opt.decode || decode;\n\n  var index = 0\n  while (index < str.length) {\n    var eqIdx = str.indexOf('=', index)\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break\n    }\n\n    var endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    var key = str.slice(index, eqIdx).trim()\n\n    // only assign once\n    if (undefined === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim()\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.partitioned) {\n    str += '; Partitioned'\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase()\n      : opt.priority\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} val\n * @returns {string}\n */\n\nfunction encode (val) {\n  return encodeURIComponent(val)\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]' ||\n    val instanceof Date\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { isNotEmpty } from './handler'\n\nimport type {\n\tLifeCycleStore,\n\tLocalHook,\n\tMaybeArray,\n\tInputSchema\n} from './types'\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const getHostname = (url: string) => url.slice(0, url.indexOf('/', 11))\n\nconst isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle import * as Sentry from '@sentry/bun'\n\t// This also handle [object Date], [object Array]\n\t// and FFI value like [object Prisma]\n\tv.toString().startsWith('[object ') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nexport const mergeDeep = <\n\tconst A extends Record<string, any>,\n\tconst B extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys\n\t}: {\n\t\tskipKeys?: string[]\n\t} = {}\n): A & B => {\n\tif (isObject(target) && isObject(source))\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tif (skipKeys?.includes(key)) continue\n\n\t\t\tif (!isObject(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (!(key in target)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (isClass(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t\t(target as any)[key] as any,\n\t\t\t\tvalue\n\t\t\t)\n\t\t}\n\n\treturn target as A & B\n}\n\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ttarget: A,\n\tsource: B\n): A & B =>\n\tmergeDeep(target, source, {\n\t\tskipKeys: ['properties']\n\t})\n\nexport const mergeObjectArray = <T>(a: T | T[], b: T | T[]): T[] => {\n\t// ! Must copy to remove side-effect\n\tconst array = [...(Array.isArray(a) ? a : [a])]\n\tconst checksums = []\n\n\tfor (const item of array) {\n\t\t// @ts-ignore\n\t\tif (item.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tchecksums.push(item.$elysiaChecksum)\n\t}\n\n\tfor (const item of Array.isArray(b) ? b : [b]) {\n\t\t// @ts-ignore\n\t\tif (!checksums.includes(item?.$elysiaChecksum)) array.push(item)\n\t}\n\n\treturn array\n}\n\nexport const mergeHook = (\n\ta?: LocalHook<any, any, any, any> | LifeCycleStore,\n\tb?: LocalHook<any, any, any, any>\n): LifeCycleStore => {\n\treturn {\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tresponse: b?.response ?? a?.response,\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray((a?.parse as any) ?? [], b?.parse ?? []),\n\t\ttransform: mergeObjectArray(\n\t\t\ta?.transform ?? [],\n\t\t\tb?.transform ?? []\n\t\t) as any,\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta?.beforeHandle ?? [],\n\t\t\tb?.beforeHandle ?? []\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta?.afterHandle ?? [],\n\t\t\tb?.afterHandle ?? []\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta?.onResponse ?? [],\n\t\t\tb?.onResponse ?? []\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace ?? [], b?.trace ?? []) as any,\n\t\terror: mergeObjectArray(a?.error ?? [], b?.error ?? [])\n\t}\n}\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic)\n\t\treturn {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\treturn TypeCompiler.Compile(schema, Object.values(models))\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\treturn TypeCompiler.Compile(schema, references)\n\t}\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, Object.values(models))\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] = Kind in schema ? compile(schema, Object.values(models)) : schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, Object.values(models))\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const mergeLifeCycle = (\n\ta: LifeCycleStore,\n\tb: LifeCycleStore | LocalHook,\n\tchecksum?: number\n): LifeCycleStore => {\n\tconst injectChecksum = <T>(x: T): T => {\n\t\t// @ts-ignore\n\t\tif (checksum && !x.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaChecksum = checksum\n\n\t\treturn x\n\t}\n\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start as any,\n\t\t\t('start' in b ? b.start ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\trequest: mergeObjectArray(\n\t\t\ta.request as any,\n\t\t\t('request' in b ? b.request ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse as any,\n\t\t\t'parse' in b ? b?.parse ?? [] : undefined ?? ([] as any)\n\t\t).map(injectChecksum),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform as any,\n\t\t\t(b?.transform ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle as any,\n\t\t\t(b?.beforeHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle as any,\n\t\t\t(b?.afterHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse as any,\n\t\t\t(b?.onResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\ttrace: a.trace,\n\t\t// trace: mergeObjectArray(\n\t\t// \ta.trace as any,\n\t\t// \t('trace' in b ? b.trace ?? [] : ([] as any)).map(injectChecksum)\n\t\t// ),\n\t\terror: mergeObjectArray(\n\t\t\ta.error as any,\n\t\t\t(b?.error ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop as any,\n\t\t\t('stop' in b ? b.stop ?? [] : ([] as any)).map(injectChecksum)\n\t\t)\n\t}\n}\n\nexport const asGlobalHook = (\n\thook: LocalHook<any, any>,\n\tinject = true\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: asGlobal(hook?.parse, inject),\n\t\ttransform: asGlobal(hook?.transform, inject),\n\t\tbeforeHandle: asGlobal(hook?.beforeHandle, inject),\n\t\tafterHandle: asGlobal(hook?.afterHandle, inject),\n\t\tonResponse: asGlobal(hook?.onResponse, inject),\n\t\terror: asGlobal(hook?.error, inject)\n\t} as LocalHook<any, any>\n}\n\nexport const asGlobal = <T extends MaybeArray<Function> | undefined>(\n\tfn: T,\n\tinject = true\n): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tfn.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse fn.$elysiaHookType = undefined\n\n\t\treturn fn\n\t}\n\n\treturn fn.map((x) => {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse x.$elysiaHookType = undefined\n\n\t\treturn x\n\t}) as T\n}\n\nconst filterGlobal = <T extends MaybeArray<Function> | undefined>(fn: T): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\t// @ts-ignore\n\t\treturn fn.$elysiaHookType === 'global' ? fn : undefined\n\t}\n\n\t// @ts-ignore\n\treturn fn.filter((x) => x.$elysiaHookType === 'global') as T\n}\n\nexport const filterGlobalHook = (\n\thook: LocalHook<any, any>\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error)\n\t} as LocalHook<any, any>\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport type HTTPStatusName = keyof typeof StatusMap\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst encoder = new TextEncoder()\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\tconst hmacArray = Array.from(new Uint8Array(hmacBuffer))\n\tconst digest = btoa(String.fromCharCode(...hmacArray))\n\treturn `${val}.${digest.replace(/=+$/, '')}`\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { isNotEmpty } from './handler'\n\nimport type {\n\tLifeCycleStore,\n\tLocalHook,\n\tMaybeArray,\n\tInputSchema\n} from './types'\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const getHostname = (url: string) => url.slice(0, url.indexOf('/', 11))\n\nconst isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle import * as Sentry from '@sentry/bun'\n\t// This also handle [object Date], [object Array]\n\t// and FFI value like [object Prisma]\n\tv.toString().startsWith('[object ') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nexport const mergeDeep = <\n\tconst A extends Record<string, any>,\n\tconst B extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys\n\t}: {\n\t\tskipKeys?: string[]\n\t} = {}\n): A & B => {\n\tif (isObject(target) && isObject(source))\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tif (skipKeys?.includes(key)) continue\n\n\t\t\tif (!isObject(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (!(key in target)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (isClass(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t\t(target as any)[key] as any,\n\t\t\t\tvalue\n\t\t\t)\n\t\t}\n\n\treturn target as A & B\n}\n\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ttarget: A,\n\tsource: B\n): A & B =>\n\tmergeDeep(target, source, {\n\t\tskipKeys: ['properties']\n\t})\n\nexport const mergeObjectArray = <T>(a: T | T[], b: T | T[]): T[] => {\n\t// ! Must copy to remove side-effect\n\tconst array = [...(Array.isArray(a) ? a : [a])]\n\tconst checksums = []\n\n\tfor (const item of array) {\n\t\t// @ts-ignore\n\t\tif (item.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tchecksums.push(item.$elysiaChecksum)\n\t}\n\n\tfor (const item of Array.isArray(b) ? b : [b]) {\n\t\t// @ts-ignore\n\t\tif (!checksums.includes(item?.$elysiaChecksum)) array.push(item)\n\t}\n\n\treturn array\n}\n\nexport const mergeHook = (\n\ta?: LocalHook<any, any, any, any> | LifeCycleStore,\n\tb?: LocalHook<any, any, any, any>\n): LifeCycleStore => {\n\treturn {\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tresponse: b?.response ?? a?.response,\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray((a?.parse as any) ?? [], b?.parse ?? []),\n\t\ttransform: mergeObjectArray(\n\t\t\ta?.transform ?? [],\n\t\t\tb?.transform ?? []\n\t\t) as any,\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta?.beforeHandle ?? [],\n\t\t\tb?.beforeHandle ?? []\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta?.afterHandle ?? [],\n\t\t\tb?.afterHandle ?? []\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta?.onResponse ?? [],\n\t\t\tb?.onResponse ?? []\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace ?? [], b?.trace ?? []) as any,\n\t\terror: mergeObjectArray(a?.error ?? [], b?.error ?? [])\n\t}\n}\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic)\n\t\treturn {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\treturn TypeCompiler.Compile(schema, Object.values(models))\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\treturn TypeCompiler.Compile(schema, references)\n\t}\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, Object.values(models))\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] = Kind in schema ? compile(schema, Object.values(models)) : schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, Object.values(models))\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const mergeLifeCycle = (\n\ta: LifeCycleStore,\n\tb: LifeCycleStore | LocalHook,\n\tchecksum?: number\n): LifeCycleStore => {\n\tconst injectChecksum = <T>(x: T): T => {\n\t\t// @ts-ignore\n\t\tif (checksum && !x.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaChecksum = checksum\n\n\t\treturn x\n\t}\n\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start as any,\n\t\t\t('start' in b ? b.start ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\trequest: mergeObjectArray(\n\t\t\ta.request as any,\n\t\t\t('request' in b ? b.request ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse as any,\n\t\t\t'parse' in b ? b?.parse ?? [] : undefined ?? ([] as any)\n\t\t).map(injectChecksum),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform as any,\n\t\t\t(b?.transform ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle as any,\n\t\t\t(b?.beforeHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle as any,\n\t\t\t(b?.afterHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse as any,\n\t\t\t(b?.onResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\ttrace: a.trace,\n\t\t// trace: mergeObjectArray(\n\t\t// \ta.trace as any,\n\t\t// \t('trace' in b ? b.trace ?? [] : ([] as any)).map(injectChecksum)\n\t\t// ),\n\t\terror: mergeObjectArray(\n\t\t\ta.error as any,\n\t\t\t(b?.error ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop as any,\n\t\t\t('stop' in b ? b.stop ?? [] : ([] as any)).map(injectChecksum)\n\t\t)\n\t}\n}\n\nexport const asGlobalHook = (\n\thook: LocalHook<any, any>,\n\tinject = true\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: asGlobal(hook?.parse, inject),\n\t\ttransform: asGlobal(hook?.transform, inject),\n\t\tbeforeHandle: asGlobal(hook?.beforeHandle, inject),\n\t\tafterHandle: asGlobal(hook?.afterHandle, inject),\n\t\tonResponse: asGlobal(hook?.onResponse, inject),\n\t\terror: asGlobal(hook?.error, inject)\n\t} as LocalHook<any, any>\n}\n\nexport const asGlobal = <T extends MaybeArray<Function> | undefined>(\n\tfn: T,\n\tinject = true\n): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tfn.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse fn.$elysiaHookType = undefined\n\n\t\treturn fn\n\t}\n\n\treturn fn.map((x) => {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse x.$elysiaHookType = undefined\n\n\t\treturn x\n\t}) as T\n}\n\nconst filterGlobal = <T extends MaybeArray<Function> | undefined>(fn: T): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\t// @ts-ignore\n\t\treturn fn.$elysiaHookType === 'global' ? fn : undefined\n\t}\n\n\t// @ts-ignore\n\treturn fn.filter((x) => x.$elysiaHookType === 'global') as T\n}\n\nexport const filterGlobalHook = (\n\thook: LocalHook<any, any>\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error)\n\t} as LocalHook<any, any>\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport type HTTPStatusName = keyof typeof StatusMap\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst encoder = new TextEncoder()\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\tconst hmacArray = Array.from(new Uint8Array(hmacBuffer))\n\tconst digest = btoa(String.fromCharCode(...hmacArray))\n\treturn `${val}.${digest.replace(/=+$/, '')}`\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { isNotEmpty } from './handler'\n\nimport type {\n\tLifeCycleStore,\n\tLocalHook,\n\tMaybeArray,\n\tInputSchema\n} from './types'\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const getHostname = (url: string) => url.slice(0, url.indexOf('/', 11))\n\nconst isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle import * as Sentry from '@sentry/bun'\n\t// This also handle [object Date], [object Array]\n\t// and FFI value like [object Prisma]\n\tv.toString().startsWith('[object ') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nexport const mergeDeep = <\n\tconst A extends Record<string, any>,\n\tconst B extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys\n\t}: {\n\t\tskipKeys?: string[]\n\t} = {}\n): A & B => {\n\tif (isObject(target) && isObject(source))\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tif (skipKeys?.includes(key)) continue\n\n\t\t\tif (!isObject(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (!(key in target)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (isClass(value)) {\n\t\t\t\ttarget[key as keyof typeof target] = value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t\t(target as any)[key] as any,\n\t\t\t\tvalue\n\t\t\t)\n\t\t}\n\n\treturn target as A & B\n}\n\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ttarget: A,\n\tsource: B\n): A & B =>\n\tmergeDeep(target, source, {\n\t\tskipKeys: ['properties']\n\t})\n\nexport const mergeObjectArray = <T>(a: T | T[], b: T | T[]): T[] => {\n\t// ! Must copy to remove side-effect\n\tconst array = [...(Array.isArray(a) ? a : [a])]\n\tconst checksums = []\n\n\tfor (const item of array) {\n\t\t// @ts-ignore\n\t\tif (item.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tchecksums.push(item.$elysiaChecksum)\n\t}\n\n\tfor (const item of Array.isArray(b) ? b : [b]) {\n\t\t// @ts-ignore\n\t\tif (!checksums.includes(item?.$elysiaChecksum)) array.push(item)\n\t}\n\n\treturn array\n}\n\nexport const mergeHook = (\n\ta?: LocalHook<any, any, any, any> | LifeCycleStore,\n\tb?: LocalHook<any, any, any, any>\n): LifeCycleStore => {\n\treturn {\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tresponse: b?.response ?? a?.response,\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray((a?.parse as any) ?? [], b?.parse ?? []),\n\t\ttransform: mergeObjectArray(\n\t\t\ta?.transform ?? [],\n\t\t\tb?.transform ?? []\n\t\t) as any,\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta?.beforeHandle ?? [],\n\t\t\tb?.beforeHandle ?? []\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta?.afterHandle ?? [],\n\t\t\tb?.afterHandle ?? []\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta?.onResponse ?? [],\n\t\t\tb?.onResponse ?? []\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace ?? [], b?.trace ?? []) as any,\n\t\terror: mergeObjectArray(a?.error ?? [], b?.error ?? [])\n\t}\n}\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic)\n\t\treturn {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\treturn TypeCompiler.Compile(schema, Object.values(models))\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\treturn TypeCompiler.Compile(schema, references)\n\t}\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, Object.values(models))\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] = Kind in schema ? compile(schema, Object.values(models)) : schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, Object.values(models))\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const mergeLifeCycle = (\n\ta: LifeCycleStore,\n\tb: LifeCycleStore | LocalHook,\n\tchecksum?: number\n): LifeCycleStore => {\n\tconst injectChecksum = <T>(x: T): T => {\n\t\t// @ts-ignore\n\t\tif (checksum && !x.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaChecksum = checksum\n\n\t\treturn x\n\t}\n\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start as any,\n\t\t\t('start' in b ? b.start ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\trequest: mergeObjectArray(\n\t\t\ta.request as any,\n\t\t\t('request' in b ? b.request ?? [] : []).map(injectChecksum) as any\n\t\t),\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse as any,\n\t\t\t'parse' in b ? b?.parse ?? [] : undefined ?? ([] as any)\n\t\t).map(injectChecksum),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform as any,\n\t\t\t(b?.transform ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle as any,\n\t\t\t(b?.beforeHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle as any,\n\t\t\t(b?.afterHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse as any,\n\t\t\t(b?.onResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\ttrace: a.trace,\n\t\t// trace: mergeObjectArray(\n\t\t// \ta.trace as any,\n\t\t// \t('trace' in b ? b.trace ?? [] : ([] as any)).map(injectChecksum)\n\t\t// ),\n\t\terror: mergeObjectArray(\n\t\t\ta.error as any,\n\t\t\t(b?.error ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop as any,\n\t\t\t('stop' in b ? b.stop ?? [] : ([] as any)).map(injectChecksum)\n\t\t)\n\t}\n}\n\nexport const asGlobalHook = (\n\thook: LocalHook<any, any>,\n\tinject = true\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: asGlobal(hook?.parse, inject),\n\t\ttransform: asGlobal(hook?.transform, inject),\n\t\tbeforeHandle: asGlobal(hook?.beforeHandle, inject),\n\t\tafterHandle: asGlobal(hook?.afterHandle, inject),\n\t\tonResponse: asGlobal(hook?.onResponse, inject),\n\t\terror: asGlobal(hook?.error, inject)\n\t} as LocalHook<any, any>\n}\n\nexport const asGlobal = <T extends MaybeArray<Function> | undefined>(\n\tfn: T,\n\tinject = true\n): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tfn.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse fn.$elysiaHookType = undefined\n\n\t\treturn fn\n\t}\n\n\treturn fn.map((x) => {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse x.$elysiaHookType = undefined\n\n\t\treturn x\n\t}) as T\n}\n\nconst filterGlobal = <T extends MaybeArray<Function> | undefined>(fn: T): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\t// @ts-ignore\n\t\treturn fn.$elysiaHookType === 'global' ? fn : undefined\n\t}\n\n\t// @ts-ignore\n\treturn fn.filter((x) => x.$elysiaHookType === 'global') as T\n}\n\nexport const filterGlobalHook = (\n\thook: LocalHook<any, any>\n): LocalHook<any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error)\n\t} as LocalHook<any, any>\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport type HTTPStatusName = keyof typeof StatusMap\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst encoder = new TextEncoder()\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\tconst hmacArray = Array.from(new Uint8Array(hmacBuffer))\n\tconst digest = btoa(String.fromCharCode(...hmacArray))\n\treturn `${val}.${digest.replace(/=+$/, '')}`\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n",
  "// @ts-ignore\nimport { parse } from 'cookie'\nimport type { Context } from './context'\n\nimport { unsignCookie } from './utils'\nimport { InvalidCookieSignature } from './error'\n\nexport interface CookieOptions {\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no\n\t * domain is set, and most clients will consider the cookie to apply to only\n\t * the current domain.\n\t */\n\tdomain?: string | undefined\n\n\t/**\n\t * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,\n\t * no expiration is set, and most clients will consider this a \"non-persistent cookie\" and will delete\n\t * it on a condition like exiting a web browser application.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\texpires?: Date | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.\n\t * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By\n\t * default, the `HttpOnly` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to true, as compliant clients will\n\t * not allow client-side JavaScript to see the cookie in `document.cookie`.\n\t */\n\thttpOnly?: boolean | undefined\n\t/**\n\t * Specifies the number (in seconds) to be the value for the `Max-Age`\n\t * `Set-Cookie` attribute. The given number will be converted to an integer\n\t * by rounding down. By default, no maximum age is set.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\tmaxAge?: number | undefined\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.\n\t * By default, the path is considered the \"default path\".\n\t */\n\tpath?: string | undefined\n\t/**\n\t * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * - `'low'` will set the `Priority` attribute to `Low`.\n\t * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n\t * - `'high'` will set the `Priority` attribute to `High`.\n\t *\n\t * More information about the different priority levels can be found in\n\t * [the specification][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t */\n\tpriority?: 'low' | 'medium' | 'high' | undefined\n\t/**\n\t * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.\n\t *\n\t * - `true` will set the `SameSite` attribute to `Strict` for strict same\n\t * site enforcement.\n\t * - `false` will not set the `SameSite` attribute.\n\t * - `'lax'` will set the `SameSite` attribute to Lax for lax same site\n\t * enforcement.\n\t * - `'strict'` will set the `SameSite` attribute to Strict for strict same\n\t * site enforcement.\n\t *  - `'none'` will set the SameSite attribute to None for an explicit\n\t *  cross-site cookie.\n\t *\n\t * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.\n\t *\n\t * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.\n\t */\n\tsameSite?: true | false | 'lax' | 'strict' | 'none' | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the\n\t * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to `true`, as compliant clients will\n\t * not send the cookie back to the server in the future if the browser does\n\t * not have an HTTPS connection.\n\t */\n\tsecure?: boolean | undefined\n\n\t/**\n\t * Secret key for signing cookie\n\t *\n\t * If array is passed, will use Key Rotation.\n\t *\n\t * Key rotation is when an encryption key is retired\n\t * and replaced by generating a new cryptographic key.\n\t */\n\tsecrets?: string | string[]\n}\n\ntype MutateCookie<T = unknown> = CookieOptions & {\n\tvalue?: T\n} extends infer A\n\t? A | ((previous: A) => A)\n\t: never\n\ntype CookieJar = Record<string, Cookie>\n\nexport class Cookie<T = unknown> implements CookieOptions {\n\tpublic name: string | undefined\n\tprivate setter: Context['set'] | undefined\n\n\tconstructor(\n\t\tprivate _value: T,\n\t\tpublic property: Readonly<CookieOptions> = {}\n\t) {}\n\n\tget() {\n\t\treturn this._value\n\t}\n\n\tget value(): T {\n\t\treturn this._value as any\n\t}\n\n\tset value(value: T) {\n\t\tif (typeof value === 'object') {\n\t\t\tif (JSON.stringify(this.value) === JSON.stringify(value)) return\n\t\t} else if (this.value === value) return\n\n\t\tthis._value = value as any\n\n\t\tthis.sync()\n\t}\n\n\tadd<T>(config: MutateCookie<T>): Cookie<T> {\n\t\tconst updated = Object.assign(\n\t\t\tthis.property,\n\t\t\ttypeof config === 'function'\n\t\t\t\t? config(Object.assign(this.property, this.value) as any)\n\t\t\t\t: config\n\t\t)\n\n\t\tif ('value' in updated) {\n\t\t\tthis._value = updated.value as any\n\n\t\t\tdelete updated.value\n\t\t}\n\n\t\tthis.property = updated\n\t\treturn this.sync() as any\n\t}\n\n\tset<T>(config: MutateCookie): Cookie<T> {\n\t\tconst updated =\n\t\t\ttypeof config === 'function'\n\t\t\t\t? config(Object.assign(this.property, this.value) as any)\n\t\t\t\t: config\n\n\t\tif ('value' in updated) {\n\t\t\tthis._value = updated.value as any\n\n\t\t\tdelete updated.value\n\t\t}\n\n\t\tthis.property = updated\n\t\treturn this.sync() as any\n\t}\n\n\tremove(\n\t\toptions?: Pick<CookieOptions, 'domain' | 'path' | 'sameSite' | 'secure'>\n\t) {\n\t\tif (this.value === undefined) return\n\n\t\tthis.set({\n\t\t\tdomain: options?.domain,\n\t\t\texpires: new Date(0),\n\t\t\tmaxAge: 0,\n\t\t\tpath: options?.path,\n\t\t\tsameSite: options?.sameSite,\n\t\t\tsecure: options?.secure,\n\t\t\tvalue: '' as any\n\t\t})\n\t}\n\n\tget domain() {\n\t\treturn this.property.domain\n\t}\n\n\tset domain(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.domain === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.domain = value\n\n\t\tthis.sync()\n\t}\n\n\tget expires() {\n\t\treturn this.property.expires\n\t}\n\n\tset expires(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.expires?.getTime() === value?.getTime()) return\n\n\t\t// @ts-ignore\n\t\tthis.property.expires = value\n\n\t\tthis.sync()\n\t}\n\n\tget httpOnly() {\n\t\treturn this.property.httpOnly\n\t}\n\n\tset httpOnly(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.domain === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.httpOnly = value\n\n\t\tthis.sync()\n\t}\n\n\tget maxAge() {\n\t\treturn this.property.maxAge\n\t}\n\n\tset maxAge(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.maxAge === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.maxAge = value\n\n\t\tthis.sync()\n\t}\n\n\tget path() {\n\t\treturn this.property.path\n\t}\n\n\tset path(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.path === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.path = value\n\n\t\tthis.sync()\n\t}\n\n\tget priority() {\n\t\treturn this.property.priority\n\t}\n\n\tset priority(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.priority === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.priority = value\n\n\t\tthis.sync()\n\t}\n\n\tget sameSite() {\n\t\treturn this.property.sameSite\n\t}\n\n\tset sameSite(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.sameSite === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.sameSite = value\n\n\t\tthis.sync()\n\t}\n\n\tget secure() {\n\t\treturn this.property.secure\n\t}\n\n\tset secure(value) {\n\t\t// @ts-ignore\n\t\tif (this.property.secure === value) return\n\n\t\t// @ts-ignore\n\t\tthis.property.secure = value\n\n\t\tthis.sync()\n\t}\n\n\ttoString() {\n\t\treturn typeof this.value === 'object'\n\t\t\t? JSON.stringify(this.value)\n\t\t\t: this.value?.toString() ?? ''\n\t}\n\n\tprivate sync() {\n\t\tif (!this.name || !this.setter) return this\n\n\t\tif (!this.setter.cookie)\n\t\t\tthis.setter.cookie = {\n\t\t\t\t[this.name]: Object.assign(this.property, {\n\t\t\t\t\tvalue: this.toString()\n\t\t\t\t})\n\t\t\t}\n\t\telse\n\t\t\tthis.setter.cookie[this.name] = Object.assign(this.property, {\n\t\t\t\tvalue: this.toString()\n\t\t\t})\n\n\t\treturn this\n\t}\n}\n\nexport const createCookieJar = (\n\tinitial: CookieJar,\n\tset: Context['set'],\n\tproperties?: CookieOptions\n) =>\n\tnew Proxy(initial as CookieJar, {\n\t\tget(target, key: string) {\n\t\t\tif (key in target) return target[key]\n\n\t\t\t// @ts-ignore\n\t\t\tconst cookie = new Cookie(\n\t\t\t\tundefined,\n\t\t\t\tproperties ? { ...properties } : undefined\n\t\t\t)\n\t\t\t// @ts-ignore\n\t\t\tcookie.setter = set\n\t\t\tcookie.name = key\n\n\t\t\t// @ts-ignore\n\t\t\treturn cookie\n\t\t},\n\t\tset(target, key: string, value) {\n\t\t\tif (!(value instanceof Cookie)) return false\n\n\t\t\tif (!set.cookie) set.cookie = {}\n\n\t\t\t// @ts-ignore\n\t\t\tvalue.setter = set\n\t\t\tvalue.name = key\n\n\t\t\t// @ts-ignore\n\t\t\tvalue.sync()\n\n\t\t\ttarget[key] = value\n\n\t\t\treturn true\n\t\t}\n\t})\n\nexport const parseCookie = async (\n\tset: Context['set'],\n\tcookieString?: string | null,\n\t{\n\t\tsecret,\n\t\tsign,\n\t\t...properties\n\t}: CookieOptions & {\n\t\tsecret?: string | string[]\n\t\tsign?: true | string | string[]\n\t} = {}\n) => {\n\tif (!cookieString) return createCookieJar({}, set, properties)\n\n\tconst jar: CookieJar = {}\n\tconst isStringKey = typeof secret === 'string'\n\n\tif (sign && sign !== true && !Array.isArray(sign)) sign = [sign]\n\n\tconst cookieKeys = Object.keys(parse(cookieString))\n\tfor (let i = 0; i < cookieKeys.length; i++) {\n\t\tconst key = cookieKeys[i]\n\t\tlet value = parse(cookieString)[key]\n\n\t\tif (sign === true || sign?.includes(key)) {\n\t\t\tif (!secret)\n\t\t\t\tthrow new Error('No secret is provided to cookie plugin')\n\n\t\t\tif (isStringKey) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tvalue = await unsignCookie(value as string, secret)\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (value === false) throw new InvalidCookieSignature(key)\n\t\t\t} else {\n\t\t\t\tlet fail = true\n\t\t\t\tfor (let i = 0; i < secret.length; i++) {\n\t\t\t\t\tconst temp = await unsignCookie(value as string, secret[i])\n\n\t\t\t\t\tif (temp !== false) {\n\t\t\t\t\t\tvalue = temp\n\t\t\t\t\t\tfail = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fail) throw new InvalidCookieSignature(key)\n\t\t\t}\n\t\t}\n\n\t\tif (value === undefined) continue\n\n\t\tconst start = (value as string).charCodeAt(0)\n\t\tif (start === 123 || start === 91)\n\t\t\ttry {\n\t\t\t\tconst cookie = new Cookie(JSON.parse(value as string))\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tcookie.setter = set\n\t\t\t\tcookie.name = key\n\n\t\t\t\tjar[key] = cookie\n\n\t\t\t\tcontinue\n\t\t\t} catch {\n\t\t\t\t// Not empty\n\t\t\t}\n\n\t\t// @ts-ignore\n\t\tif (!Number.isNaN(+value)) value = +value\n\t\t// @ts-ignore\n\t\telse if (value === 'true') value = true\n\t\t// @ts-ignore\n\t\telse if (value === 'false') value = false\n\n\t\tconst cookie = new Cookie(value, properties)\n\n\t\t// @ts-ignore\n\t\tcookie.setter = set\n\t\tcookie.name = key\n\n\t\tjar[key] = cookie\n\t}\n\n\treturn createCookieJar(jar, set)\n}\n",
  "// @ts-ignore\nimport { serialize } from 'cookie'\nimport { StatusMap } from './utils'\n\nimport type { Context } from './context'\nimport { Cookie } from './cookie'\n\nconst hasHeaderShorthand = 'toJSON' in new Headers()\n\ntype SetResponse = Omit<Context['set'], 'status'> & {\n\tstatus: number\n}\n\nexport const isNotEmpty = (obj: Object) => {\n\tfor (const x in obj) return true\n\n\treturn false\n}\n\nexport const parseSetCookies = (headers: Headers, setCookie: string[]) => {\n\tif (!headers || !Array.isArray(setCookie)) return headers\n\n\theaders.delete('Set-Cookie')\n\n\tfor (let i = 0; i < setCookie.length; i++) {\n\t\tconst index = setCookie[i].indexOf('=')\n\n\t\theaders.append(\n\t\t\t'Set-Cookie',\n\t\t\t`${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`\n\t\t)\n\t}\n\n\treturn headers\n}\n\nexport const cookieToHeader = (cookies: Context['set']['cookie']) => {\n\tif (!cookies || typeof cookies !== 'object' || !isNotEmpty(cookies))\n\t\treturn undefined\n\n\tconst set: string[] = []\n\n\tfor (const [key, property] of Object.entries(cookies)) {\n\t\tif (!key || !property) continue\n\n\t\tif (Array.isArray(property.value)) {\n\t\t\tfor (let i = 0; i < property.value.length; i++) {\n\t\t\t\tlet value = property.value[i]\n\t\t\t\tif (value === undefined || value === null) continue\n\n\t\t\t\tif (typeof value === 'object') value = JSON.stringify(value)\n\n\t\t\t\tset.push(serialize(key, value, property))\n\t\t\t}\n\t\t} else {\n\t\t\tlet value = property.value\n\t\t\tif (value === undefined || value === null) continue\n\n\t\t\tif (typeof value === 'object') value = JSON.stringify(value)\n\n\t\t\tset.push(serialize(key, property.value, property))\n\t\t}\n\t}\n\n\tif (set.length === 0) return undefined\n\tif (set.length === 1) return set[0]\n\n\treturn set\n}\n\nexport const mapResponse = (\n\tresponse: unknown,\n\tset: Context['set']\n): Response => {\n\tif (\n\t\t// @ts-ignore\n\t\tresponse?.$passthrough\n\t)\n\t\t// @ts-ignore\n\t\tresponse = response[response.$passthrough]\n\n\tif (\n\t\tisNotEmpty(set.headers) ||\n\t\tset.status !== 200 ||\n\t\tset.redirect ||\n\t\tset.cookie\n\t) {\n\t\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\t\t\tif (!set.status || set.status < 300 || set.status >= 400)\n\t\t\t\tset.status = 302\n\t\t}\n\n\t\tif (set.cookie && isNotEmpty(set.cookie))\n\t\t\tset.headers['Set-Cookie'] = cookieToHeader(set.cookie)\n\n\t\tif (\n\t\t\tset.headers['Set-Cookie'] &&\n\t\t\tArray.isArray(set.headers['Set-Cookie'])\n\t\t)\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers),\n\t\t\t\tset.headers['Set-Cookie']\n\t\t\t) as any\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\tcase 'Blob':\n\t\t\t\treturn new Response(response as string | Blob, {\n\t\t\t\t\tstatus: set.status,\n\t\t\t\t\theaders: set.headers\n\t\t\t\t})\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as ReadableStream,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\t\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('', set as SetResponse)\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Response':\n\t\t\t\tconst inherits = { ...set.headers }\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\tset.headers = (response as Response).headers.toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t(response as Response).headers.append(key, inherits[key])\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn response.then((x) => mapResponse(x, set))\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123) {\n\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\treturn new Response(\n\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t) as any\n\t\t\t\t}\n\n\t\t\t\treturn new Response(r, set as SetResponse)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\tcase 'Blob':\n\t\t\t\treturn new Response(response as string | Blob)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\t\t\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as any as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapCompactResponse(x)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn new Response('')\n\t\t\t\t})\n\n\t\t\t// ? Maybe response or Blob\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\n\t\t\t\treturn new Response(r)\n\t\t}\n}\n\nexport const mapEarlyResponse = (\n\tresponse: unknown,\n\tset: Context['set']\n): Response | undefined => {\n\tif (response === undefined || response === null) return\n\n\tif (\n\t\t// @ts-ignore\n\t\tresponse?.$passthrough\n\t)\n\t\t// @ts-ignore\n\t\tresponse = response[response.$passthrough]\n\n\tif (\n\t\tisNotEmpty(set.headers) ||\n\t\tset.status !== 200 ||\n\t\tset.redirect ||\n\t\tset.cookie\n\t) {\n\t\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\n\t\t\tif (!set.status || set.status < 300 || set.status >= 400)\n\t\t\t\tset.status = 302\n\t\t}\n\n\t\tif (set.cookie && isNotEmpty(set.cookie))\n\t\t\tset.headers['Set-Cookie'] = cookieToHeader(set.cookie)\n\n\t\tif (\n\t\t\tset.headers['Set-Cookie'] &&\n\t\t\tArray.isArray(set.headers['Set-Cookie'])\n\t\t)\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers),\n\t\t\t\tset.headers['Set-Cookie']\n\t\t\t) as any\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\tcase 'Blob':\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as string | Blob,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as ReadableStream,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Response':\n\t\t\t\tconst inherits = Object.assign({}, set.headers)\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tset.headers = (response as Response).headers.toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\tif (!(key in set.headers)) set.headers[key] = value\n\n\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t(response as Response).headers.append(key, inherits[key])\n\n\t\t\t\tif ((response as Response).status !== set.status)\n\t\t\t\t\tset.status = (response as Response).status\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapEarlyResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123) {\n\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\treturn new Response(\n\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t) as any\n\t\t\t\t}\n\n\t\t\t\treturn new Response(r, set as SetResponse)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\tcase 'Blob':\n\t\t\t\treturn new Response(response as string | Blob)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\n\t\t\t\treturn new Response(r)\n\t\t}\n}\n\nexport const mapCompactResponse = (response: unknown): Response => {\n\tif (\n\t\t// @ts-ignore\n\t\tresponse?.$passthrough\n\t)\n\t\t// @ts-ignore\n\t\tresponse = response[response.$passthrough]\n\n\tswitch (response?.constructor?.name) {\n\t\tcase 'String':\n\t\tcase 'Blob':\n\t\t\treturn new Response(response as string | Blob)\n\n\t\tcase 'Object':\n\t\tcase 'Array':\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'ReadableStream':\n\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase undefined:\n\t\t\tif (!response) return new Response('')\n\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Response':\n\t\t\treturn response as Response\n\n\t\tcase 'Error':\n\t\t\treturn errorToResponse(response as Error)\n\n\t\tcase 'Promise':\n\t\t\t// @ts-ignore\n\t\t\treturn (response as any as Promise<unknown>).then((x) => {\n\t\t\t\tconst r = mapCompactResponse(x)\n\n\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\treturn new Response('')\n\t\t\t})\n\n\t\t// ? Maybe response or Blob\n\t\tcase 'Function':\n\t\t\treturn mapCompactResponse((response as Function)())\n\n\t\tcase 'Number':\n\t\tcase 'Boolean':\n\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\tdefault:\n\t\t\tconst r = JSON.stringify(response)\n\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t}) as any\n\n\t\t\treturn new Response(r)\n\t}\n}\n\nexport const errorToResponse = (error: Error, set?: Context['set']) =>\n\tnew Response(\n\t\tJSON.stringify({\n\t\t\tname: error?.name,\n\t\t\tmessage: error?.message,\n\t\t\tcause: error?.cause\n\t\t}),\n\t\t{\n\t\t\tstatus: set?.status !== 200 ? (set?.status as number) ?? 500 : 500,\n\t\t\theaders: set?.headers\n\t\t}\n\t)\n",
  "import { type Elysia } from '.'\n\nimport { TypeCheck } from '@sinclair/typebox/compiler'\nimport type { TAnySchema } from '@sinclair/typebox'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { signCookie } from './utils'\n\nimport {\n\tmapEarlyResponse,\n\tmapResponse,\n\tmapCompactResponse,\n\tisNotEmpty\n} from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE\n} from './error'\n\nimport { CookieOptions, parseCookie } from './cookie'\n\nimport type {\n\tComposedHandler,\n\tElysiaConfig,\n\tHandler,\n\tLifeCycleStore,\n\tPreHandler,\n\tSchemaValidator,\n\tTraceEvent,\n\tTraceReporter\n} from './types'\n\nconst headersHasToJSON = new Headers().toJSON\nconst findAliases = new RegExp(` (\\\\w+) = context`, 'g')\n\nconst requestId = { value: 0 }\n\nconst createReport = ({\n\thasTrace,\n\thasTraceSet = false,\n\taddFn,\n\tcondition = {}\n}: {\n\thasTrace: boolean | number\n\thasTraceSet?: boolean\n\taddFn(string: string): void\n\tcondition: Partial<Record<TraceEvent, boolean>>\n}) => {\n\taddFn(`\\nconst reporter = getReporter()\\n`)\n\n\tif (hasTrace) {\n\t\treturn (\n\t\t\tevent: TraceEvent,\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tattribute = '',\n\t\t\t\tunit = 0\n\t\t\t}: {\n\t\t\t\tname?: string\n\t\t\t\tattribute?: string\n\t\t\t\tunit?: number\n\t\t\t} = {}\n\t\t) => {\n\t\t\tconst dotIndex = event.indexOf('.')\n\t\t\tconst isGroup = dotIndex === -1\n\n\t\t\tif (\n\t\t\t\tevent !== 'request' &&\n\t\t\t\tevent !== 'response' &&\n\t\t\t\t!condition[\n\t\t\t\t\t(isGroup\n\t\t\t\t\t\t? event\n\t\t\t\t\t\t: event.slice(0, dotIndex)) as keyof typeof condition\n\t\t\t\t]\n\t\t\t)\n\t\t\t\treturn () => {\n\t\t\t\t\tif (hasTraceSet && event === 'afterHandle') {\n\t\t\t\t\t\taddFn(\n\t\t\t\t\t\t\t`reporter.emit('event',{id,event:'exit',type:'begin',time:0})`\n\t\t\t\t\t\t)\n\t\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (isGroup) name ||= event\n\t\t\telse name ||= 'anonymous'\n\n\t\t\taddFn(\n\t\t\t\t'\\n' +\n\t\t\t\t\t`reporter.emit('event', { \n\t\t\t\t\tid,\n\t\t\t\t\tevent: '${event}',\n\t\t\t\t\ttype: 'begin',\n\t\t\t\t\tname: '${name}',\n\t\t\t\t\ttime: performance.now(),\n\t\t\t\t\t${isGroup ? `unit: ${unit},` : ''}\n\t\t\t\t\t${attribute}\n\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t'\\n'\n\t\t\t)\n\n\t\t\tlet handled = false\n\n\t\t\treturn () => {\n\t\t\t\tif (handled) return\n\n\t\t\t\thandled = true\n\t\t\t\taddFn(\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tevent: '${event}',\n\t\t\t\t\t\t\ttype: 'end',\n\t\t\t\t\t\t\ttime: performance.now()\n\t\t\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t\t'\\n'\n\t\t\t\t)\n\n\t\t\t\tif (hasTraceSet && event === 'afterHandle') {\n\t\t\t\t\taddFn(\n\t\t\t\t\t\t`\\nreporter.emit('event',{id,event:'exit',type:'begin',time:0})\\n`\n\t\t\t\t\t)\n\t\t\t\t\taddFn('\\nawait traceDone\\n')\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn () => () => {}\n\t}\n}\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (\n\thasErrorHandler: boolean,\n\t{\n\t\tinjectResponse = ''\n\t}: {\n\t\tinjectResponse?: string\n\t} = {}\n) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 400; throw new ValidationError(\n'${type}',\n${type},\n${value}\n)`\n\t\t\t: `c.set.status = 400; return new ValidationError(\n\t'${type}',\n\t${type},\n\t${value}\n).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tconst returnError = hasErrorHandler\n\t\t\t? `throw new ValidationError(\n'response',\nresponse[c.set.status],\n${name}\n)`\n\t\t\t: `return new ValidationError(\n'response',\nresponse[c.set.status],\n${name}\n).toResponse(c.set.headers)`\n\n\t\treturn `\\n${injectResponse}\n\t\tif(response[c.set.status]?.Check(${name}) === false) { \n\tif(!(response instanceof Error))\n\t\t${returnError}\n}\\n`\n\t}\n})\n\nexport const isFnUse = (keyword: string, fnLiteral: string) => {\n\tfnLiteral = fnLiteral.trimStart()\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tif (/^(\\w+)\\(/g.test(fnLiteral))\n\t\tfnLiteral = fnLiteral.slice(fnLiteral.indexOf('('))\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\tconst restIndex =\n\t\targument.charCodeAt(0) === 123 ? argument.indexOf('...') : -1\n\n\t// Using object destructuring\n\tif (argument.charCodeAt(0) === 123) {\n\t\t// Since Function already format the code, styling is enforced\n\t\tif (argument.includes(keyword)) return true\n\n\t\tif (restIndex === -1) return false\n\t}\n\n\t// Match dot notation and named access\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${argument}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t) {\n\t\treturn true\n\t}\n\n\tconst restAlias =\n\t\trestIndex !== -1\n\t\t\t? argument.slice(\n\t\t\t\t\trestIndex + 3,\n\t\t\t\t\targument.indexOf(' ', restIndex + 3)\n\t\t\t  )\n\t\t\t: undefined\n\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${restAlias}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t)\n\t\treturn true\n\n\tconst aliases = [argument]\n\tif (restAlias) aliases.push(restAlias)\n\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [params] of fnLiteral.matchAll(destructuringRegex))\n\t\tif (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))\n\t\t\treturn true\n\n\treturn false\n}\n\nconst isContextPassToFunction = (fnLiteral: string) => {\n\tfnLiteral = fnLiteral.trimStart()\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tif (/^(\\w+)\\(/g.test(fnLiteral))\n\t\tfnLiteral = fnLiteral.slice(fnLiteral.indexOf('('))\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\tconst restIndex =\n\t\targument.charCodeAt(0) === 123 ? argument.indexOf('...') : -1\n\n\tconst restAlias =\n\t\trestIndex !== -1\n\t\t\t? argument.slice(\n\t\t\t\t\trestIndex + 3,\n\t\t\t\t\targument.indexOf(' ', restIndex + 3)\n\t\t\t  )\n\t\t\t: undefined\n\n\tconst aliases = [argument]\n\tif (restAlias) aliases.push(restAlias)\n\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tfor (const alias of aliases)\n\t\tif (new RegExp(`\\\\b\\\\w+\\\\([^)]*\\\\b${alias}\\\\b[^)]*\\\\)`).test(fnLiteral))\n\t\t\treturn true\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [renamed] of fnLiteral.matchAll(destructuringRegex))\n\t\tif (\n\t\t\tnew RegExp(`\\\\b\\\\w+\\\\([^)]*\\\\b${renamed}\\\\b[^)]*\\\\)`).test(\n\t\t\t\tfnLiteral\n\t\t\t)\n\t\t)\n\t\t\treturn true\n\n\treturn false\n}\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\nconst getUnionedType = (validator: TypeCheck<any> | undefined) => {\n\tif (!validator) return\n\n\t// @ts-ignore\n\tconst schema = validator?.schema\n\n\tif (schema && 'anyOf' in schema) {\n\t\tlet foundDifference = false\n\t\tconst type: string = schema.anyOf[0].type\n\n\t\tfor (const validator of schema.anyOf as { type: string }[]) {\n\t\t\tif (validator.type !== type) {\n\t\t\t\tfoundDifference = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (!foundDifference) return type\n\t}\n\n\t// @ts-ignore\n\treturn validator.schema?.type\n}\n\nconst matchFnReturn = /(?:return|=>) \\S*\\(/g\n\nexport const isAsync = (fn: Function) => {\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\treturn fn.toString().match(matchFnReturn)\n}\n\nexport const composeHandler = ({\n\tpath,\n\tmethod,\n\thooks,\n\tvalidator,\n\thandler,\n\thandleError,\n\tdefinitions,\n\tschema,\n\tonRequest,\n\tconfig,\n\tgetReporter\n}: {\n\tpath: string\n\tmethod: string\n\thooks: LifeCycleStore\n\tvalidator: SchemaValidator\n\thandler: Handler<any, any>\n\thandleError: Elysia['handleError']\n\tdefinitions?: Elysia['definitions']['type']\n\tschema?: Elysia['schema']\n\tonRequest: PreHandler<any, any>[]\n\tconfig: ElysiaConfig<any>\n\tgetReporter: () => TraceReporter\n}): ComposedHandler => {\n\tconst hasErrorHandler =\n\t\tconfig.forceErrorEncapsulation ||\n\t\thooks.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0 ||\n\t\t!!hooks.trace.length\n\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tconst traceLiteral = hooks.trace.map((x) => x.toString())\n\n\tlet hasUnknownContext = false\n\n\tif (isContextPassToFunction(handler.toString())) hasUnknownContext = true\n\n\tif (!hasUnknownContext)\n\t\tfor (const [key, value] of Object.entries(hooks)) {\n\t\t\tif (\n\t\t\t\t!Array.isArray(value) ||\n\t\t\t\t!value.length ||\n\t\t\t\t![\n\t\t\t\t\t'parse',\n\t\t\t\t\t'transform',\n\t\t\t\t\t'beforeHandle',\n\t\t\t\t\t'afterHandle',\n\t\t\t\t\t'onResponse'\n\t\t\t\t].includes(key)\n\t\t\t)\n\t\t\t\tcontinue\n\n\t\t\tfor (const handle of value) {\n\t\t\t\tif (typeof handle !== 'function') continue\n\n\t\t\t\tif (isContextPassToFunction(handle.toString())) {\n\t\t\t\t\thasUnknownContext = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUnknownContext) break\n\t\t}\n\n\tconst traceConditions: Record<\n\t\tExclude<TraceEvent, `${string}.unit` | 'request' | 'response' | 'exit'>,\n\t\tboolean\n\t> = {\n\t\tparse: traceLiteral.some((x) => isFnUse('parse', x)),\n\t\ttransform: traceLiteral.some((x) => isFnUse('transform', x)),\n\t\thandle: traceLiteral.some((x) => isFnUse('handle', x)),\n\t\tbeforeHandle: traceLiteral.some((x) => isFnUse('beforeHandle', x)),\n\t\tafterHandle: traceLiteral.some((x) => isFnUse('afterHandle', x)),\n\t\terror: hasErrorHandler || traceLiteral.some((x) => isFnUse('error', x))\n\t}\n\n\tconst hasTrace = hooks.trace.length > 0\n\tlet fnLiteral = ''\n\n\tconst lifeCycleLiteral =\n\t\tvalidator || (method !== 'GET' && method !== 'HEAD')\n\t\t\t? [\n\t\t\t\t\thandler,\n\t\t\t\t\t...hooks.transform,\n\t\t\t\t\t...hooks.beforeHandle,\n\t\t\t\t\t...hooks.afterHandle\n\t\t\t  ].map((x) => x.toString())\n\t\t\t: []\n\n\tconst hasBody =\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\t(hasUnknownContext ||\n\t\t\t(hooks.type !== 'none' &&\n\t\t\t\t(!!validator.body ||\n\t\t\t\t\t!!hooks.type ||\n\t\t\t\t\tlifeCycleLiteral.some((fn) => isFnUse('body', fn)))))\n\n\tconst hasHeaders =\n\t\thasUnknownContext ||\n\t\tvalidator.headers ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('headers', fn))\n\n\tconst hasCookie =\n\t\thasUnknownContext ||\n\t\tvalidator.cookie ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('cookie', fn))\n\n\t// @ts-ignore\n\tconst cookieMeta = validator?.cookie?.schema as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t? cookieMeta.secrets\n\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += `const _setCookie = c.set.cookie\n\t\tif(_setCookie) {`\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\t// encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\tencodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {\n\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')\n\t\t\t}`\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t// if (!(name in cookieMeta.properties)) continue\n\n\t\t\t\tencodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\t}\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler)\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += headersHasToJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}: \"${defaultValue}\",`\n\t\t\t\t\t: `${name}: ${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}: '${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}: ${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{\n\t\t\tsecret: ${\n\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t  cookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t  ) +\n\t\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\tsign: ${\n\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t? true\n\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t? '[' +\n\t\t\t\t\t  cookieMeta.sign.reduce((a, b) => a + `'${b}',`, '') +\n\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\t${get('domain')}\n\t\t\t${get('expires')}\n\t\t\t${get('httpOnly')}\n\t\t\t${get('maxAge')}\n\t\t\t${get('path', '/')}\n\t\t\t${get('priority')}\n\t\t\t${get('sameSite')}\n\t\t\t${get('secure')}\n\t\t}`\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\\n`\n\t}\n\n\tconst hasQuery =\n\t\thasUnknownContext ||\n\t\tvalidator.query ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('query', fn))\n\n\tif (hasQuery) {\n\t\tfnLiteral += `const url = c.request.url\n\n\t\tif(c.qi !== -1) {\n\t\t\tc.query ??= parseQuery(url.substring(c.qi + 1))\n\t\t} else {\n\t\t\tc.query ??= {}\n\t\t}\n\t\t`\n\t}\n\n\tconst traceLiterals = hooks.trace.map((x) => x.toString())\n\tconst hasTraceSet = traceLiterals.some(\n\t\t(fn) => isFnUse('set', fn) || isContextPassToFunction(fn)\n\t)\n\n\thasUnknownContext || hooks.trace.some((fn) => isFnUse('set', fn.toString()))\n\n\tconst hasSet =\n\t\thasTraceSet ||\n\t\thasCookie ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('set', fn)) ||\n\t\tonRequest.some((fn) => isFnUse('set', fn.toString()))\n\n\tif (hasTrace) fnLiteral += '\\nconst id = c.$$requestId\\n'\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet,\n\t\tcondition: traceConditions,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += hasErrorHandler ? 'try {\\n' : ''\n\n\tif (hasTrace) {\n\t\t// fnLiteral += `\\nconst traceDone = new Promise(r => r())\\n`\n\t\tfnLiteral += `\\nconst traceDone = Promise.all([`\n\t\tfor (let i = 0; i < hooks.trace.length; i++) {\n\t\t\tfnLiteral += `new Promise(r => { reporter.once(\\`res\\${id}.${i}\\`, r) }),`\n\t\t}\n\t\tfnLiteral += `])\\n`\n\t}\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\thasTraceSet ||\n\t\tisAsync(handler) ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tconst endParse = report('parse', {\n\t\tunit: hooks.parse.length\n\t})\n\n\tif (hasBody) {\n\t\tconst type = getUnionedType(validator?.body)\n\n\t\tif (hooks.type && !Array.isArray(hooks.type)) {\n\t\t\tif (hooks.type) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.json()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text':\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hooks.parse.length) fnLiteral += '}}'\n\t\t} else {\n\t\t\tconst getAotParser = () => {\n\t\t\t\tif (hooks.parse.length && type && !Array.isArray(hooks.type)) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst schema = validator?.body?.schema\n\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\thasType('File', schema) ||\n\t\t\t\t\t\t\t\thasType('Files', schema)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\treturn `c.body = {}\n\t\t\n\t\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\n\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t// else {\n\t\t\t\t\t\t\t// \t// Since it's an object an not accepting file\n\t\t\t\t\t\t\t// \t// we can infer that it's JSON\n\t\t\t\t\t\t\t// \tfnLiteral += `c.body = await c.request.json()\\n`\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// fnLiteral += defaultParser\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst aotParse = getAotParser()\n\n\t\t\tif (aotParse) fnLiteral += aotParse\n\t\t\telse {\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t\tfnLiteral += hasHeaders\n\t\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\t\tfnLiteral += `\n\t\t\t\tif (contentType) {\n\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n`\n\n\t\t\t\tif (hooks.parse.length) {\n\t\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\t\tconst endReport = report('parse', {\n\t\t\t\t\t\tunit: hooks.parse.length\n\t\t\t\t\t})\n\n\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\tconst endUnit = report('parse.unit', {\n\t\t\t\t\t\t\tname: hooks.parse[i].name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType)\\n`\n\t\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\\n`\n\t\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\t\tendUnit()\n\n\t\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t\t}\n\n\t\t\t\t\tendReport()\n\t\t\t\t}\n\n\t\t\t\tif (hooks.parse.length) fnLiteral += `if (!used)`\n\n\t\t\t\tfnLiteral += `\n\t\t\t\tswitch (contentType) {\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tc.body = await c.request.json()\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tc.body = await c.request.text()\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tc.body = {}\n\t\t\t\t\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\\n`\n\n\t\t\t\tfnLiteral += '}\\n'\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tendParse()\n\n\tif (hooks?.transform) {\n\t\tconst endTransform = report('transform', {\n\t\t\tunit: hooks.transform.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = report('transform.unit', {\n\t\t\t\tname: transform.name\n\t\t\t})\n\n\t\t\t// @ts-ignore\n\t\t\tif (transform.$elysia === 'derive')\n\t\t\t\tfnLiteral += isAsync(hooks.transform[i])\n\t\t\t\t\t? `Object.assign(c, await transform[${i}](c));`\n\t\t\t\t\t: `Object.assign(c, transform[${i}](c));`\n\t\t\telse\n\t\t\t\tfnLiteral += isAsync(hooks.transform[i])\n\t\t\t\t\t? `await transform[${i}](c);`\n\t\t\t\t\t: `transform[${i}](c);`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\tendTransform()\n\t}\n\n\tif (validator) {\n\t\tfnLiteral += '\\n'\n\n\t\tif (validator.headers) {\n\t\t\tfnLiteral += `if(headers.Check(c.headers) === false) {\n\t\t\t\t${composeValidation('headers')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `\\nc.headers = headers.Decode(c.headers)\\n`\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) {\n\t\t\t\t${composeValidation('params')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `\\nc.params = params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) {\n\t\t\t\t${composeValidation('query')} \n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\t// Decode doesn't work with Object.create(null)\n\t\t\t\tfnLiteral += `\\nc.query = query.Decode(Object.assign({}, c.query))\\n`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\tfnLiteral += `if(body.Check(c.body) === false) { \n\t\t\t\t${composeValidation('body')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.body.schema))\n\t\t\t\tfnLiteral += `\\nc.body = body.Decode(c.body)\\n`\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (isNotEmpty(validator.cookie?.schema.properties ?? {})) {\n\t\t\tfnLiteral += `const cookieValue = {}\n\t\t\tfor(const [key, value] of Object.entries(c.cookie))\n\t\t\t\tcookieValue[key] = value.value\n\n\t\t\tif(cookie.Check(cookieValue) === false) {\n\t\t\t\t${composeValidation('cookie', 'cookieValue')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.cookie.schema))\n\t\t\t\tfnLiteral += `\\nc.cookie = params.Decode(c.cookie)\\n`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst endBeforeHandle = report('beforeHandle', {\n\t\t\tunit: hooks.beforeHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst endUnit = report('beforeHandle.unit', {\n\t\t\t\tname: hooks.beforeHandle[i].name\n\t\t\t})\n\n\t\t\tconst name = `be${i}`\n\t\t\tconst returning = hasReturn(hooks.beforeHandle[i].toString())\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.beforeHandle[i])\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hooks.beforeHandle[i])\n\t\t\t\t\t? `let ${name} = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `let ${name} = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(${name} !== undefined) {\\n`\n\t\t\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\t\t\tunit: hooks.transform.length\n\t\t\t\t})\n\t\t\t\tif (hooks.afterHandle) {\n\t\t\t\t\tconst beName = name\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst returning = hasReturn(\n\t\t\t\t\t\t\thooks.afterHandle[i].toString()\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\t\t\t\tname: hooks.afterHandle[i].name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tfnLiteral += `c.response = ${beName}\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst name = `af${i}`\n\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `const ${name} = await afterHandle[${i}](c);\\n`\n\t\t\t\t\t\t\t\t: `const ${name} = afterHandle[${i}](c);\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.response = ${beName} = ${name} }\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tendAfterHandle()\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation(name)\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(${name}, c.set)}\\n`\n\t\t\t}\n\t\t}\n\n\t\tendBeforeHandle()\n\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: handler.name\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t? `let r = c.response = await handler(c);\\n`\n\t\t\t\t: `let r = c.response = handler(c);\\n`\n\t\telse\n\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t? `let r = await handler(c);\\n`\n\t\t\t\t: `let r = handler(c);\\n`\n\n\t\tendHandle()\n\n\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\tunit: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst name = `af${i}`\n\t\t\tconst returning = hasReturn(hooks.afterHandle[i].toString())\n\n\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\tname: hooks.afterHandle[i].name\n\t\t\t})\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t? `let ${name} = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t: `let ${name} = afterHandle[${i}](c)\\n`\n\t\t\t\telse\n\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t? `let ${name} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\\n`\n\t\t\t\t\t\t: `let ${name} = mapEarlyResponse(afterHandle[${i}](c), c.set)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(${name} !== undefined) {`\n\t\t\t\t\tfnLiteral += composeResponseValidation(name)\n\n\t\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, c.set)\\n`\n\n\t\t\t\t\tfnLiteral += `if(${name}) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tif (hasTraceSet)\n\t\t\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, c.set)\\n`\n\n\t\t\t\t\tfnLiteral += `return ${name} } }`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(${name}) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += `return ${name}}\\n`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tendAfterHandle()\n\n\t\tfnLiteral += `r = c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t} else {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: handler.name\n\t\t})\n\n\t\tif (validator.response) {\n\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t? `const r = await handler(c);\\n`\n\t\t\t\t: `const r = handler(c);\\n`\n\n\t\t\tendHandle()\n\n\t\t\tfnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t} else {\n\t\t\tif (traceConditions.handle || hasCookie) {\n\t\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t\t? `let r = await handler(c);\\n`\n\t\t\t\t\t: `let r = handler(c);\\n`\n\n\t\t\t\tendHandle()\n\n\t\t\t\treport('afterHandle')()\n\n\t\t\t\tfnLiteral += encodeCookie\n\n\t\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t\t} else {\n\t\t\t\tendHandle()\n\n\t\t\t\tconst handled = isAsync(handler)\n\t\t\t\t\t? 'await handler(c) '\n\t\t\t\t\t: 'handler(c)'\n\n\t\t\t\treport('afterHandle')()\n\n\t\t\t\tif (hasSet)\n\t\t\t\t\tfnLiteral += `return mapResponse(${handled}, c.set)\\n`\n\t\t\t\telse fnLiteral += `return mapCompactResponse(${handled})\\n`\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hasErrorHandler || handleResponse) {\n\t\tfnLiteral += `\n} catch(error) {`\n\n\t\tif (!maybeAsync) fnLiteral += `return (async () => {`\n\n\t\tfnLiteral += `const set = c.set\n\n\t\tif (!set.status || set.status < 300) set.status = error?.status || 500\n\t`\n\n\t\tconst endError = report('error', {\n\t\t\tunit: hooks.error.length\n\t\t})\n\t\tif (hooks.error.length) {\n\t\t\tfnLiteral += `\n\t\t\t\tc.error = error\n\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t`\n\n\t\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\t\tconst name = `er${i}`\n\t\t\t\tconst endUnit = report('error.unit', {\n\t\t\t\t\tname: hooks.error[i].name\n\t\t\t\t})\n\n\t\t\t\tfnLiteral += `\\nlet ${name} = handleErrors[${i}](c)\\n`\n\n\t\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\t\tfnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, set)\\n`\n\t\t\t\tfnLiteral += `if (${name}) {`\n\t\t\t\tfnLiteral += `return ${name} }\\n`\n\t\t\t}\n\t\t}\n\n\t\tendError()\n\n\t\tfnLiteral += `return handleError(c, error)\\n\\n`\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += '}'\n\n\t\tif (handleResponse || hasTrace) {\n\t\t\tfnLiteral += ` finally { `\n\n\t\t\tconst endResponse = report('response', {\n\t\t\t\tunit: hooks.onResponse.length\n\t\t\t})\n\n\t\t\tfnLiteral += handleResponse\n\n\t\t\tendResponse()\n\n\t\t\tfnLiteral += `}`\n\t\t}\n\t}\n\n\tfnLiteral = `const { \n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse,\n\t\t\tcookie\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function(c) {\n\t\t${schema && definitions ? 'c.schema = schema; c.defs = definitions;' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks,\n\t\tvalidator,\n\t\thandleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie\n\t})\n}\n\nexport const composeGeneralHandler = (app: Elysia<any, any, any, any, any>) => {\n\tlet decoratorsLiteral = ''\n\tlet fnLiteral = ''\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.decorators))\n\t\tdecoratorsLiteral += `,${key}: app.decorators.${key}`\n\n\t// @ts-ignore\n\tconst { router, staticRouter } = app\n\n\tconst hasTrace = app.event.trace.length > 0\n\n\tconst findDynamicRoute = `\n\tconst route = find(request.method, path) ${\n\t\trouter.root.ALL ? '?? find(\"ALL\", path)' : ''\n\t}\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `app.handleError(ctx, notFound)`\n\t\t\t\t: `new Response(error404, {\n\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,\n\t\t\t\t\theaders: ctx.set.headers\n\t\t\t\t})`\n\t\t}\n\n\tctx.params = route.params\n\n\treturn route.store(ctx)`\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(staticRouter.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: break map`\n\t\t}}\\n\\n`\n\n\tconst maybeAsync = app.event.request.some(isAsync)\n\n\tfnLiteral += `const {\n\t\tapp,\n\t\tapp: { store, router, staticRouter, wsRouter },\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trequestId,\n\t\tgetReporter\n\t} = data\n\n\tconst notFound = new NotFoundError()\n\n\t${app.event.request.length ? `const onRequest = app.event.request` : ''}\n\n\t${staticRouter.variables}\n\n\tconst find = router.find.bind(router)\n\tconst findWs = wsRouter.find.bind(wsRouter)\n\tconst handleError = app.handleError.bind(this)\n\n\t${app.event.error.length ? '' : `const error404 = notFound.message.toString()`}\n\n\treturn ${maybeAsync ? 'async' : ''} function map(request) {\n\t`\n\n\tconst traceLiteral = app.event.trace.map((x) => x.toString())\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet: app.event.trace.some((fn) => {\n\t\t\tconst literal = fn.toString()\n\n\t\t\treturn isFnUse('set', literal) || isContextPassToFunction(literal)\n\t\t}),\n\t\tcondition: {\n\t\t\trequest: traceLiteral.some(\n\t\t\t\t(x) => isFnUse('request', x) || isContextPassToFunction(x)\n\t\t\t)\n\t\t},\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tset: {\n\t\t\t\t\tcookie: {},\n\t\t\t\t\theaders: {},\n\t\t\t\t\tstatus: 200\n\t\t\t\t}\n\t\t\t\t${hasTrace ? ',$$requestId: +id' : ''}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\t\t`\n\n\t\tconst endReport = report('request', {\n\t\t\tattribute: 'ctx',\n\t\t\tunit: app.event.request.length\n\t\t})\n\n\t\tfnLiteral += `try {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst fn = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(fn.toString())\n\t\t\tconst maybeAsync = isAsync(fn)\n\n\t\t\tconst endUnit = report('request.unit', {\n\t\t\t\tname: app.event.request[i].name\n\t\t\t})\n\n\t\t\tconst name = `re${i}`\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral += `const ${name} = mapEarlyResponse(\n\t\t\t\t\t${maybeAsync ? 'await' : ''} onRequest[${i}](ctx),\n\t\t\t\t\tctx.set\n\t\t\t\t)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(${name}) return ${name}\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${\n\t\t\t\t\tmaybeAsync ? 'await' : ''\n\t\t\t\t} onRequest[${i}](ctx)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn app.handleError(ctx, error)\n\t\t}`\n\n\t\tendReport()\n\n\t\tfnLiteral += `\n\t\tconst url = request.url,\n\t\ts = url.indexOf('/', 11),\n\t\ti = ctx.qi = url.indexOf('?', s + 1),\n\t\tpath = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`\n\t} else {\n\t\tfnLiteral += `\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1\n\t\t\t\t? url.substring(s)\n\t\t\t\t: url.substring(s, qi)\n\n\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tset: {\n\t\t\t\theaders: {},\n\t\t\t\tstatus: 200\n\t\t\t}\n\t\t\t${hasTrace ? ',$$requestId: id' : ''}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\n\t\treport('request', {\n\t\t\tunit: app.event.request.length,\n\t\t\tattribute:\n\t\t\t\ttraceLiteral.some((x) => isFnUse('context', x)) ||\n\t\t\t\ttraceLiteral.some((x) => isFnUse('store', x)) ||\n\t\t\t\ttraceLiteral.some((x) => isFnUse('set', x))\n\t\t\t\t\t? 'ctx'\n\t\t\t\t\t: ''\n\t\t})()\n\t}\n\n\t// @ts-ignore\n\tconst wsPaths = app.wsPaths\n\t// @ts-ignore\n\tconst wsRouter = app.wsRouter\n\n\tif (Object.keys(wsPaths).length || wsRouter.history.length) {\n\t\tfnLiteral += `\n\t\t\tif(request.method === 'GET') {\n\t\t\t\tswitch(path) {`\n\n\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\tfnLiteral += `\n\t\t\t\t\tcase '${path}':\n\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')\n\t\t\t\t\t\t\treturn st${index}(ctx)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tbreak`\n\t\t}\n\n\t\tfnLiteral += `\n\t\t\t\tdefault:\n\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {\n\t\t\t\t\t\tconst route = findWs('ws', path)\n\n\t\t\t\t\t\tif(route) {\n\t\t\t\t\t\t\tctx.params = route.params\n\n\t\t\t\t\t\t\treturn route.store(ctx)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t}\n\n\tfnLiteral += `\n\t\tmap: switch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\n\t\t${findDynamicRoute}\n\t}`\n\n\t// @ts-ignore\n\tapp.handleError = composeErrorHandler(app) as any\n\n\t// console.log(fnLiteral)\n\t// console.log(app.event)\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\t// @ts-ignore\n\t\tgetReporter: () => app.reporter,\n\t\trequestId\n\t})\n}\n\nexport const composeErrorHandler = (app: Elysia<any, any, any, any, any>) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onError, onResponse: res } },\n\t\tmapResponse,\n\t\tERROR_CODE\n\t} = inject\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(context, error) {\n\t\tconst { set } = context\n\n\t\tcontext.code = error.code\n\t\tcontext.error = error\n\t\t`\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${isAsync(handler) ? 'await ' : ''}onError[${i}](context)`\n\n\t\tif (hasReturn(handler.toString()))\n\t\t\tfnLiteral += `const r${i} = ${response}; if(r${i} !== undefined) {\n\t\t\t\tif(set.status === 200) set.status = error.status\n\t\t\t\treturn mapResponse(r${i}, set)\n\t\t\t}\\n`\n\t\telse fnLiteral += response + '\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\" || error.constructor.name === \"TransformDecodeError\") {\n\t\tset.status = error.status ?? 400\n\t\treturn new Response(\n\t\t\terror.message, \n\t\t\t{ headers: set.headers, status: set.status }\n\t\t)\n\t} else {\n\t\treturn new Response(error.message, { headers: set.headers, status: error.status ?? 500 })\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE\n\t})\n}\n",
  "import { type Elysia } from '.'\n\nimport { TypeCheck } from '@sinclair/typebox/compiler'\nimport type { TAnySchema } from '@sinclair/typebox'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { signCookie } from './utils'\n\nimport {\n\tmapEarlyResponse,\n\tmapResponse,\n\tmapCompactResponse,\n\tisNotEmpty\n} from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE\n} from './error'\n\nimport { CookieOptions, parseCookie } from './cookie'\n\nimport type {\n\tComposedHandler,\n\tElysiaConfig,\n\tHandler,\n\tLifeCycleStore,\n\tPreHandler,\n\tSchemaValidator,\n\tTraceEvent,\n\tTraceReporter\n} from './types'\n\nconst headersHasToJSON = new Headers().toJSON\nconst findAliases = new RegExp(` (\\\\w+) = context`, 'g')\n\nconst requestId = { value: 0 }\n\nconst createReport = ({\n\thasTrace,\n\thasTraceSet = false,\n\taddFn,\n\tcondition = {}\n}: {\n\thasTrace: boolean | number\n\thasTraceSet?: boolean\n\taddFn(string: string): void\n\tcondition: Partial<Record<TraceEvent, boolean>>\n}) => {\n\taddFn(`\\nconst reporter = getReporter()\\n`)\n\n\tif (hasTrace) {\n\t\treturn (\n\t\t\tevent: TraceEvent,\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tattribute = '',\n\t\t\t\tunit = 0\n\t\t\t}: {\n\t\t\t\tname?: string\n\t\t\t\tattribute?: string\n\t\t\t\tunit?: number\n\t\t\t} = {}\n\t\t) => {\n\t\t\tconst dotIndex = event.indexOf('.')\n\t\t\tconst isGroup = dotIndex === -1\n\n\t\t\tif (\n\t\t\t\tevent !== 'request' &&\n\t\t\t\tevent !== 'response' &&\n\t\t\t\t!condition[\n\t\t\t\t\t(isGroup\n\t\t\t\t\t\t? event\n\t\t\t\t\t\t: event.slice(0, dotIndex)) as keyof typeof condition\n\t\t\t\t]\n\t\t\t)\n\t\t\t\treturn () => {\n\t\t\t\t\tif (hasTraceSet && event === 'afterHandle') {\n\t\t\t\t\t\taddFn(\n\t\t\t\t\t\t\t`reporter.emit('event',{id,event:'exit',type:'begin',time:0})`\n\t\t\t\t\t\t)\n\t\t\t\t\t\taddFn(`\\nawait traceDone\\n`)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (isGroup) name ||= event\n\t\t\telse name ||= 'anonymous'\n\n\t\t\taddFn(\n\t\t\t\t'\\n' +\n\t\t\t\t\t`reporter.emit('event', { \n\t\t\t\t\tid,\n\t\t\t\t\tevent: '${event}',\n\t\t\t\t\ttype: 'begin',\n\t\t\t\t\tname: '${name}',\n\t\t\t\t\ttime: performance.now(),\n\t\t\t\t\t${isGroup ? `unit: ${unit},` : ''}\n\t\t\t\t\t${attribute}\n\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t'\\n'\n\t\t\t)\n\n\t\t\tlet handled = false\n\n\t\t\treturn () => {\n\t\t\t\tif (handled) return\n\n\t\t\t\thandled = true\n\t\t\t\taddFn(\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t`reporter.emit('event', {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tevent: '${event}',\n\t\t\t\t\t\t\ttype: 'end',\n\t\t\t\t\t\t\ttime: performance.now()\n\t\t\t\t\t\t})`.replace(/(\\t| |\\n)/g, '') +\n\t\t\t\t\t\t'\\n'\n\t\t\t\t)\n\n\t\t\t\tif (hasTraceSet && event === 'afterHandle') {\n\t\t\t\t\taddFn(\n\t\t\t\t\t\t`\\nreporter.emit('event',{id,event:'exit',type:'begin',time:0})\\n`\n\t\t\t\t\t)\n\t\t\t\t\taddFn('\\nawait traceDone\\n')\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn () => () => {}\n\t}\n}\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (\n\thasErrorHandler: boolean,\n\t{\n\t\tinjectResponse = ''\n\t}: {\n\t\tinjectResponse?: string\n\t} = {}\n) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 400; throw new ValidationError(\n'${type}',\n${type},\n${value}\n)`\n\t\t\t: `c.set.status = 400; return new ValidationError(\n\t'${type}',\n\t${type},\n\t${value}\n).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tconst returnError = hasErrorHandler\n\t\t\t? `throw new ValidationError(\n'response',\nresponse[c.set.status],\n${name}\n)`\n\t\t\t: `return new ValidationError(\n'response',\nresponse[c.set.status],\n${name}\n).toResponse(c.set.headers)`\n\n\t\treturn `\\n${injectResponse}\n\t\tif(response[c.set.status]?.Check(${name}) === false) { \n\tif(!(response instanceof Error))\n\t\t${returnError}\n}\\n`\n\t}\n})\n\nexport const isFnUse = (keyword: string, fnLiteral: string) => {\n\tfnLiteral = fnLiteral.trimStart()\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tif (/^(\\w+)\\(/g.test(fnLiteral))\n\t\tfnLiteral = fnLiteral.slice(fnLiteral.indexOf('('))\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\tconst restIndex =\n\t\targument.charCodeAt(0) === 123 ? argument.indexOf('...') : -1\n\n\t// Using object destructuring\n\tif (argument.charCodeAt(0) === 123) {\n\t\t// Since Function already format the code, styling is enforced\n\t\tif (argument.includes(keyword)) return true\n\n\t\tif (restIndex === -1) return false\n\t}\n\n\t// Match dot notation and named access\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${argument}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t) {\n\t\treturn true\n\t}\n\n\tconst restAlias =\n\t\trestIndex !== -1\n\t\t\t? argument.slice(\n\t\t\t\t\trestIndex + 3,\n\t\t\t\t\targument.indexOf(' ', restIndex + 3)\n\t\t\t  )\n\t\t\t: undefined\n\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${restAlias}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t)\n\t\treturn true\n\n\tconst aliases = [argument]\n\tif (restAlias) aliases.push(restAlias)\n\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [params] of fnLiteral.matchAll(destructuringRegex))\n\t\tif (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))\n\t\t\treturn true\n\n\treturn false\n}\n\nconst isContextPassToFunction = (fnLiteral: string) => {\n\tfnLiteral = fnLiteral.trimStart()\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tif (/^(\\w+)\\(/g.test(fnLiteral))\n\t\tfnLiteral = fnLiteral.slice(fnLiteral.indexOf('('))\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\tconst restIndex =\n\t\targument.charCodeAt(0) === 123 ? argument.indexOf('...') : -1\n\n\tconst restAlias =\n\t\trestIndex !== -1\n\t\t\t? argument.slice(\n\t\t\t\t\trestIndex + 3,\n\t\t\t\t\targument.indexOf(' ', restIndex + 3)\n\t\t\t  )\n\t\t\t: undefined\n\n\tconst aliases = [argument]\n\tif (restAlias) aliases.push(restAlias)\n\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tfor (const alias of aliases)\n\t\tif (new RegExp(`\\\\b\\\\w+\\\\([^)]*\\\\b${alias}\\\\b[^)]*\\\\)`).test(fnLiteral))\n\t\t\treturn true\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [renamed] of fnLiteral.matchAll(destructuringRegex))\n\t\tif (\n\t\t\tnew RegExp(`\\\\b\\\\w+\\\\([^)]*\\\\b${renamed}\\\\b[^)]*\\\\)`).test(\n\t\t\t\tfnLiteral\n\t\t\t)\n\t\t)\n\t\t\treturn true\n\n\treturn false\n}\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\nconst getUnionedType = (validator: TypeCheck<any> | undefined) => {\n\tif (!validator) return\n\n\t// @ts-ignore\n\tconst schema = validator?.schema\n\n\tif (schema && 'anyOf' in schema) {\n\t\tlet foundDifference = false\n\t\tconst type: string = schema.anyOf[0].type\n\n\t\tfor (const validator of schema.anyOf as { type: string }[]) {\n\t\t\tif (validator.type !== type) {\n\t\t\t\tfoundDifference = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (!foundDifference) return type\n\t}\n\n\t// @ts-ignore\n\treturn validator.schema?.type\n}\n\nconst matchFnReturn = /(?:return|=>) \\S*\\(/g\n\nexport const isAsync = (fn: Function) => {\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\treturn fn.toString().match(matchFnReturn)\n}\n\nexport const composeHandler = ({\n\tpath,\n\tmethod,\n\thooks,\n\tvalidator,\n\thandler,\n\thandleError,\n\tdefinitions,\n\tschema,\n\tonRequest,\n\tconfig,\n\tgetReporter\n}: {\n\tpath: string\n\tmethod: string\n\thooks: LifeCycleStore\n\tvalidator: SchemaValidator\n\thandler: Handler<any, any>\n\thandleError: Elysia['handleError']\n\tdefinitions?: Elysia['definitions']['type']\n\tschema?: Elysia['schema']\n\tonRequest: PreHandler<any, any>[]\n\tconfig: ElysiaConfig<any>\n\tgetReporter: () => TraceReporter\n}): ComposedHandler => {\n\tconst hasErrorHandler =\n\t\tconfig.forceErrorEncapsulation ||\n\t\thooks.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0 ||\n\t\t!!hooks.trace.length\n\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tconst traceLiteral = hooks.trace.map((x) => x.toString())\n\n\tlet hasUnknownContext = false\n\n\tif (isContextPassToFunction(handler.toString())) hasUnknownContext = true\n\n\tif (!hasUnknownContext)\n\t\tfor (const [key, value] of Object.entries(hooks)) {\n\t\t\tif (\n\t\t\t\t!Array.isArray(value) ||\n\t\t\t\t!value.length ||\n\t\t\t\t![\n\t\t\t\t\t'parse',\n\t\t\t\t\t'transform',\n\t\t\t\t\t'beforeHandle',\n\t\t\t\t\t'afterHandle',\n\t\t\t\t\t'onResponse'\n\t\t\t\t].includes(key)\n\t\t\t)\n\t\t\t\tcontinue\n\n\t\t\tfor (const handle of value) {\n\t\t\t\tif (typeof handle !== 'function') continue\n\n\t\t\t\tif (isContextPassToFunction(handle.toString())) {\n\t\t\t\t\thasUnknownContext = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUnknownContext) break\n\t\t}\n\n\tconst traceConditions: Record<\n\t\tExclude<TraceEvent, `${string}.unit` | 'request' | 'response' | 'exit'>,\n\t\tboolean\n\t> = {\n\t\tparse: traceLiteral.some((x) => isFnUse('parse', x)),\n\t\ttransform: traceLiteral.some((x) => isFnUse('transform', x)),\n\t\thandle: traceLiteral.some((x) => isFnUse('handle', x)),\n\t\tbeforeHandle: traceLiteral.some((x) => isFnUse('beforeHandle', x)),\n\t\tafterHandle: traceLiteral.some((x) => isFnUse('afterHandle', x)),\n\t\terror: hasErrorHandler || traceLiteral.some((x) => isFnUse('error', x))\n\t}\n\n\tconst hasTrace = hooks.trace.length > 0\n\tlet fnLiteral = ''\n\n\tconst lifeCycleLiteral =\n\t\tvalidator || (method !== 'GET' && method !== 'HEAD')\n\t\t\t? [\n\t\t\t\t\thandler,\n\t\t\t\t\t...hooks.transform,\n\t\t\t\t\t...hooks.beforeHandle,\n\t\t\t\t\t...hooks.afterHandle\n\t\t\t  ].map((x) => x.toString())\n\t\t\t: []\n\n\tconst hasBody =\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\t(hasUnknownContext ||\n\t\t\t(hooks.type !== 'none' &&\n\t\t\t\t(!!validator.body ||\n\t\t\t\t\t!!hooks.type ||\n\t\t\t\t\tlifeCycleLiteral.some((fn) => isFnUse('body', fn)))))\n\n\tconst hasHeaders =\n\t\thasUnknownContext ||\n\t\tvalidator.headers ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('headers', fn))\n\n\tconst hasCookie =\n\t\thasUnknownContext ||\n\t\tvalidator.cookie ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('cookie', fn))\n\n\t// @ts-ignore\n\tconst cookieMeta = validator?.cookie?.schema as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t? cookieMeta.secrets\n\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += `const _setCookie = c.set.cookie\n\t\tif(_setCookie) {`\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\t// encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\tencodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {\n\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')\n\t\t\t}`\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t// if (!(name in cookieMeta.properties)) continue\n\n\t\t\t\tencodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\t}\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler)\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += headersHasToJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}: \"${defaultValue}\",`\n\t\t\t\t\t: `${name}: ${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}: '${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}: ${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{\n\t\t\tsecret: ${\n\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t  cookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t  ) +\n\t\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\tsign: ${\n\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t? true\n\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t? '[' +\n\t\t\t\t\t  cookieMeta.sign.reduce((a, b) => a + `'${b}',`, '') +\n\t\t\t\t\t  ']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\t${get('domain')}\n\t\t\t${get('expires')}\n\t\t\t${get('httpOnly')}\n\t\t\t${get('maxAge')}\n\t\t\t${get('path', '/')}\n\t\t\t${get('priority')}\n\t\t\t${get('sameSite')}\n\t\t\t${get('secure')}\n\t\t}`\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\\n`\n\t}\n\n\tconst hasQuery =\n\t\thasUnknownContext ||\n\t\tvalidator.query ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('query', fn))\n\n\tif (hasQuery) {\n\t\tfnLiteral += `const url = c.request.url\n\n\t\tif(c.qi !== -1) {\n\t\t\tc.query ??= parseQuery(url.substring(c.qi + 1))\n\t\t} else {\n\t\t\tc.query ??= {}\n\t\t}\n\t\t`\n\t}\n\n\tconst traceLiterals = hooks.trace.map((x) => x.toString())\n\tconst hasTraceSet = traceLiterals.some(\n\t\t(fn) => isFnUse('set', fn) || isContextPassToFunction(fn)\n\t)\n\n\thasUnknownContext || hooks.trace.some((fn) => isFnUse('set', fn.toString()))\n\n\tconst hasSet =\n\t\thasTraceSet ||\n\t\thasCookie ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('set', fn)) ||\n\t\tonRequest.some((fn) => isFnUse('set', fn.toString()))\n\n\tif (hasTrace) fnLiteral += '\\nconst id = c.$$requestId\\n'\n\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet,\n\t\tcondition: traceConditions,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += hasErrorHandler ? 'try {\\n' : ''\n\n\tif (hasTrace) {\n\t\t// fnLiteral += `\\nconst traceDone = new Promise(r => r())\\n`\n\t\tfnLiteral += `\\nconst traceDone = Promise.all([`\n\t\tfor (let i = 0; i < hooks.trace.length; i++) {\n\t\t\tfnLiteral += `new Promise(r => { reporter.once(\\`res\\${id}.${i}\\`, r) }),`\n\t\t}\n\t\tfnLiteral += `])\\n`\n\t}\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\thasTraceSet ||\n\t\tisAsync(handler) ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tconst endParse = report('parse', {\n\t\tunit: hooks.parse.length\n\t})\n\n\tif (hasBody) {\n\t\tconst type = getUnionedType(validator?.body)\n\n\t\tif (hooks.type && !Array.isArray(hooks.type)) {\n\t\t\tif (hooks.type) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.json()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text':\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hooks.parse.length) fnLiteral += '}}'\n\t\t} else {\n\t\t\tconst getAotParser = () => {\n\t\t\t\tif (hooks.parse.length && type && !Array.isArray(hooks.type)) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst schema = validator?.body?.schema\n\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\thasType('File', schema) ||\n\t\t\t\t\t\t\t\thasType('Files', schema)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\treturn `c.body = {}\n\t\t\n\t\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\n\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t// else {\n\t\t\t\t\t\t\t// \t// Since it's an object an not accepting file\n\t\t\t\t\t\t\t// \t// we can infer that it's JSON\n\t\t\t\t\t\t\t// \tfnLiteral += `c.body = await c.request.json()\\n`\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// fnLiteral += defaultParser\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst aotParse = getAotParser()\n\n\t\t\tif (aotParse) fnLiteral += aotParse\n\t\t\telse {\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t\tfnLiteral += hasHeaders\n\t\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\t\tfnLiteral += `\n\t\t\t\tif (contentType) {\n\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n`\n\n\t\t\t\tif (hooks.parse.length) {\n\t\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\t\tconst endReport = report('parse', {\n\t\t\t\t\t\tunit: hooks.parse.length\n\t\t\t\t\t})\n\n\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\tconst endUnit = report('parse.unit', {\n\t\t\t\t\t\t\tname: hooks.parse[i].name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType)\\n`\n\t\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\\n`\n\t\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\t\tendUnit()\n\n\t\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t\t}\n\n\t\t\t\t\tendReport()\n\t\t\t\t}\n\n\t\t\t\tif (hooks.parse.length) fnLiteral += `if (!used)`\n\n\t\t\t\tfnLiteral += `\n\t\t\t\tswitch (contentType) {\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tc.body = await c.request.json()\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tc.body = await c.request.text()\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tc.body = {}\n\t\t\t\t\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\\n`\n\n\t\t\t\tfnLiteral += '}\\n'\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tendParse()\n\n\tif (hooks?.transform) {\n\t\tconst endTransform = report('transform', {\n\t\t\tunit: hooks.transform.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = report('transform.unit', {\n\t\t\t\tname: transform.name\n\t\t\t})\n\n\t\t\t// @ts-ignore\n\t\t\tif (transform.$elysia === 'derive')\n\t\t\t\tfnLiteral += isAsync(hooks.transform[i])\n\t\t\t\t\t? `Object.assign(c, await transform[${i}](c));`\n\t\t\t\t\t: `Object.assign(c, transform[${i}](c));`\n\t\t\telse\n\t\t\t\tfnLiteral += isAsync(hooks.transform[i])\n\t\t\t\t\t? `await transform[${i}](c);`\n\t\t\t\t\t: `transform[${i}](c);`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\tendTransform()\n\t}\n\n\tif (validator) {\n\t\tfnLiteral += '\\n'\n\n\t\tif (validator.headers) {\n\t\t\tfnLiteral += `if(headers.Check(c.headers) === false) {\n\t\t\t\t${composeValidation('headers')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `\\nc.headers = headers.Decode(c.headers)\\n`\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) {\n\t\t\t\t${composeValidation('params')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `\\nc.params = params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) {\n\t\t\t\t${composeValidation('query')} \n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\t// Decode doesn't work with Object.create(null)\n\t\t\t\tfnLiteral += `\\nc.query = query.Decode(Object.assign({}, c.query))\\n`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\tfnLiteral += `if(body.Check(c.body) === false) { \n\t\t\t\t${composeValidation('body')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.body.schema))\n\t\t\t\tfnLiteral += `\\nc.body = body.Decode(c.body)\\n`\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (isNotEmpty(validator.cookie?.schema.properties ?? {})) {\n\t\t\tfnLiteral += `const cookieValue = {}\n\t\t\tfor(const [key, value] of Object.entries(c.cookie))\n\t\t\t\tcookieValue[key] = value.value\n\n\t\t\tif(cookie.Check(cookieValue) === false) {\n\t\t\t\t${composeValidation('cookie', 'cookieValue')}\n\t\t\t}`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasTransform(validator.cookie.schema))\n\t\t\t\tfnLiteral += `\\nc.cookie = params.Decode(c.cookie)\\n`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst endBeforeHandle = report('beforeHandle', {\n\t\t\tunit: hooks.beforeHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst endUnit = report('beforeHandle.unit', {\n\t\t\t\tname: hooks.beforeHandle[i].name\n\t\t\t})\n\n\t\t\tconst name = `be${i}`\n\t\t\tconst returning = hasReturn(hooks.beforeHandle[i].toString())\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.beforeHandle[i])\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hooks.beforeHandle[i])\n\t\t\t\t\t? `let ${name} = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `let ${name} = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(${name} !== undefined) {\\n`\n\t\t\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\t\t\tunit: hooks.transform.length\n\t\t\t\t})\n\t\t\t\tif (hooks.afterHandle) {\n\t\t\t\t\tconst beName = name\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst returning = hasReturn(\n\t\t\t\t\t\t\thooks.afterHandle[i].toString()\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\t\t\t\tname: hooks.afterHandle[i].name\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tfnLiteral += `c.response = ${beName}\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst name = `af${i}`\n\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `const ${name} = await afterHandle[${i}](c);\\n`\n\t\t\t\t\t\t\t\t: `const ${name} = afterHandle[${i}](c);\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.response = ${beName} = ${name} }\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tendAfterHandle()\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation(name)\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(${name}, c.set)}\\n`\n\t\t\t}\n\t\t}\n\n\t\tendBeforeHandle()\n\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: handler.name\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t? `let r = c.response = await handler(c);\\n`\n\t\t\t\t: `let r = c.response = handler(c);\\n`\n\t\telse\n\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t? `let r = await handler(c);\\n`\n\t\t\t\t: `let r = handler(c);\\n`\n\n\t\tendHandle()\n\n\t\tconst endAfterHandle = report('afterHandle', {\n\t\t\tunit: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst name = `af${i}`\n\t\t\tconst returning = hasReturn(hooks.afterHandle[i].toString())\n\n\t\t\tconst endUnit = report('afterHandle.unit', {\n\t\t\t\tname: hooks.afterHandle[i].name\n\t\t\t})\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t? `let ${name} = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t: `let ${name} = afterHandle[${i}](c)\\n`\n\t\t\t\telse\n\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t? `let ${name} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\\n`\n\t\t\t\t\t\t: `let ${name} = mapEarlyResponse(afterHandle[${i}](c), c.set)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(${name} !== undefined) {`\n\t\t\t\t\tfnLiteral += composeResponseValidation(name)\n\n\t\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, c.set)\\n`\n\n\t\t\t\t\tfnLiteral += `if(${name}) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tif (hasTraceSet)\n\t\t\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, c.set)\\n`\n\n\t\t\t\t\tfnLiteral += `return ${name} } }`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(${name}) {`\n\t\t\t\t\tendAfterHandle()\n\n\t\t\t\t\tfnLiteral += `return ${name}}\\n`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tendAfterHandle()\n\n\t\tfnLiteral += `r = c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t} else {\n\t\tconst endHandle = report('handle', {\n\t\t\tname: handler.name\n\t\t})\n\n\t\tif (validator.response) {\n\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t? `const r = await handler(c);\\n`\n\t\t\t\t: `const r = handler(c);\\n`\n\n\t\t\tendHandle()\n\n\t\t\tfnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle')()\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t} else {\n\t\t\tif (traceConditions.handle || hasCookie) {\n\t\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t\t? `let r = await handler(c);\\n`\n\t\t\t\t\t: `let r = handler(c);\\n`\n\n\t\t\t\tendHandle()\n\n\t\t\t\treport('afterHandle')()\n\n\t\t\t\tfnLiteral += encodeCookie\n\n\t\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t\t} else {\n\t\t\t\tendHandle()\n\n\t\t\t\tconst handled = isAsync(handler)\n\t\t\t\t\t? 'await handler(c) '\n\t\t\t\t\t: 'handler(c)'\n\n\t\t\t\treport('afterHandle')()\n\n\t\t\t\tif (hasSet)\n\t\t\t\t\tfnLiteral += `return mapResponse(${handled}, c.set)\\n`\n\t\t\t\telse fnLiteral += `return mapCompactResponse(${handled})\\n`\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hasErrorHandler || handleResponse) {\n\t\tfnLiteral += `\n} catch(error) {`\n\n\t\tif (!maybeAsync) fnLiteral += `return (async () => {`\n\n\t\tfnLiteral += `const set = c.set\n\n\t\tif (!set.status || set.status < 300) set.status = error?.status || 500\n\t`\n\n\t\tconst endError = report('error', {\n\t\t\tunit: hooks.error.length\n\t\t})\n\t\tif (hooks.error.length) {\n\t\t\tfnLiteral += `\n\t\t\t\tc.error = error\n\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t`\n\n\t\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\t\tconst name = `er${i}`\n\t\t\t\tconst endUnit = report('error.unit', {\n\t\t\t\t\tname: hooks.error[i].name\n\t\t\t\t})\n\n\t\t\t\tfnLiteral += `\\nlet ${name} = handleErrors[${i}](c)\\n`\n\n\t\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\t\tfnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, set)\\n`\n\t\t\t\tfnLiteral += `if (${name}) {`\n\t\t\t\tfnLiteral += `return ${name} }\\n`\n\t\t\t}\n\t\t}\n\n\t\tendError()\n\n\t\tfnLiteral += `return handleError(c, error)\\n\\n`\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += '}'\n\n\t\tif (handleResponse || hasTrace) {\n\t\t\tfnLiteral += ` finally { `\n\n\t\t\tconst endResponse = report('response', {\n\t\t\t\tunit: hooks.onResponse.length\n\t\t\t})\n\n\t\t\tfnLiteral += handleResponse\n\n\t\t\tendResponse()\n\n\t\t\tfnLiteral += `}`\n\t\t}\n\t}\n\n\tfnLiteral = `const { \n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse,\n\t\t\tcookie\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function(c) {\n\t\t${schema && definitions ? 'c.schema = schema; c.defs = definitions;' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks,\n\t\tvalidator,\n\t\thandleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tgetReporter,\n\t\trequestId,\n\t\tparseCookie,\n\t\tsignCookie\n\t})\n}\n\nexport const composeGeneralHandler = (app: Elysia<any, any, any, any, any>) => {\n\tlet decoratorsLiteral = ''\n\tlet fnLiteral = ''\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.decorators))\n\t\tdecoratorsLiteral += `,${key}: app.decorators.${key}`\n\n\t// @ts-ignore\n\tconst { router, staticRouter } = app\n\n\tconst hasTrace = app.event.trace.length > 0\n\n\tconst findDynamicRoute = `\n\tconst route = find(request.method, path) ${\n\t\trouter.root.ALL ? '?? find(\"ALL\", path)' : ''\n\t}\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `app.handleError(ctx, notFound)`\n\t\t\t\t: `new Response(error404, {\n\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,\n\t\t\t\t\theaders: ctx.set.headers\n\t\t\t\t})`\n\t\t}\n\n\tctx.params = route.params\n\n\treturn route.store(ctx)`\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(staticRouter.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: break map`\n\t\t}}\\n\\n`\n\n\tconst maybeAsync = app.event.request.some(isAsync)\n\n\tfnLiteral += `const {\n\t\tapp,\n\t\tapp: { store, router, staticRouter, wsRouter },\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trequestId,\n\t\tgetReporter\n\t} = data\n\n\tconst notFound = new NotFoundError()\n\n\t${app.event.request.length ? `const onRequest = app.event.request` : ''}\n\n\t${staticRouter.variables}\n\n\tconst find = router.find.bind(router)\n\tconst findWs = wsRouter.find.bind(wsRouter)\n\tconst handleError = app.handleError.bind(this)\n\n\t${app.event.error.length ? '' : `const error404 = notFound.message.toString()`}\n\n\treturn ${maybeAsync ? 'async' : ''} function map(request) {\n\t`\n\n\tconst traceLiteral = app.event.trace.map((x) => x.toString())\n\tconst report = createReport({\n\t\thasTrace,\n\t\thasTraceSet: app.event.trace.some((fn) => {\n\t\t\tconst literal = fn.toString()\n\n\t\t\treturn isFnUse('set', literal) || isContextPassToFunction(literal)\n\t\t}),\n\t\tcondition: {\n\t\t\trequest: traceLiteral.some(\n\t\t\t\t(x) => isFnUse('request', x) || isContextPassToFunction(x)\n\t\t\t)\n\t\t},\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tset: {\n\t\t\t\t\tcookie: {},\n\t\t\t\t\theaders: {},\n\t\t\t\t\tstatus: 200\n\t\t\t\t}\n\t\t\t\t${hasTrace ? ',$$requestId: +id' : ''}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\t\t`\n\n\t\tconst endReport = report('request', {\n\t\t\tattribute: 'ctx',\n\t\t\tunit: app.event.request.length\n\t\t})\n\n\t\tfnLiteral += `try {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst fn = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(fn.toString())\n\t\t\tconst maybeAsync = isAsync(fn)\n\n\t\t\tconst endUnit = report('request.unit', {\n\t\t\t\tname: app.event.request[i].name\n\t\t\t})\n\n\t\t\tconst name = `re${i}`\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral += `const ${name} = mapEarlyResponse(\n\t\t\t\t\t${maybeAsync ? 'await' : ''} onRequest[${i}](ctx),\n\t\t\t\t\tctx.set\n\t\t\t\t)\\n`\n\n\t\t\t\tendUnit()\n\n\t\t\t\tfnLiteral += `if(${name}) return ${name}\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${\n\t\t\t\t\tmaybeAsync ? 'await' : ''\n\t\t\t\t} onRequest[${i}](ctx)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn app.handleError(ctx, error)\n\t\t}`\n\n\t\tendReport()\n\n\t\tfnLiteral += `\n\t\tconst url = request.url,\n\t\ts = url.indexOf('/', 11),\n\t\ti = ctx.qi = url.indexOf('?', s + 1),\n\t\tpath = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`\n\t} else {\n\t\tfnLiteral += `\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1\n\t\t\t\t? url.substring(s)\n\t\t\t\t: url.substring(s, qi)\n\n\t\t${hasTrace ? 'const id = +requestId.value++' : ''}\n\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tset: {\n\t\t\t\theaders: {},\n\t\t\t\tstatus: 200\n\t\t\t}\n\t\t\t${hasTrace ? ',$$requestId: id' : ''}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\n\t\treport('request', {\n\t\t\tunit: app.event.request.length,\n\t\t\tattribute:\n\t\t\t\ttraceLiteral.some((x) => isFnUse('context', x)) ||\n\t\t\t\ttraceLiteral.some((x) => isFnUse('store', x)) ||\n\t\t\t\ttraceLiteral.some((x) => isFnUse('set', x))\n\t\t\t\t\t? 'ctx'\n\t\t\t\t\t: ''\n\t\t})()\n\t}\n\n\t// @ts-ignore\n\tconst wsPaths = app.wsPaths\n\t// @ts-ignore\n\tconst wsRouter = app.wsRouter\n\n\tif (Object.keys(wsPaths).length || wsRouter.history.length) {\n\t\tfnLiteral += `\n\t\t\tif(request.method === 'GET') {\n\t\t\t\tswitch(path) {`\n\n\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\tfnLiteral += `\n\t\t\t\t\tcase '${path}':\n\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')\n\t\t\t\t\t\t\treturn st${index}(ctx)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tbreak`\n\t\t}\n\n\t\tfnLiteral += `\n\t\t\t\tdefault:\n\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {\n\t\t\t\t\t\tconst route = findWs('ws', path)\n\n\t\t\t\t\t\tif(route) {\n\t\t\t\t\t\t\tctx.params = route.params\n\n\t\t\t\t\t\t\treturn route.store(ctx)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t}\n\n\tfnLiteral += `\n\t\tmap: switch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\n\t\t${findDynamicRoute}\n\t}`\n\n\t// @ts-ignore\n\tapp.handleError = composeErrorHandler(app) as any\n\n\t// console.log(fnLiteral)\n\t// console.log(app.event)\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\t// @ts-ignore\n\t\tgetReporter: () => app.reporter,\n\t\trequestId\n\t})\n}\n\nexport const composeErrorHandler = (app: Elysia<any, any, any, any, any>) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onError, onResponse: res } },\n\t\tmapResponse,\n\t\tERROR_CODE\n\t} = inject\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(context, error) {\n\t\tconst { set } = context\n\n\t\tcontext.code = error.code\n\t\tcontext.error = error\n\t\t`\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${isAsync(handler) ? 'await ' : ''}onError[${i}](context)`\n\n\t\tif (hasReturn(handler.toString()))\n\t\t\tfnLiteral += `const r${i} = ${response}; if(r${i} !== undefined) {\n\t\t\t\tif(set.status === 200) set.status = error.status\n\t\t\t\treturn mapResponse(r${i}, set)\n\t\t\t}\\n`\n\t\telse fnLiteral += response + '\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\" || error.constructor.name === \"TransformDecodeError\") {\n\t\tset.status = error.status ?? 400\n\t\treturn new Response(\n\t\t\terror.message, \n\t\t\t{ headers: set.headers, status: set.status }\n\t\t)\n\t} else {\n\t\treturn new Response(error.message, { headers: set.headers, status: error.status ?? 500 })\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE\n\t})\n}\n",
  "import type { Elysia } from '.'\n\nimport { mapEarlyResponse, mapResponse } from './handler'\nimport { ElysiaErrors, NotFoundError, ValidationError } from './error'\n\nimport type { Context } from './context'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { signCookie } from './utils'\nimport { parseCookie } from './cookie'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: Handler<any, any>\n\tcontent?: string\n\thooks: LifeCycleStore\n\tvalidator?: SchemaValidator\n}\n\nexport const createDynamicHandler =\n\t(app: Elysia<any, any, any, any, any>) =>\n\tasync (request: Request): Promise<Response> => {\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tlet context: Context\n\n\t\t// @ts-ignore\n\t\tif (app.decorators) {\n\t\t\t// @ts-ignore\n\t\t\tcontext = app.decorators as any as Context\n\n\t\t\tcontext.request = request\n\t\t\tcontext.set = set\n\t\t\tcontext.store = app.store\n\t\t} else {\n\t\t\tcontext = {\n\t\t\t\tset,\n\t\t\t\tstore: app.store,\n\t\t\t\trequest\n\t\t\t} as any as Context\n\t\t}\n\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tq = url.indexOf('?', s + 1),\n\t\t\tpath = q === -1 ? url.substring(s) : url.substring(s, q)\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst onRequest = app.event.request[i]\n\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\tif (response) return response\n\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find(request.method, path) ??\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\tfor (let i = 0; i < app.event.parse.length; i++) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tlet temp = app.event.parse[i](context, contentType)\n\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.body = body\n\t\t\t// @ts-ignore\n\t\t\tcontext.params = handler?.params || undefined\n\t\t\tcontext.query = q === -1 ? {} : parseQuery(url.substring(q + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\t// @ts-ignore\n\t\t\tconst cookieMeta = validator?.cookie?.schema as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tcontext.cookie = await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcontext.headers.cookie,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecret:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined\n\t\t\t)\n\n\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\tconst operation = hooks.transform[i](context)\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (hooks.transform[i].$elysia === 'derive') {\n\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (validator.headers) {\n\t\t\t\t\tconst _header: Record<string, string> = {}\n\t\t\t\t\tfor (const key in request.headers)\n\t\t\t\t\t\t_header[key] = request.headers.get(key)!\n\n\t\t\t\t\tif (validator.headers.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.params?.Check(context.params) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.query?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.cookie) {\n\t\t\t\t\tconst cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie?.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.body?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body, body)\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\tlet response = hooks.beforeHandle[i](context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\tif (result) return result\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet response = handle(context)\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\tconst responseValidator = validator?.response?.[response.status]\n\n\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'response',\n\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t;(\n\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t}\n\t\t\t\t).response = response\n\n\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\tconst result = mapEarlyResponse(newResponse, context.set)\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\tvalidator?.response?.[response.status]\n\n\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in cookieMeta.properties)) continue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mapResponse(response, context.set)\n\t\t} catch (error) {\n\t\t\tif ((error as ElysiaErrors).status)\n\t\t\t\tset.status = (error as ElysiaErrors).status\n\n\t\t\t// @ts-ignore\n\t\t\treturn app.handleError(context, error)\n\t\t} finally {\n\t\t\t// @ts-ignore\n\t\t\tfor (const onResponse of app.event.onResponse)\n\t\t\t\tawait onResponse(context)\n\t\t}\n\t}\n\nexport const createDynamicErrorHandler =\n\t(app: Elysia<any, any, any, any, any, any>) =>\n\tasync (context: Context, error: ElysiaErrors) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\t// @ts-ignore\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tlet response = app.event.error[i](errorContext as any)\n\t\t\tif (response instanceof Promise) response = await response\n\t\t\tif (response !== undefined && response !== null)\n\t\t\t\treturn mapResponse(response, context.set)\n\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n",
  "import type { Elysia } from '.'\n\nimport { mapEarlyResponse, mapResponse } from './handler'\nimport { ElysiaErrors, NotFoundError, ValidationError } from './error'\n\nimport type { Context } from './context'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { signCookie } from './utils'\nimport { parseCookie } from './cookie'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: Handler<any, any>\n\tcontent?: string\n\thooks: LifeCycleStore\n\tvalidator?: SchemaValidator\n}\n\nexport const createDynamicHandler =\n\t(app: Elysia<any, any, any, any, any>) =>\n\tasync (request: Request): Promise<Response> => {\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tlet context: Context\n\n\t\t// @ts-ignore\n\t\tif (app.decorators) {\n\t\t\t// @ts-ignore\n\t\t\tcontext = app.decorators as any as Context\n\n\t\t\tcontext.request = request\n\t\t\tcontext.set = set\n\t\t\tcontext.store = app.store\n\t\t} else {\n\t\t\tcontext = {\n\t\t\t\tset,\n\t\t\t\tstore: app.store,\n\t\t\t\trequest\n\t\t\t} as any as Context\n\t\t}\n\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tq = url.indexOf('?', s + 1),\n\t\t\tpath = q === -1 ? url.substring(s) : url.substring(s, q)\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst onRequest = app.event.request[i]\n\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\tif (response) return response\n\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find(request.method, path) ??\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\tfor (let i = 0; i < app.event.parse.length; i++) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tlet temp = app.event.parse[i](context, contentType)\n\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.body = body\n\t\t\t// @ts-ignore\n\t\t\tcontext.params = handler?.params || undefined\n\t\t\tcontext.query = q === -1 ? {} : parseQuery(url.substring(q + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\t// @ts-ignore\n\t\t\tconst cookieMeta = validator?.cookie?.schema as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tcontext.cookie = await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcontext.headers.cookie,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecret:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined\n\t\t\t)\n\n\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\tconst operation = hooks.transform[i](context)\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (hooks.transform[i].$elysia === 'derive') {\n\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (validator.headers) {\n\t\t\t\t\tconst _header: Record<string, string> = {}\n\t\t\t\t\tfor (const key in request.headers)\n\t\t\t\t\t\t_header[key] = request.headers.get(key)!\n\n\t\t\t\t\tif (validator.headers.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.params?.Check(context.params) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.query?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.cookie) {\n\t\t\t\t\tconst cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie?.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.body?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body, body)\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\tlet response = hooks.beforeHandle[i](context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\tif (result) return result\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet response = handle(context)\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\tconst responseValidator = validator?.response?.[response.status]\n\n\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'response',\n\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t;(\n\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t}\n\t\t\t\t).response = response\n\n\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\tconst result = mapEarlyResponse(newResponse, context.set)\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\tvalidator?.response?.[response.status]\n\n\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in cookieMeta.properties)) continue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mapResponse(response, context.set)\n\t\t} catch (error) {\n\t\t\tif ((error as ElysiaErrors).status)\n\t\t\t\tset.status = (error as ElysiaErrors).status\n\n\t\t\t// @ts-ignore\n\t\t\treturn app.handleError(context, error)\n\t\t} finally {\n\t\t\t// @ts-ignore\n\t\t\tfor (const onResponse of app.event.onResponse)\n\t\t\t\tawait onResponse(context)\n\t\t}\n\t}\n\nexport const createDynamicErrorHandler =\n\t(app: Elysia<any, any, any, any, any, any>) =>\n\tasync (context: Context, error: ElysiaErrors) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\t// @ts-ignore\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tlet response = app.event.error[i](errorContext as any)\n\t\t\tif (response instanceof Promise) response = await response\n\t\t\tif (response !== undefined && response !== null)\n\t\t\t\treturn mapResponse(response, context.set)\n\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n",
  "import { TypeSystem } from '@sinclair/typebox/system'\nimport {\n\tType,\n\ttype SchemaOptions,\n\ttype NumericOptions,\n\ttype TNull,\n\ttype TUnion,\n\ttype TSchema,\n\ttype TUndefined,\n\tTProperties,\n\tObjectOptions,\n\tTObject,\n\tTNumber,\n\tFormatRegistry\n} from '@sinclair/typebox'\nimport { type TypeCheck } from '@sinclair/typebox/compiler'\nimport { CookieOptions } from './cookie'\nimport { Value } from '@sinclair/typebox/value'\nimport { ValidationError } from './error'\n\ntry {\n\tTypeSystem.Format('email', (value) =>\n\t\t/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\n\t\t\tvalue\n\t\t)\n\t)\n\n\tTypeSystem.Format('uuid', (value) =>\n\t\t/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n\t\t\tvalue\n\t\t)\n\t)\n\n\tTypeSystem.Format(\n\t\t'date',\n\t\t(value) => !Number.isNaN(new Date(value).getTime())\n\t)\n\n\tTypeSystem.Format(\n\t\t'date-time',\n\t\t(value) => !Number.isNaN(new Date(value).getTime())\n\t)\n} catch (error) {\n\t// Not empty\n}\n\ntype MaybeArray<T> = T | T[]\n\nexport namespace ElysiaTypeOptions {\n\texport type Numeric = NumericOptions<number>\n\n\texport type FileUnit = number | `${number}${'k' | 'm'}`\n\n\texport interface File extends SchemaOptions {\n\t\ttype?: MaybeArray<\n\t\t\t| (string & {})\n\t\t\t| 'image'\n\t\t\t| 'image/jpeg'\n\t\t\t| 'image/png'\n\t\t\t| 'image/gif'\n\t\t\t| 'image/tiff'\n\t\t\t| 'image/x-icon'\n\t\t\t| 'image/svg'\n\t\t\t| 'image/webp'\n\t\t\t| 'image/avif'\n\t\t\t| 'audio'\n\t\t\t| 'audio/mpeg'\n\t\t\t| 'audio/x-ms-wma'\n\t\t\t| 'audio/vnd.rn-realaudio'\n\t\t\t| 'audio/x-wav'\n\t\t\t| 'video'\n\t\t\t| 'video/mpeg'\n\t\t\t| 'video/mp4'\n\t\t\t| 'video/quicktime'\n\t\t\t| 'video/x-ms-wmv'\n\t\t\t| 'video/x-msvideo'\n\t\t\t| 'video/x-flv'\n\t\t\t| 'video/webm'\n\t\t\t| 'text'\n\t\t\t| 'text/css'\n\t\t\t| 'text/csv'\n\t\t\t| 'text/html'\n\t\t\t| 'text/javascript'\n\t\t\t| 'text/plain'\n\t\t\t| 'text/xml'\n\t\t\t| 'application'\n\t\t\t| 'application/ogg'\n\t\t\t| 'application/pdf'\n\t\t\t| 'application/xhtml'\n\t\t\t| 'application/html'\n\t\t\t| 'application/json'\n\t\t\t| 'application/ld+json'\n\t\t\t| 'application/xml'\n\t\t\t| 'application/zip'\n\t\t>\n\t\tminSize?: FileUnit\n\t\tmaxSize?: FileUnit\n\t}\n\n\texport interface Files extends File {\n\t\tminItems?: number\n\t\tmaxItems?: number\n\t}\n}\n\nconst parseFileUnit = (size: ElysiaTypeOptions.FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nconst validateFile = (options: ElysiaTypeOptions.File, value: any) => {\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\tif (options.extension)\n\t\tif (typeof options.extension === 'string') {\n\t\t\tif (!value.type.startsWith(options.extension)) return false\n\t\t} else {\n\t\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\t\tif (value.type.startsWith(options.extension[i])) return true\n\n\t\t\treturn false\n\t\t}\n\n\treturn true\n}\n\nconst Files = TypeSystem.Type<File[], ElysiaTypeOptions.Files>(\n\t'Files',\n\t(options, value) => {\n\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\tif (options.minItems && value.length < options.minItems) return false\n\n\t\tif (options.maxItems && value.length > options.maxItems) return false\n\n\t\tfor (let i = 0; i < value.length; i++)\n\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\treturn true\n\t}\n)\n\nFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\nFormatRegistry.Set('ObjectString', (value) => {\n\tlet start = value.charCodeAt(0)\n\n\t// If starts with ' ', '\\t', '\\n', then trim first\n\tif (start === 9 || start === 10 || start === 32)\n\t\tstart = value.trimStart().charCodeAt(0)\n\n\tif (start !== 123 && start !== 91) return false\n\n\ttry {\n\t\tJSON.parse(value)\n\n\t\treturn true\n\t} catch {\n\t\treturn false\n\t}\n})\n\nexport const ElysiaType = {\n\tNumeric: (property?: NumericOptions<number>) => {\n\t\tconst schema = Type.Number(property)\n\n\t\treturn Type.Transform(\n\t\t\tType.Union([\n\t\t\t\tType.String({\n\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\tdefault: 0\n\t\t\t\t}),\n\t\t\t\tschema\n\t\t\t])\n\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !Value.Check(schema, number))\n\t\t\t\t\tthrow new ValidationError('property', schema, number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\tObjectString: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions\n\t) =>\n\t\tType.Transform(\n\t\t\tType.Union([\n\t\t\t\tType.String({\n\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\tdefault: ''\n\t\t\t\t}),\n\t\t\t\tType.Object(properties, options)\n\t\t\t])\n\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => JSON.stringify(value)) as any as TObject<T>,\n\tFile: TypeSystem.Type<File, ElysiaTypeOptions.File>('File', validateFile),\n\tFiles: (options: ElysiaTypeOptions.Files = {}) =>\n\t\tType.Transform(Files(options))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value),\n\tNullable: <T extends TSchema>(schema: T): TUnion<[T, TNull]> =>\n\t\tType.Union([Type.Null(), schema]) as any,\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T): TUnion<[T, TUndefined]> =>\n\t\tType.Union([Type.Null(), Type.Undefined(), schema]) as any,\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions &\n\t\t\tCookieOptions & {\n\t\t\t\t/**\n\t\t\t\t * Secret key for signing cookie\n\t\t\t\t *\n\t\t\t\t * If array is passed, will use Key Rotation.\n\t\t\t\t *\n\t\t\t\t * Key rotation is when an encryption key is retired\n\t\t\t\t * and replaced by generating a new cryptographic key.\n\t\t\t\t */\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\t/**\n\t\t\t\t * Specified cookie name to be signed globally\n\t\t\t\t */\n\t\t\t\tsign?: Readonly<(keyof T | (string & {}))[]>\n\t\t\t}\n\t): TObject<T> => Type.Object(properties, options)\n} as const\n\nexport type TCookie = (typeof ElysiaType)['Cookie']\n\ndeclare module '@sinclair/typebox' {\n\tinterface TypeBuilder {\n\t\tObjectString: typeof ElysiaType.ObjectString\n\t\t// @ts-ignore\n\t\tNumeric: typeof ElysiaType.Numeric\n\t\t// @ts-ignore\n\t\tFile: typeof ElysiaType.File\n\t\t// @ts-ignore\n\t\tFiles: typeof ElysiaType.Files\n\t\tNullable: typeof ElysiaType.Nullable\n\t\tMaybeEmpty: typeof ElysiaType.MaybeEmpty\n\t\tCookie: typeof ElysiaType.Cookie\n\t}\n\n\tinterface SchemaOptions {\n\t\terror?:\n\t\t\t| string\n\t\t\t| ((\n\t\t\t\t\ttype: string,\n\t\t\t\t\tvalidator: TypeCheck<any>,\n\t\t\t\t\tvalue: unknown\n\t\t\t  ) => string | void)\n\t}\n}\n\nType.ObjectString = ElysiaType.ObjectString\n\n/**\n * A Numeric string\n *\n * Will be parse to Number\n */\nType.Numeric = ElysiaType.Numeric\n\nType.File = (arg = {}) =>\n\tElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n\nType.Files = (arg = {}) =>\n\tElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n\nType.Nullable = (schema) => ElysiaType.Nullable(schema)\nType.MaybeEmpty = ElysiaType.MaybeEmpty\n\nType.Cookie = ElysiaType.Cookie\n\nexport { Type as t }\n\nexport * from '@sinclair/typebox/system'\nexport * from '@sinclair/typebox/compiler'\n\n// type Template =\n// \t| string\n// \t| number\n// \t| bigint\n// \t| boolean\n// \t| StringConstructor\n// \t| NumberConstructor\n// \t| undefined\n\n// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>\n// \t? (\n// \t\t\tFirst extends Readonly<Template[]>\n// \t\t\t\t? First[number]\n// \t\t\t\t: First extends StringConstructor\n// \t\t\t\t? string\n// \t\t\t\t: First extends NumberConstructor\n// \t\t\t\t? `${number}`\n// \t\t\t\t: First\n// \t  ) extends infer A\n// \t\t? Rest extends []\n// \t\t\t? A extends undefined\n// \t\t\t\t? NonNullable<A> | ''\n// \t\t\t\t: A\n// \t\t\t: // @ts-ignore\n// \t\t\tA extends undefined\n// \t\t\t? `${NonNullable<A>}${Join<Rest>}` | ''\n// \t\t\t: // @ts-ignore\n// \t\t\t  `${A}${Join<Rest>}`\n// \t\t: ''\n// \t: ''\n\n// const template = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): Join<T> => {\n// \treturn a as any\n// }\n\n// const create =\n// \t<const T extends string>(t: T): ((t: T) => void) =>\n// \t(t) =>\n// \t\tt\n\n// const optional = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): T | undefined => {\n// \treturn undefined\n// }\n\n// template.optional = optional\n\n// const hi = create(\n// \ttemplate(\n// \t\t['seminar', 'millennium'],\n// \t\t':',\n// \t\t['Rio', 'Yuuka', 'Noa', 'Koyuki'],\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))\n// \t)\n// )\n\n// hi(`seminar:Noa,Koyuki,Yuuka`)\n\n// const a = TypeCompiler.Compile(Type.String())\n\n// console.log(v.Decode.toString())\n\n// const T = Type.Transform(v.schema)\n// \t.Decode((value) => new Date(value)) // required: number to Date\n// \t.Encode((value) => value.getTime()) // required: Date to number\n\n// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)\n// const encoded = Value.Encode(T, decoded)\n",
  "import { TypeSystem } from '@sinclair/typebox/system'\nimport {\n\tType,\n\ttype SchemaOptions,\n\ttype NumericOptions,\n\ttype TNull,\n\ttype TUnion,\n\ttype TSchema,\n\ttype TUndefined,\n\tTProperties,\n\tObjectOptions,\n\tTObject,\n\tTNumber,\n\tFormatRegistry\n} from '@sinclair/typebox'\nimport { type TypeCheck } from '@sinclair/typebox/compiler'\nimport { CookieOptions } from './cookie'\nimport { Value } from '@sinclair/typebox/value'\nimport { ValidationError } from './error'\n\ntry {\n\tTypeSystem.Format('email', (value) =>\n\t\t/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\n\t\t\tvalue\n\t\t)\n\t)\n\n\tTypeSystem.Format('uuid', (value) =>\n\t\t/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n\t\t\tvalue\n\t\t)\n\t)\n\n\tTypeSystem.Format(\n\t\t'date',\n\t\t(value) => !Number.isNaN(new Date(value).getTime())\n\t)\n\n\tTypeSystem.Format(\n\t\t'date-time',\n\t\t(value) => !Number.isNaN(new Date(value).getTime())\n\t)\n} catch (error) {\n\t// Not empty\n}\n\ntype MaybeArray<T> = T | T[]\n\nexport namespace ElysiaTypeOptions {\n\texport type Numeric = NumericOptions<number>\n\n\texport type FileUnit = number | `${number}${'k' | 'm'}`\n\n\texport interface File extends SchemaOptions {\n\t\ttype?: MaybeArray<\n\t\t\t| (string & {})\n\t\t\t| 'image'\n\t\t\t| 'image/jpeg'\n\t\t\t| 'image/png'\n\t\t\t| 'image/gif'\n\t\t\t| 'image/tiff'\n\t\t\t| 'image/x-icon'\n\t\t\t| 'image/svg'\n\t\t\t| 'image/webp'\n\t\t\t| 'image/avif'\n\t\t\t| 'audio'\n\t\t\t| 'audio/mpeg'\n\t\t\t| 'audio/x-ms-wma'\n\t\t\t| 'audio/vnd.rn-realaudio'\n\t\t\t| 'audio/x-wav'\n\t\t\t| 'video'\n\t\t\t| 'video/mpeg'\n\t\t\t| 'video/mp4'\n\t\t\t| 'video/quicktime'\n\t\t\t| 'video/x-ms-wmv'\n\t\t\t| 'video/x-msvideo'\n\t\t\t| 'video/x-flv'\n\t\t\t| 'video/webm'\n\t\t\t| 'text'\n\t\t\t| 'text/css'\n\t\t\t| 'text/csv'\n\t\t\t| 'text/html'\n\t\t\t| 'text/javascript'\n\t\t\t| 'text/plain'\n\t\t\t| 'text/xml'\n\t\t\t| 'application'\n\t\t\t| 'application/ogg'\n\t\t\t| 'application/pdf'\n\t\t\t| 'application/xhtml'\n\t\t\t| 'application/html'\n\t\t\t| 'application/json'\n\t\t\t| 'application/ld+json'\n\t\t\t| 'application/xml'\n\t\t\t| 'application/zip'\n\t\t>\n\t\tminSize?: FileUnit\n\t\tmaxSize?: FileUnit\n\t}\n\n\texport interface Files extends File {\n\t\tminItems?: number\n\t\tmaxItems?: number\n\t}\n}\n\nconst parseFileUnit = (size: ElysiaTypeOptions.FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nconst validateFile = (options: ElysiaTypeOptions.File, value: any) => {\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\tif (options.extension)\n\t\tif (typeof options.extension === 'string') {\n\t\t\tif (!value.type.startsWith(options.extension)) return false\n\t\t} else {\n\t\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\t\tif (value.type.startsWith(options.extension[i])) return true\n\n\t\t\treturn false\n\t\t}\n\n\treturn true\n}\n\nconst Files = TypeSystem.Type<File[], ElysiaTypeOptions.Files>(\n\t'Files',\n\t(options, value) => {\n\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\tif (options.minItems && value.length < options.minItems) return false\n\n\t\tif (options.maxItems && value.length > options.maxItems) return false\n\n\t\tfor (let i = 0; i < value.length; i++)\n\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\treturn true\n\t}\n)\n\nFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\nFormatRegistry.Set('ObjectString', (value) => {\n\tlet start = value.charCodeAt(0)\n\n\t// If starts with ' ', '\\t', '\\n', then trim first\n\tif (start === 9 || start === 10 || start === 32)\n\t\tstart = value.trimStart().charCodeAt(0)\n\n\tif (start !== 123 && start !== 91) return false\n\n\ttry {\n\t\tJSON.parse(value)\n\n\t\treturn true\n\t} catch {\n\t\treturn false\n\t}\n})\n\nexport const ElysiaType = {\n\tNumeric: (property?: NumericOptions<number>) => {\n\t\tconst schema = Type.Number(property)\n\n\t\treturn Type.Transform(\n\t\t\tType.Union([\n\t\t\t\tType.String({\n\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\tdefault: 0\n\t\t\t\t}),\n\t\t\t\tschema\n\t\t\t])\n\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !Value.Check(schema, number))\n\t\t\t\t\tthrow new ValidationError('property', schema, number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\tObjectString: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions\n\t) =>\n\t\tType.Transform(\n\t\t\tType.Union([\n\t\t\t\tType.String({\n\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\tdefault: ''\n\t\t\t\t}),\n\t\t\t\tType.Object(properties, options)\n\t\t\t])\n\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => JSON.stringify(value)) as any as TObject<T>,\n\tFile: TypeSystem.Type<File, ElysiaTypeOptions.File>('File', validateFile),\n\tFiles: (options: ElysiaTypeOptions.Files = {}) =>\n\t\tType.Transform(Files(options))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value),\n\tNullable: <T extends TSchema>(schema: T): TUnion<[T, TNull]> =>\n\t\tType.Union([Type.Null(), schema]) as any,\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T): TUnion<[T, TUndefined]> =>\n\t\tType.Union([Type.Null(), Type.Undefined(), schema]) as any,\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions &\n\t\t\tCookieOptions & {\n\t\t\t\t/**\n\t\t\t\t * Secret key for signing cookie\n\t\t\t\t *\n\t\t\t\t * If array is passed, will use Key Rotation.\n\t\t\t\t *\n\t\t\t\t * Key rotation is when an encryption key is retired\n\t\t\t\t * and replaced by generating a new cryptographic key.\n\t\t\t\t */\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\t/**\n\t\t\t\t * Specified cookie name to be signed globally\n\t\t\t\t */\n\t\t\t\tsign?: Readonly<(keyof T | (string & {}))[]>\n\t\t\t}\n\t): TObject<T> => Type.Object(properties, options)\n} as const\n\nexport type TCookie = (typeof ElysiaType)['Cookie']\n\ndeclare module '@sinclair/typebox' {\n\tinterface TypeBuilder {\n\t\tObjectString: typeof ElysiaType.ObjectString\n\t\t// @ts-ignore\n\t\tNumeric: typeof ElysiaType.Numeric\n\t\t// @ts-ignore\n\t\tFile: typeof ElysiaType.File\n\t\t// @ts-ignore\n\t\tFiles: typeof ElysiaType.Files\n\t\tNullable: typeof ElysiaType.Nullable\n\t\tMaybeEmpty: typeof ElysiaType.MaybeEmpty\n\t\tCookie: typeof ElysiaType.Cookie\n\t}\n\n\tinterface SchemaOptions {\n\t\terror?:\n\t\t\t| string\n\t\t\t| ((\n\t\t\t\t\ttype: string,\n\t\t\t\t\tvalidator: TypeCheck<any>,\n\t\t\t\t\tvalue: unknown\n\t\t\t  ) => string | void)\n\t}\n}\n\nType.ObjectString = ElysiaType.ObjectString\n\n/**\n * A Numeric string\n *\n * Will be parse to Number\n */\nType.Numeric = ElysiaType.Numeric\n\nType.File = (arg = {}) =>\n\tElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n\nType.Files = (arg = {}) =>\n\tElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n\nType.Nullable = (schema) => ElysiaType.Nullable(schema)\nType.MaybeEmpty = ElysiaType.MaybeEmpty\n\nType.Cookie = ElysiaType.Cookie\n\nexport { Type as t }\n\nexport * from '@sinclair/typebox/system'\nexport * from '@sinclair/typebox/compiler'\n\n// type Template =\n// \t| string\n// \t| number\n// \t| bigint\n// \t| boolean\n// \t| StringConstructor\n// \t| NumberConstructor\n// \t| undefined\n\n// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>\n// \t? (\n// \t\t\tFirst extends Readonly<Template[]>\n// \t\t\t\t? First[number]\n// \t\t\t\t: First extends StringConstructor\n// \t\t\t\t? string\n// \t\t\t\t: First extends NumberConstructor\n// \t\t\t\t? `${number}`\n// \t\t\t\t: First\n// \t  ) extends infer A\n// \t\t? Rest extends []\n// \t\t\t? A extends undefined\n// \t\t\t\t? NonNullable<A> | ''\n// \t\t\t\t: A\n// \t\t\t: // @ts-ignore\n// \t\t\tA extends undefined\n// \t\t\t? `${NonNullable<A>}${Join<Rest>}` | ''\n// \t\t\t: // @ts-ignore\n// \t\t\t  `${A}${Join<Rest>}`\n// \t\t: ''\n// \t: ''\n\n// const template = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): Join<T> => {\n// \treturn a as any\n// }\n\n// const create =\n// \t<const T extends string>(t: T): ((t: T) => void) =>\n// \t(t) =>\n// \t\tt\n\n// const optional = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): T | undefined => {\n// \treturn undefined\n// }\n\n// template.optional = optional\n\n// const hi = create(\n// \ttemplate(\n// \t\t['seminar', 'millennium'],\n// \t\t':',\n// \t\t['Rio', 'Yuuka', 'Noa', 'Koyuki'],\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))\n// \t)\n// )\n\n// hi(`seminar:Noa,Koyuki,Yuuka`)\n\n// const a = TypeCompiler.Compile(Type.String())\n\n// console.log(v.Decode.toString())\n\n// const T = Type.Transform(v.schema)\n// \t.Decode((value) => new Date(value)) // required: number to Date\n// \t.Encode((value) => value.getTime()) // required: Date to number\n\n// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)\n// const encoded = Value.Encode(T, decoded)\n",
  "import type { Serve, Server, ServerWebSocket } from 'bun'\n\nimport { Memoirist } from 'memoirist'\nimport EventEmitter from 'eventemitter3'\nimport type { Static, TSchema } from '@sinclair/typebox'\n\nimport { createTraceListener } from './trace'\nimport type { Context } from './context'\n\nimport { ElysiaWS, websocket } from './ws'\nimport type { WS } from './ws/types'\n\nimport { isNotEmpty } from './handler'\nimport {\n\tcomposeHandler,\n\tcomposeGeneralHandler,\n\tcomposeErrorHandler\n} from './compose'\nimport {\n\tmergeHook,\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\tmergeDeep,\n\tmergeCookie,\n\tchecksum,\n\tmergeLifeCycle,\n\tfilterGlobalHook,\n\tasGlobal,\n\tgetHostname\n} from './utils'\n\nimport {\n\tcreateDynamicErrorHandler,\n\tcreateDynamicHandler,\n\ttype DynamicHandler\n} from './dynamic-handle'\n\nimport {\n\tisProduction,\n\tERROR_CODE,\n\tValidationError,\n\ttype ParseError,\n\ttype NotFoundError,\n\ttype InternalServerError\n} from './error'\n\nimport type {\n\tElysiaConfig,\n\tDecoratorBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tErrorHandler,\n\tLifeCycleStore,\n\tMaybePromise,\n\tPrettify,\n\tListenCallback,\n\tAddPrefix,\n\tAddSuffix,\n\tAddPrefixCapitalize,\n\tAddSuffixCapitalize,\n\tTraceReporter,\n\tTraceHandler,\n\tMaybeArray,\n\tGracefulHandler\n} from './types'\nimport { t } from './type-system'\n\n/**\n * ### Elysia Server\n * Main instance to create web server using Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n *\n * new Elysia()\n *     .get(\"/\", () => \"Hello\")\n *     .listen(8080)\n * ```\n */\nexport default class Elysia<\n\tBasePath extends string = '',\n\tDecorators extends DecoratorBase = {\n\t\trequest: {}\n\t\tstore: {}\n\t},\n\tDefinitions extends DefinitionBase = {\n\t\ttype: {}\n\t\terror: {}\n\t},\n\tParentSchema extends RouteSchema = {},\n\tRoutes extends RouteBase = {},\n\tScoped extends boolean = false\n> {\n\tconfig: ElysiaConfig<BasePath>\n\tprivate dependencies: Record<string, number[]> = {}\n\n\tstore: Decorators['store'] = {}\n\tprivate decorators = {} as Decorators['request']\n\tprivate definitions = {\n\t\ttype: {},\n\t\terror: {}\n\t} as {\n\t\ttype: Definitions['type']\n\t\terror: Definitions['error']\n\t}\n\n\tschema = {} as Routes\n\n\tevent: LifeCycleStore = {\n\t\tstart: [],\n\t\trequest: [],\n\t\tparse: [],\n\t\ttransform: [],\n\t\tbeforeHandle: [],\n\t\tafterHandle: [],\n\t\tonResponse: [],\n\t\ttrace: [],\n\t\terror: [],\n\t\tstop: []\n\t}\n\n\treporter: TraceReporter = new EventEmitter()\n\n\tserver: Server | null = null\n\tprivate getServer() {\n\t\treturn this.server\n\t}\n\tprivate validator: SchemaValidator | null = null\n\n\tprivate router = new Memoirist<ComposedHandler>()\n\tprivate wsRouter = new Memoirist<ComposedHandler>()\n\troutes: InternalRoute[] = []\n\n\tprivate staticRouter = {\n\t\thandlers: [] as ComposedHandler[],\n\t\tvariables: '',\n\t\tmap: {} as Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tcode: string\n\t\t\t\tall?: string\n\t\t\t}\n\t\t>,\n\t\tall: ''\n\t}\n\n\tprivate wsPaths: Record<string, number> = {}\n\tprivate dynamicRouter = new Memoirist<DynamicHandler>()\n\tprivate lazyLoadModules: Promise<Elysia<any, any>>[] = []\n\tpath: BasePath = '' as any\n\n\tconstructor(config?: Partial<ElysiaConfig<BasePath, Scoped>>) {\n\t\tthis.config = {\n\t\t\tforceErrorEncapsulation: true,\n\t\t\tprefix: '',\n\t\t\taot: true,\n\t\t\tstrictPath: false,\n\t\t\tscoped: false,\n\t\t\tcookie: {},\n\t\t\t...config,\n\t\t\tseed: config?.seed === undefined ? '' : config?.seed\n\t\t} as any\n\t}\n\n\tprivate add(\n\t\tmethod: HTTPMethod,\n\t\tpaths: string | Readonly<string[]>,\n\t\thandler: Handler<any, any, any>,\n\t\thook?: LocalHook<any, any, any, any>,\n\t\t{ allowMeta = false, skipPrefix = false } = {\n\t\t\tallowMeta: false as boolean | undefined,\n\t\t\tskipPrefix: false as boolean | undefined\n\t\t}\n\t) {\n\t\tif (typeof paths === 'string') paths = [paths]\n\n\t\tfor (let path of paths) {\n\t\t\tpath =\n\t\t\t\tpath === ''\n\t\t\t\t\t? path\n\t\t\t\t\t: path.charCodeAt(0) === 47\n\t\t\t\t\t? path\n\t\t\t\t\t: `/${path}`\n\n\t\t\tif (this.config.prefix && !skipPrefix)\n\t\t\t\tpath = this.config.prefix + path\n\n\t\t\tif (hook?.type)\n\t\t\t\tswitch (hook.type) {\n\t\t\t\t\tcase 'text':\n\t\t\t\t\t\thook.type = 'text/plain'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'json':\n\t\t\t\t\t\thook.type = 'application/json'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\t\thook.type = 'multipart/form-data'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\t\thook.type = 'application/x-www-form-urlencoded'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\t\thook.type = 'application/octet-stream'\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\tconst models = this.definitions.type as Record<string, TSchema>\n\n\t\t\tlet cookieValidator = getSchemaValidator(\n\t\t\t\thook?.cookie ?? (this.validator?.cookie as any),\n\t\t\t\t{\n\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\tmodels,\n\t\t\t\t\tadditionalProperties: true\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (isNotEmpty(this.config.cookie ?? {})) {\n\t\t\t\tif (cookieValidator) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tcookieValidator.schema = mergeCookie(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tcookieValidator.schema,\n\t\t\t\t\t\tthis.config.cookie ?? {}\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tcookieValidator = getSchemaValidator(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tt.Cookie({}, this.config.cookie),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tadditionalProperties: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst validator = {\n\t\t\t\tbody: getSchemaValidator(\n\t\t\t\t\thook?.body ?? (this.validator?.body as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\theaders: getSchemaValidator(\n\t\t\t\t\thook?.headers ?? (this.validator?.headers as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels,\n\t\t\t\t\t\tadditionalProperties: true\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\tparams: getSchemaValidator(\n\t\t\t\t\thook?.params ?? (this.validator?.params as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\tquery: getSchemaValidator(\n\t\t\t\t\thook?.query ?? (this.validator?.query as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t\tcookie: cookieValidator,\n\t\t\t\tresponse: getResponseSchemaValidator(\n\t\t\t\t\thook?.response ?? (this.validator?.response as any),\n\t\t\t\t\t{\n\t\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t} as any\n\n\t\t\tconst hooks = mergeHook(this.event, hook)\n\t\t\tconst loosePath = path.endsWith('/')\n\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t: path + '/'\n\n\t\t\tif (this.config.aot === false) {\n\t\t\t\tthis.dynamicRouter.add(method, path, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: hook?.type as string,\n\t\t\t\t\thandle: handler\n\t\t\t\t})\n\n\t\t\t\tif (this.config.strictPath === false) {\n\t\t\t\t\tthis.dynamicRouter.add(method, loosePath, {\n\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\thooks,\n\t\t\t\t\t\tcontent: hook?.type as string,\n\t\t\t\t\t\thandle: handler\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tthis.routes.push({\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\tcomposed: null,\n\t\t\t\t\thandler,\n\t\t\t\t\thooks: hooks as any\n\t\t\t\t})\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst mainHandler = composeHandler({\n\t\t\t\tpath,\n\t\t\t\tmethod,\n\t\t\t\thooks,\n\t\t\t\tvalidator,\n\t\t\t\thandler,\n\t\t\t\thandleError: this.handleError,\n\t\t\t\tonRequest: this.event.request,\n\t\t\t\tconfig: this.config,\n\t\t\t\tdefinitions: allowMeta ? this.definitions.type : undefined,\n\t\t\t\tschema: allowMeta ? this.schema : undefined,\n\t\t\t\tgetReporter: () => this.reporter\n\t\t\t})\n\n\t\t\tconst existingRouteIndex = this.routes.findIndex(\n\t\t\t\t(route) => route.path === path && route.method === method\n\t\t\t)\n\n\t\t\tif (existingRouteIndex !== -1) {\n\t\t\t\t// remove route previously defined\n\t\t\t\tthis.routes.splice(existingRouteIndex, 1)\n\t\t\t}\n\n\t\t\tthis.routes.push({\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tcomposed: mainHandler,\n\t\t\t\thandler,\n\t\t\t\thooks: hooks as any\n\t\t\t})\n\n\t\t\tif (method === '$INTERNALWS') {\n\t\t\t\tconst loose = this.config.strictPath\n\t\t\t\t\t? undefined\n\t\t\t\t\t: path.endsWith('/')\n\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t: path + '/'\n\n\t\t\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\t\t\tconst index = this.staticRouter.handlers.length\n\t\t\t\t\tthis.staticRouter.handlers.push(mainHandler)\n\n\t\t\t\t\tthis.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\\n`\n\n\t\t\t\t\tthis.wsPaths[path] = index\n\t\t\t\t\tif (loose) this.wsPaths[loose] = index\n\t\t\t\t} else {\n\t\t\t\t\tthis.wsRouter.add('ws', path, mainHandler)\n\t\t\t\t\tif (loose) this.wsRouter.add('ws', loose, mainHandler)\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\t\tconst index = this.staticRouter.handlers.length\n\t\t\t\tthis.staticRouter.handlers.push(mainHandler)\n\n\t\t\t\tthis.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\\n`\n\n\t\t\t\tif (!this.staticRouter.map[path])\n\t\t\t\t\tthis.staticRouter.map[path] = {\n\t\t\t\t\t\tcode: ''\n\t\t\t\t\t}\n\n\t\t\t\tif (method === 'ALL')\n\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\tpath\n\t\t\t\t\t].all = `default: return st${index}(ctx)\\n`\n\t\t\t\telse\n\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\tpath\n\t\t\t\t\t].code = `case '${method}': return st${index}(ctx)\\n${this.staticRouter.map[path].code}`\n\n\t\t\t\tif (!this.config.strictPath) {\n\t\t\t\t\tif (!this.staticRouter.map[loosePath])\n\t\t\t\t\t\tthis.staticRouter.map[loosePath] = {\n\t\t\t\t\t\t\tcode: ''\n\t\t\t\t\t\t}\n\n\t\t\t\t\tif (method === 'ALL')\n\t\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\t\tloosePath\n\t\t\t\t\t\t].all = `default: return st${index}(ctx)\\n`\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\t\tloosePath\n\t\t\t\t\t\t].code = `case '${method}': return st${index}(ctx)\\n${this.staticRouter.map[loosePath].code}`\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.router.add(method, path, mainHandler)\n\t\t\t\tif (!this.config.strictPath)\n\t\t\t\t\tthis.router.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath.endsWith('/')\n\t\t\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t\t\t: path + '/',\n\t\t\t\t\t\tmainHandler\n\t\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * ### start | Life cycle event\n\t * Called after server is ready for serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStart(({ url, port }) => {\n\t *         console.log(\"Running at ${url}:${port}\")\n\t *     })\n\t *     .listen(8080)\n\t * ```\n\t */\n\tonStart(handler: MaybeArray<GracefulHandler<this, Decorators>>) {\n\t\tthis.on('start', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### request | Life cycle event\n\t * Called on every new request is accepted\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onRequest(({ method, url }) => {\n\t *         saveToAnalytic({ method, url })\n\t *     })\n\t * ```\n\t */\n\tonRequest<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tPreHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('request', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse(parser: MaybeArray<BodyHandler<ParentSchema, Decorators>>) {\n\t\tthis.on('parse', parser)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tVoidHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('transform', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Intercept request **before(()) main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('beforeHandle', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('afterHandle', handler as AfterHandler<any, any>)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### response | Life cycle event\n\t * Called when handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\n\tonResponse<Schema extends RouteSchema = {}>(\n\t\thandler: MaybeArray<\n\t\t\tVoidHandler<MergeSchema<Schema, ParentSchema>, Decorators>\n\t\t>\n\t) {\n\t\tthis.on('response', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<Route extends RouteSchema = {}>(\n\t\thandler: TraceHandler<Route, Decorators>\n\t) {\n\t\tthis.reporter.on(\n\t\t\t'event',\n\t\t\tcreateTraceListener(\n\t\t\t\t() => this.reporter,\n\t\t\t\tthis.event.trace.length,\n\t\t\t\thandler\n\t\t\t)\n\t\t)\n\n\t\tthis.on('trace', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * @deprecated this method will be renamed to `error` on 0.8, consider using `.error` instead\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\taddError<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[K in keyof Errors]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * @deprecated this method will be renamed to `error` on 0.8, consider using `.error` instead\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error({\n\t *         CUSTOM_ERROR: CustomError\n\t *     })\n\t * ```\n\t */\n\taddError<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\taddError(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >\n\t\t\t| Function,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): Elysia<any, any, any, any, any, any> {\n\t\treturn this.error(name as any, error as any)\n\t}\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[K in keyof Errors]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error({\n\t *         CUSTOM_ERROR: CustomError\n\t *     })\n\t * ```\n\t */\n\terror<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<const NewErrors extends Record<string, Error>>(\n\t\tmapper: (decorators: Definitions['error']) => NewErrors\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: {\n\t\t\t\t[K in keyof NewErrors]: NewErrors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: never\n\t\t\t}\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\terror(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >\n\t\t\t| Function,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): Elysia<any, any, any, any, any, any> {\n\t\tswitch (typeof name) {\n\t\t\tcase 'string':\n\t\t\t\t// @ts-ignore\n\t\t\t\terror.prototype[ERROR_CODE] = name\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.definitions.error[name] = error\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.error = name(this.definitions.error)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tfor (const [code, error] of Object.entries(name)) {\n\t\t\t// @ts-ignore\n\t\t\terror.prototype[ERROR_CODE] = code\n\n\t\t\t// @ts-ignore\n\t\t\tthis.definitions.error[code] = error\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<Schema extends RouteSchema = {}>(\n\t\thandler: ErrorHandler<\n\t\t\tDefinitions['error'],\n\t\t\tMergeSchema<Schema, ParentSchema>,\n\t\t\tDecorators\n\t\t>\n\t) {\n\t\tthis.on('error', handler as ErrorHandler<any, any, any>)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop | Life cycle event\n\t * Called after server stop serving request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStop((app) => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonStop(handler: MaybeArray<GracefulHandler<this, Decorators>>) {\n\t\tthis.on('stop', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<Event extends keyof LifeCycleStore>(\n\t\ttype: Exclude<Event, 'onResponse'> | 'response',\n\t\thandlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>\n\t) {\n\t\tfor (let handler of Array.isArray(handlers) ? handlers : [handlers]) {\n\t\t\thandler = asGlobal(handler)\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'start':\n\t\t\t\t\tthis.event.start.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.event.request.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'response':\n\t\t\t\t\tthis.event.onResponse.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'parse':\n\t\t\t\t\tthis.event.parse.splice(\n\t\t\t\t\t\tthis.event.parse.length - 1,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\thandler as any\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'transform':\n\t\t\t\t\tthis.event.transform.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\tthis.event.beforeHandle.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterHandle':\n\t\t\t\t\tthis.event.afterHandle.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'trace':\n\t\t\t\t\tthis.event.trace.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tthis.event.error.push(handler as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'stop':\n\t\t\t\t\tthis.event.stop.push(handler as any)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\tgroup<\n\t\tconst NewElysia extends Elysia<any, any, any, any, any, any>,\n\t\tconst Prefix extends string\n\t>(\n\t\tprefix: Prefix,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\tDecorators,\n\t\t\t\tDefinitions,\n\t\t\t\tParentSchema,\n\t\t\t\t{}\n\t\t\t>\n\t\t) => NewElysia\n\t): NewElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tany\n\t>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tPluginDecorators,\n\t\t\t\tPluginDefinitions,\n\t\t\t\tPluginSchema,\n\t\t\t\tPrettify<Routes & NewElysia['schema']>\n\t\t  >\n\t\t: this\n\n\tgroup<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst NewElysia extends Elysia<any, any, any, any, any, any>,\n\t\tconst Prefix extends string,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\tprefix: Prefix,\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Prefix}`\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\tDecorators,\n\t\t\t\tDefinitions,\n\t\t\t\tSchema,\n\t\t\t\t{}\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<Routes & NewElysia['schema']>\n\t>\n\n\t/**\n\t * ### group\n\t * Encapsulate and group path with prefix\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .group('/v1', app => app\n\t *         .get('/', () => 'Hi')\n\t *         .get('/name', () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tgroup(\n\t\tprefix: string,\n\t\tschemaOrRun:\n\t\t\t| LocalHook<any, any, any, any>\n\t\t\t| ((\n\t\t\t\t\tgroup: Elysia<any, any, any, any, any, any>\n\t\t\t  ) => Elysia<any, any, any, any, any, any>),\n\t\trun?: (\n\t\t\tgroup: Elysia<any, any, any, any, any, any>\n\t\t) => Elysia<any, any, any, any, any, any>\n\t): this {\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.store = this.store\n\t\tinstance.getServer = () => this.server\n\n\t\tconst isSchema = typeof schemaOrRun === 'object'\n\n\t\tconst sandbox = (isSchema ? run! : schemaOrRun)(instance)\n\t\tthis.decorators = mergeDeep(this.decorators, instance.decorators)\n\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...this.event.request,\n\t\t\t\t...(sandbox.event.request as any)\n\t\t\t]\n\n\t\tif (sandbox.event.onResponse.length)\n\t\t\tthis.event.onResponse = [\n\t\t\t\t...this.event.onResponse,\n\t\t\t\t...(sandbox.event.onResponse as any)\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.routes).forEach(\n\t\t\t({ method, path, handler, hooks }) => {\n\t\t\t\tpath = (isSchema ? '' : this.config.prefix) + prefix + path\n\n\t\t\t\tif (isSchema) {\n\t\t\t\t\tconst hook = schemaOrRun\n\t\t\t\t\tconst localHook = hooks as LocalHook<any, any, any, any>\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hook, {\n\t\t\t\t\t\t\t...localHook,\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t? [...localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t\t\t: [localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hooks as LocalHook<any, any, any, any>, {\n\t\t\t\t\t\t\terror: sandbox.event.error\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tskipPrefix: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\thook: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\tBasePath\n\t\t>\n\t): Elysia<BasePath, Decorators, Definitions, Route, Routes, Scoped>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst NewElysia extends Elysia<any, any, any, any, any, any>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorators,\n\t\t\tDefinitions['error']\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<BasePath, Decorators, Definitions, Schema, {}, Scoped>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<Routes & NewElysia['schema']>,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### guard\n\t * Encapsulate and pass hook into all child handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .guard({\n\t *          schema: {\n\t *              body: t.Object({\n\t *                  username: t.String(),\n\t *                  password: t.String()\n\t *              })\n\t *          }\n\t *     }, app => app\n\t *         .get(\"/\", () => 'Hi')\n\t *         .get(\"/name\", () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tguard(\n\t\thook: LocalHook<any, any, any, any>,\n\t\trun?: (\n\t\t\tgroup: Elysia<any, any, any, any, any, any>\n\t\t) => Elysia<any, any, any, any, any, any>\n\t): Elysia<any, any, any, any, any, any> {\n\t\tif (!run) {\n\t\t\tthis.event = mergeLifeCycle(this.event, hook)\n\t\t\tthis.validator = {\n\t\t\t\tbody: hook.body,\n\t\t\t\theaders: hook.headers,\n\t\t\t\tparams: hook.params,\n\t\t\t\tquery: hook.query,\n\t\t\t\tresponse: hook.response\n\t\t\t}\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst instance = new Elysia<any>()\n\t\tinstance.store = this.store\n\n\t\tconst sandbox = run(instance)\n\t\tthis.decorators = mergeDeep(this.decorators, instance.decorators)\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...this.event.request,\n\t\t\t\t...sandbox.event.request\n\t\t\t]\n\n\t\tif (sandbox.event.onResponse.length)\n\t\t\tthis.event.onResponse = [\n\t\t\t\t...this.event.onResponse,\n\t\t\t\t...sandbox.event.onResponse\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.routes).forEach(\n\t\t\t({ method, path, handler, hooks: localHook }) => {\n\t\t\t\tthis.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\thandler,\n\t\t\t\t\tmergeHook(hook as LocalHook<any, any, any, any>, {\n\t\t\t\t\t\t...(localHook as LocalHook<any, any, any, any>),\n\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t? [...localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t\t: [localHook.error, ...sandbox.event.error]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t// Inline Fn\n\tuse<NewElysia extends Elysia<any, any, any, any, any, any> = this>(\n\t\tplugin: MaybePromise<(app: NewElysia) => MaybePromise<NewElysia>>\n\t): NewElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tany\n\t>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\trequest: Prettify<\n\t\t\t\t\t\tDecorators['request'] & PluginDecorators['request']\n\t\t\t\t\t>\n\t\t\t\t\tstore: Prettify<\n\t\t\t\t\t\tDecorators['store'] & PluginDecorators['store']\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: Prettify<\n\t\t\t\t\t\tDefinitions['type'] & PluginDefinitions['type']\n\t\t\t\t\t>\n\t\t\t\t\terror: Prettify<\n\t\t\t\t\t\tDefinitions['error'] & PluginDefinitions['error']\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tPrettify<MergeSchema<ParentSchema, PluginSchema>>,\n\t\t\t\tRoutes & NewElysia['schema'],\n\t\t\t\tScoped\n\t\t  >\n\t\t: this\n\n\t// Entire Instance\n\tuse<NewElysia extends Elysia<any, any, any, any, any, any>>(\n\t\tinstance: MaybePromise<NewElysia>\n\t): NewElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tany,\n\t\tinfer IsScoped\n\t>\n\t\t? IsScoped extends true\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tDecorators,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tParentSchema,\n\t\t\t\t\tBasePath extends ``\n\t\t\t\t\t\t? Routes & NewElysia['schema']\n\t\t\t\t\t\t: Routes & AddPrefix<BasePath, NewElysia['schema']>,\n\t\t\t\t\tScoped\n\t\t\t  >\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\t{\n\t\t\t\t\t\trequest: Prettify<\n\t\t\t\t\t\t\tDecorators['request'] & PluginDecorators['request']\n\t\t\t\t\t\t>\n\t\t\t\t\t\tstore: Prettify<\n\t\t\t\t\t\t\tDecorators['store'] & PluginDecorators['store']\n\t\t\t\t\t\t>\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: Prettify<\n\t\t\t\t\t\t\tDefinitions['type'] & PluginDefinitions['type']\n\t\t\t\t\t\t>\n\t\t\t\t\t\terror: Prettify<\n\t\t\t\t\t\t\tDefinitions['error'] & PluginDefinitions['error']\n\t\t\t\t\t\t>\n\t\t\t\t\t},\n\t\t\t\t\tPrettify<MergeSchema<ParentSchema, PluginSchema>>,\n\t\t\t\t\tBasePath extends ``\n\t\t\t\t\t\t? Routes & NewElysia['schema']\n\t\t\t\t\t\t: Routes & AddPrefix<BasePath, NewElysia['schema']>,\n\t\t\t\t\tScoped\n\t\t\t  >\n\t\t: this\n\n\t// Import Fn\n\tuse<NewElysia extends Elysia<any, any, any, any, any, any>>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (\n\t\t\t\telysia: Elysia<any, any, any, any, any, any>\n\t\t\t) => MaybePromise<NewElysia>\n\t\t}>\n\t): NewElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tany\n\t>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\trequest: Decorators['request'] & PluginDecorators['request']\n\t\t\t\t\tstore: Decorators['store'] & PluginDecorators['store']\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: Definitions['type'] & PluginDefinitions['type']\n\t\t\t\t\terror: Definitions['error'] & PluginDefinitions['error']\n\t\t\t\t},\n\t\t\t\tMergeSchema<ParentSchema, PluginSchema>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['schema']\n\t\t\t\t\t: Routes & AddPrefix<BasePath, NewElysia['schema']>,\n\t\t\t\tScoped\n\t\t  >\n\t\t: this\n\n\t// Import entire instance\n\tuse<LazyLoadElysia extends Elysia<any, any, any, any, any, any>>(\n\t\tplugin: Promise<{\n\t\t\tdefault: LazyLoadElysia\n\t\t}>\n\t): LazyLoadElysia extends Elysia<\n\t\tany,\n\t\tinfer PluginDecorators,\n\t\tinfer PluginDefinitions,\n\t\tinfer PluginSchema,\n\t\tany\n\t>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\trequest: PluginDecorators['request'] & Decorators['request']\n\t\t\t\t\tstore: PluginDecorators['store'] & Decorators['store']\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: PluginDefinitions['type'] & Definitions['type']\n\n\t\t\t\t\terror: PluginDefinitions['error'] & Definitions['error']\n\t\t\t\t},\n\t\t\t\tMergeSchema<PluginSchema, ParentSchema>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & LazyLoadElysia['schema']\n\t\t\t\t\t: Routes & AddPrefix<BasePath, LazyLoadElysia['schema']>\n\t\t  >\n\t\t: this\n\n\t/**\n\t * ### use\n\t * Merge separate logic of Elysia with current\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const plugin = (app: Elysia) => app\n\t *     .get('/plugin', () => 'hi')\n\t *\n\t * new Elysia()\n\t *     .use(plugin)\n\t * ```\n\t */\n\tuse(\n\t\tplugin:\n\t\t\t| Elysia<any, any, any, any, any, any>\n\t\t\t| MaybePromise<\n\t\t\t\t\t(\n\t\t\t\t\t\tapp: Elysia<any, any, any, any, any, any>\n\t\t\t\t\t) => MaybePromise<Elysia<any, any, any, any, any, any>>\n\t\t\t  >\n\t\t\t| Promise<{\n\t\t\t\t\tdefault: Elysia<any, any, any, any, any, any>\n\t\t\t  }>\n\t\t\t| Promise<{\n\t\t\t\t\tdefault: (\n\t\t\t\t\t\telysia: Elysia<any, any, any, any, any, any>\n\t\t\t\t\t) => MaybePromise<Elysia<any, any, any, any, any, any>>\n\t\t\t  }>\n\t): Elysia<any, any, any, any, any, any> {\n\t\tif (plugin instanceof Promise) {\n\t\t\tthis.lazyLoadModules.push(\n\t\t\t\tplugin\n\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\tif (typeof plugin === 'function') {\n\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t) as unknown as Elysia\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t})\n\t\t\t\t\t.then((x) => x.compile())\n\t\t\t)\n\n\t\t\treturn this as unknown as any\n\t\t} else return this._use(plugin)\n\n\t\treturn this\n\t}\n\n\tprivate _use(\n\t\tplugin:\n\t\t\t| Elysia<any, any, any, any, any, any>\n\t\t\t| ((\n\t\t\t\t\tapp: Elysia<any, any, any, any, any, any>\n\t\t\t  ) => MaybePromise<Elysia<any, any, any, any, any, any>>)\n\t) {\n\t\tif (typeof plugin === 'function') {\n\t\t\tconst instance = plugin(this as unknown as any) as unknown as any\n\t\t\tif (instance instanceof Promise) {\n\t\t\t\tthis.lazyLoadModules.push(\n\t\t\t\t\tinstance\n\t\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\t\tif (plugin instanceof Elysia) {\n\t\t\t\t\t\t\t\tthis.compile()\n\n\t\t\t\t\t\t\t\t// Recompile async plugin routes\n\t\t\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\thooks\n\t\t\t\t\t\t\t\t} of Object.values(plugin.routes)) {\n\t\t\t\t\t\t\t\t\tthis.add(\n\t\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\t\tmergeHook(\n\t\t\t\t\t\t\t\t\t\t\thooks as LocalHook<\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn plugin\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (typeof plugin === 'function')\n\t\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((x) => x.compile())\n\t\t\t\t)\n\t\t\t\treturn this as unknown as any\n\t\t\t}\n\n\t\t\treturn instance\n\t\t}\n\n\t\tconst { name, seed } = plugin.config\n\n\t\tplugin.getServer = () => this.getServer()\n\n\t\tconst isScoped = plugin.config.scoped\n\t\tif (isScoped) {\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t(checksum) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn this\n\n\t\t\t\tthis.dependencies[name].push(current)\n\t\t\t}\n\n\t\t\tplugin.model(this.definitions.type as any)\n\t\t\tplugin.error(this.definitions.error as any)\n\n\t\t\tplugin.onRequest((context) => {\n\t\t\t\tObject.assign(context, this.decorators)\n\t\t\t\tObject.assign(context.store, this.store)\n\t\t\t})\n\n\t\t\tplugin.event.trace = [...this.event.trace, ...plugin.event.trace]\n\n\t\t\tif (plugin.config.aot) plugin.compile()\n\n\t\t\tconst instance = this.mount(plugin.fetch)\n\t\t\tthis.routes = this.routes.concat(instance.routes)\n\n\t\t\treturn this\n\t\t} else {\n\t\t\tplugin.reporter = this.reporter\n\t\t\tfor (const trace of plugin.event.trace) this.trace(trace)\n\t\t}\n\n\t\tthis.decorate(plugin.decorators)\n\t\tthis.state(plugin.store)\n\t\tthis.model(plugin.definitions.type)\n\t\tthis.error(plugin.definitions.error)\n\n\t\tfor (const { method, path, handler, hooks } of Object.values(\n\t\t\tplugin.routes\n\t\t)) {\n\t\t\tthis.add(\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\thandler,\n\t\t\t\tmergeHook(hooks as LocalHook<any, any, any, any, any, any>, {\n\t\t\t\t\terror: plugin.event.error\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\tif (!isScoped)\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t(checksum) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn this\n\n\t\t\t\tthis.dependencies[name].push(current)\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event),\n\t\t\t\t\tcurrent\n\t\t\t\t)\n\t\t\t} else\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event)\n\t\t\t\t)\n\n\t\treturn this\n\t}\n\n\tmount(handle: (request: Request) => MaybePromise<Response>): this\n\tmount(\n\t\tpath: string,\n\t\thandle: (request: Request) => MaybePromise<Response>\n\t): this\n\n\tmount(\n\t\tpath: string | ((request: Request) => MaybePromise<Response>),\n\t\thandle?: (request: Request) => MaybePromise<Response>\n\t) {\n\t\tif (typeof path === 'function' || path.length === 0 || path === '/') {\n\t\t\tconst run = typeof path === 'function' ? path : handle!\n\n\t\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\t\trun(\n\t\t\t\t\tnew Request(getHostname(request.url) + path || '/', request)\n\t\t\t\t)\n\n\t\t\tthis.all('/', handler as any, {\n\t\t\t\ttype: 'none'\n\t\t\t})\n\t\t\tthis.all('/*', handler as any, {\n\t\t\t\ttype: 'none'\n\t\t\t})\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst length = path.length\n\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\thandle!(\n\t\t\t\tnew Request(\n\t\t\t\t\tgetHostname(request.url) + path.slice(length) || '/',\n\t\t\t\t\trequest\n\t\t\t\t)\n\t\t\t)\n\n\t\tthis.all(path, handler as any, {\n\t\t\ttype: 'none'\n\t\t})\n\t\tthis.all(path + (path.endsWith('/') ? '*' : '/*'), handler as any, {\n\t\t\ttype: 'none'\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### get\n\t * Register handler for path with method [GET]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .get('/', () => 'hi')\n\t *     .get('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tget<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tget: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('GET', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### post\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .post('/', () => 'hi')\n\t *     .post('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tpost<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tpost: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('POST', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### put\n\t * Register handler for path with method [PUT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .put('/', () => 'hi')\n\t *     .put('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tput<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tput: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('PUT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### patch\n\t * Register handler for path with method [PATCH]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .patch('/', () => 'hi')\n\t *     .patch('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tpatch<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tpatch: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('PATCH', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### delete\n\t * Register handler for path with method [DELETE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .delete('/', () => 'hi')\n\t *     .delete('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tdelete<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tdelete: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('DELETE', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### options\n\t * Register handler for path with method [OPTIONS]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .options('/', () => 'hi')\n\t *     .options('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\toptions<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('OPTIONS', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### all\n\t * Register handler for path with any method\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .all('/', () => 'hi')\n\t * ```\n\t */\n\tall<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\t[method in string]: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('ALL', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### head\n\t * Register handler for path with method [HEAD]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .head('/', () => 'hi')\n\t *     .head('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\thead<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\thead: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('HEAD', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### connect\n\t * Register handler for path with method [CONNECT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .connect('/', () => 'hi')\n\t *     .connect('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tconnect<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>\n\t>(\n\t\tpath: Path,\n\t\thandler: Function,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tconnect: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: unknown extends Route['response']\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add('CONNECT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### ws\n\t * Register handler for path with method [ws]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .ws('/', {\n\t *         message(ws, message) {\n\t *             ws.send(message)\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tws<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\toptions: WS.LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\tsubscribe: {\n\t\t\t\t\t\tbody: Route['body']\n\t\t\t\t\t\tparams: Route['params']\n\t\t\t\t\t\tquery: Route['query']\n\t\t\t\t\t\theaders: Route['headers']\n\t\t\t\t\t\tresponse: Route['response']\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tconst transform = options.transformMessage\n\t\t\t? Array.isArray(options.transformMessage)\n\t\t\t\t? options.transformMessage\n\t\t\t\t: [options.transformMessage]\n\t\t\t: undefined\n\n\t\tlet server: Server | null = null\n\n\t\tconst validateMessage = getSchemaValidator(options?.body, {\n\t\t\tmodels: this.definitions.type as Record<string, TSchema>\n\t\t})\n\n\t\tconst validateResponse = getSchemaValidator(options?.response as any, {\n\t\t\tmodels: this.definitions.type as Record<string, TSchema>\n\t\t})\n\n\t\tconst parseMessage = (message: any) => {\n\t\t\tif (typeof message === 'string') {\n\t\t\t\tconst start = message?.charCodeAt(0)\n\n\t\t\t\tif (start === 47 || start === 123)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmessage = JSON.parse(message)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Not empty\n\t\t\t\t\t}\n\t\t\t\telse if (!Number.isNaN(+message)) message = +message\n\t\t\t}\n\n\t\t\tif (transform?.length)\n\t\t\t\tfor (let i = 0; i < transform.length; i++) {\n\t\t\t\t\tconst temp = transform[i](message)\n\n\t\t\t\t\tif (temp !== undefined) message = temp\n\t\t\t\t}\n\n\t\t\treturn message\n\t\t}\n\n\t\tthis.route(\n\t\t\t'$INTERNALWS',\n\t\t\tpath as any,\n\t\t\t// @ts-ignore\n\t\t\t(context) => {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { set, path, qi, headers, query, params } = context\n\n\t\t\t\tif (server === null) server = this.getServer()\n\n\t\t\t\tif (\n\t\t\t\t\tserver?.upgrade<any>(context.request, {\n\t\t\t\t\t\theaders:\n\t\t\t\t\t\t\ttypeof options.upgrade === 'function'\n\t\t\t\t\t\t\t\t? options.upgrade(context as any as Context)\n\t\t\t\t\t\t\t\t: options.upgrade,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tvalidator: validateResponse,\n\t\t\t\t\t\t\topen(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\toptions.open?.(new ElysiaWS(ws, context as any))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: (ws: ServerWebSocket<any>, msg: any) => {\n\t\t\t\t\t\t\t\tconst message = parseMessage(msg)\n\n\t\t\t\t\t\t\t\tif (validateMessage?.Check(message) === false)\n\t\t\t\t\t\t\t\t\treturn void ws.send(\n\t\t\t\t\t\t\t\t\t\tnew ValidationError(\n\t\t\t\t\t\t\t\t\t\t\t'message',\n\t\t\t\t\t\t\t\t\t\t\tvalidateMessage,\n\t\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t).message as string\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\toptions.message?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdrain(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\toptions.drain?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclose(\n\t\t\t\t\t\t\t\tws: ServerWebSocket<any>,\n\t\t\t\t\t\t\t\tcode: number,\n\t\t\t\t\t\t\t\treason: string\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toptions.close?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\treason\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t\treturn\n\n\t\t\t\tset.status = 400\n\n\t\t\t\treturn 'Expected a websocket connection'\n\t\t\t},\n\t\t\t{\n\t\t\t\tbeforeHandle: options.beforeHandle,\n\t\t\t\ttransform: options.transform,\n\t\t\t\theaders: options.headers,\n\t\t\t\tparams: options.params,\n\t\t\t\tquery: options.query\n\t\t\t} as any\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### route\n\t * Register handler for path with custom method\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .route('CUSTOM', '/', () => 'hi')\n\t *     .route('CUSTOM', '/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\n\troute<\n\t\tconst Method extends HTTPMethod,\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst Function extends Handler<Route, Decorators, `${BasePath}${Path}`>,\n\t\tconst Route extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tParentSchema\n\t\t>\n\t>(\n\t\tmethod: Method,\n\t\tpath: Path,\n\t\thandler: Function,\n\t\t{\n\t\t\tconfig,\n\t\t\t...hook\n\t\t}: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tRoute,\n\t\t\tDecorators,\n\t\t\tDefinitions['error'],\n\t\t\t`${BasePath}${Path}`\n\t\t> & {\n\t\t\tconfig: {\n\t\t\t\tallowMeta?: boolean\n\t\t\t}\n\t\t} = {\n\t\t\tconfig: {\n\t\t\t\tallowMeta: false\n\t\t\t}\n\t\t} as any\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tPrettify<\n\t\t\tRoutes & {\n\t\t\t\t[path in `${BasePath}${Path}`]: {\n\t\t\t\t\t[method in Lowercase<Method>]: Route extends {\n\t\t\t\t\t\tbody: infer Body\n\t\t\t\t\t\tparams: infer Params\n\t\t\t\t\t\tquery: infer Query\n\t\t\t\t\t\theaders: infer Headers\n\t\t\t\t\t\tresponse: infer Response\n\t\t\t\t\t}\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tbody: Body\n\t\t\t\t\t\t\t\tparams: Params\n\t\t\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\t\t\theaders: Headers\n\t\t\t\t\t\t\t\tresponse: unknown extends Response\n\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t200: ReturnType<Function>\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t: Route['response'] extends { 200: any }\n\t\t\t\t\t\t\t\t\t? Route['response']\n\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t200: Route['response']\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: never\n\t\t\t\t}\n\t\t\t}\n\t\t>,\n\t\tScoped\n\t> {\n\t\tthis.add(method, path, handler as any, hook, config)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Name extends string | number | symbol, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: Prettify<\n\t\t\t\tDecorators['store'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Store extends Record<string, unknown>>(\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: Prettify<Decorators['store'] & Store>\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tstate<const NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Decorators['store']) => NewStore\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: NewStore\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate(\n\t\tname: string | number | symbol | Record<string, unknown> | Function,\n\t\tvalue?: unknown\n\t) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tthis.store = mergeDeep(this.store, name)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tthis.store = name(this.store)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tif (!(name in this.store)) {\n\t\t\t// eslint-disable-next-line no-extra-semi\n\t\t\t;(this.store as Record<string | number | symbol, unknown>)[name] =\n\t\t\t\tvalue\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const Name extends string, const Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Prettify<\n\t\t\t\tDecorators['request'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tstore: Decorators['store']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Prettify<Decorators['request'] & NewDecorators>\n\t\t\tstore: Decorators['store']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tmapper: (decorators: Decorators['request']) => NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: NewDecorators\n\t\t\tstore: Decorators['store']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate(\n\t\tname: string | Record<string, unknown> | Function,\n\t\tvalue?: unknown\n\t) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tthis.decorators = mergeDeep(this.decorators, name)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tthis.decorators = name(this.decorators)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (!(name in this.decorators)) this.decorators[name] = value\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<Derivative extends Object>(\n\t\ttransform: (\n\t\t\tcontext: Prettify<Context<ParentSchema, Decorators>>\n\t\t) => MaybePromise<Derivative> extends { store: any }\n\t\t\t? never\n\t\t\t: Derivative\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Prettify<Decorators['request'] & Awaited<Derivative>>\n\t\t\tstore: Decorators['store']\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t> {\n\t\t// @ts-ignore\n\t\ttransform.$elysia = 'derive'\n\n\t\treturn this.onTransform(transform as any) as any\n\t}\n\n\tmodel<Name extends string, Model extends TSchema>(\n\t\tname: Name,\n\t\tmodel: Model\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Prettify<\n\t\t\t\tDefinitions['type'] & { [name in Name]: Static<Model> }\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tmodel<Recorder extends Record<string, TSchema>>(\n\t\trecord: Recorder\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: Prettify<\n\t\t\t\tDefinitions['type'] & {\n\t\t\t\t\t[key in keyof Recorder]: Static<Recorder[key]>\n\t\t\t\t}\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tmodel<const NewType extends Record<string, TSchema>>(\n\t\tmapper: (decorators: {\n\t\t\t[type in keyof Definitions['type']]: ReturnType<\n\t\t\t\ttypeof t.Unsafe<Definitions['type'][type]>\n\t\t\t>\n\t\t}) => NewType\n\t): Elysia<\n\t\tBasePath,\n\t\tDecorators,\n\t\t{\n\t\t\ttype: { [x in keyof NewType]: Static<NewType[x]> }\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t>\n\n\tmodel(name: string | Record<string, TSchema> | Function, model?: TSchema) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tObject.entries(name).forEach(([key, value]) => {\n\t\t\t\t\tif (!(key in this.definitions.type))\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tthis.definitions.type[key] = value as TSchema\n\t\t\t\t})\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.type = name(this.definitions.type)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t;(this.definitions.type as Record<string, TSchema>)[name] = model!\n\n\t\treturn this as any\n\t}\n\n\tmapDerive<const NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Decorators['request']) => MaybePromise<NewStore>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Decorators['request']\n\t\t\tstore: NewStore\n\t\t},\n\t\tDefinitions,\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t> {\n\t\t// @ts-ignore\n\t\tmapper.$elysia = 'derive'\n\n\t\treturn this.onTransform(mapper as any) as any\n\t}\n\n\taffix<\n\t\tconst Base extends 'prefix' | 'suffix',\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(\n\t\tbase: Base,\n\t\ttype: Type,\n\t\tword: Word\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Decorators['request']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Decorators['request']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Decorators['request']>\n\t\t\t\t: Decorators['request']\n\t\t\tstore: Type extends 'state' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Decorators['store']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Decorators['store']>\n\t\t\t\t\t: AddSuffix<Word, Decorators['store']>\n\t\t\t\t: Decorators['store']\n\t\t},\n\t\t{\n\t\t\ttype: Type extends 'model' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['type']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['type']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['type']>\n\t\t\t\t: Definitions['type']\n\t\t\terror: Type extends 'error' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['error']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['error']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['error']>\n\t\t\t\t: Definitions['error']\n\t\t},\n\t\tParentSchema,\n\t\tRoutes,\n\t\tScoped\n\t> {\n\t\tif (word === '') return this as any\n\n\t\tconst delimieter = ['_', '-', ' ']\n\t\tconst capitalize = (word: string) =>\n\t\t\tword[0].toUpperCase() + word.slice(1)\n\n\t\tconst joinKey =\n\t\t\tbase === 'prefix'\n\t\t\t\t? (prefix: string, word: string) =>\n\t\t\t\t\t\tdelimieter.includes(prefix.at(-1) ?? '')\n\t\t\t\t\t\t\t? prefix + word\n\t\t\t\t\t\t\t: prefix + capitalize(word)\n\t\t\t\t: delimieter.includes(word.at(-1) ?? '')\n\t\t\t\t? (suffix: string, word: string) => word + suffix\n\t\t\t\t: (suffix: string, word: string) => word + capitalize(suffix)\n\n\t\tconst remap = (type: 'decorator' | 'state' | 'model' | 'error') => {\n\t\t\tconst store: Record<string, any> = {}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'decorator':\n\t\t\t\t\tfor (const key in this.decorators)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.decorators[key]\n\n\t\t\t\t\tthis.decorators = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'state':\n\t\t\t\t\tfor (const key in this.store)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.store[key]\n\n\t\t\t\t\tthis.store = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'model':\n\t\t\t\t\tfor (const key in this.definitions.type)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.type[key]\n\n\t\t\t\t\tthis.definitions.type = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tfor (const key in this.definitions.error)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.error[key]\n\n\t\t\t\t\tthis.definitions.error = store\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst types = Array.isArray(type) ? type : [type]\n\n\t\tfor (const type of types.some((x) => x === 'all')\n\t\t\t? ['decorator', 'state', 'model', 'error']\n\t\t\t: types)\n\t\t\tremap(type as 'decorator')\n\n\t\treturn this as any\n\t}\n\n\tprefix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('prefix', type, word)\n\t}\n\n\tsuffix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('suffix', type, word)\n\t}\n\n\tcompile() {\n\t\tthis.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this)\n\n\t\tif (typeof this.server?.reload === 'function')\n\t\t\tthis.server.reload({\n\t\t\t\t...this.server,\n\t\t\t\tfetch: this.fetch\n\t\t\t})\n\n\t\treturn this\n\t}\n\n\thandle = async (request: Request) => this.fetch(request)\n\n\t/**\n\t * Handle can be either sync or async to save performance.\n\t *\n\t * Beside benchmark purpose, please use 'handle' instead.\n\t */\n\tfetch = (request: Request): MaybePromise<Response> =>\n\t\t(this.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this))(request)\n\n\tprivate handleError = async (\n\t\tcontext: Context,\n\t\terror:\n\t\t\t| Error\n\t\t\t| ValidationError\n\t\t\t| ParseError\n\t\t\t| NotFoundError\n\t\t\t| InternalServerError\n\t) =>\n\t\t(this.handleError = this.config.aot\n\t\t\t? composeErrorHandler(this)\n\t\t\t: createDynamicErrorHandler(this))(context, error)\n\n\tprivate outerErrorHandler = (error: Error) =>\n\t\tnew Response(error.message || error.name || 'Error', {\n\t\t\t// @ts-ignore\n\t\t\tstatus: error?.status ?? 500\n\t\t})\n\n\t/**\n\t * ### listen\n\t * Assign current instance to port and start serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(8080)\n\t * ```\n\t */\n\tlisten = (\n\t\toptions: string | number | Partial<Serve>,\n\t\tcallback?: ListenCallback\n\t) => {\n\t\tif (!Bun) throw new Error('Bun to run')\n\n\t\tthis.compile()\n\n\t\tif (typeof options === 'string') {\n\t\t\toptions = +options.trim()\n\n\t\t\tif (Number.isNaN(options))\n\t\t\t\tthrow new Error('Port must be a numeric value')\n\t\t}\n\n\t\tconst fetch = this.fetch\n\n\t\tconst serve =\n\t\t\ttypeof options === 'object'\n\t\t\t\t? ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\t...this.config.serve,\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t...this.config.websocket,\n\t\t\t\t\t\t\t...websocket\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t  } as Serve)\n\t\t\t\t: ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\t...this.config.serve,\n\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t...this.config.websocket,\n\t\t\t\t\t\t\t...websocket\n\t\t\t\t\t\t},\n\t\t\t\t\t\tport: options,\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t  } as Serve)\n\n\t\tif (typeof Bun === 'undefined')\n\t\t\tthrow new Error(\n\t\t\t\t'.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch'\n\t\t\t)\n\n\t\tthis.server = Bun?.serve(serve)\n\n\t\tif (this.event.start.length) {\n\t\t\t;(async () => {\n\t\t\t\tconst context = Object.assign(this.decorators, {\n\t\t\t\t\tstore: this.store,\n\t\t\t\t\tapp: this\n\t\t\t\t})\n\n\t\t\t\tfor (let i = 0; i < this.event.transform.length; i++) {\n\t\t\t\t\tconst operation = this.event.transform[i](context)\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (this.event.transform[i].$elysia === 'derive') {\n\t\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < this.event.start.length; i++)\n\t\t\t\t\tthis.event.start[i](context)\n\t\t\t})()\n\t\t}\n\n\t\tif (callback) callback(this.server!)\n\n\t\tPromise.all(this.lazyLoadModules).then(() => {\n\t\t\tBun?.gc(false)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop\n\t * Stop server from serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(8080)\n\t *\n\t * // Sometime later\n\t * app.stop()\n\t * ```\n\t */\n\tstop = async () => {\n\t\tif (!this.server)\n\t\t\tthrow new Error(\n\t\t\t\t\"Elysia isn't running. Call `app.listen` to start the server.\"\n\t\t\t)\n\n\t\tthis.server.stop()\n\n\t\tif (this.event.stop.length) {\n\t\t\t;(async () => {\n\t\t\t\tconst context = Object.assign(this.decorators, {\n\t\t\t\t\tstore: this.store,\n\t\t\t\t\tapp: this\n\t\t\t\t})\n\n\t\t\t\tfor (let i = 0; i < this.event.transform.length; i++) {\n\t\t\t\t\tconst operation = this.event.transform[i](context)\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (this.event.transform[i].$elysia === 'derive') {\n\t\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\t\tthis.event.stop[i](context)\n\t\t\t})()\n\t\t}\n\t}\n\n\t/**\n\t * Wait until all lazy loaded modules all load is fully\n\t */\n\tget modules() {\n\t\treturn Promise.all(this.lazyLoadModules)\n\t}\n}\n\nexport { Elysia }\n\nexport { mapResponse, mapCompactResponse, mapEarlyResponse } from './handler'\nexport { t } from './type-system'\nexport { Cookie, type CookieOptions } from './cookie'\n\nexport {\n\tgetSchemaValidator,\n\tmergeDeep,\n\tmergeHook,\n\tmergeObjectArray,\n\tgetResponseSchemaValidator\n} from './utils'\n\nexport {\n\tParseError,\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tInvalidCookieSignature\n} from './error'\n\nexport type { Context, PreContext } from './context'\n\nexport type {\n\tElysiaConfig,\n\tDecoratorBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tErrorHandler,\n\tAfterHandler,\n\tLifeCycleEvent,\n\tTraceEvent,\n\tLifeCycleStore,\n\tMaybePromise,\n\tListenCallback,\n\tUnwrapSchema,\n\tTraceHandler,\n\tTraceProcess,\n\tTraceReporter,\n\tTraceStream\n} from './types'\n\nexport type { Static } from '@sinclair/typebox'\n"
  ],
  "mappings": "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",
  "debugId": "F9D4474E540FF28C64756e2164756e21",
  "names": []
}