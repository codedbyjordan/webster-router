import{parse as e}from"fast-querystring";import{signCookie as t}from"./utils";import{mapEarlyResponse as r,mapResponse as s,mapCompactResponse as n,isNotEmpty as o}from"./handler";import{NotFoundError as a,ValidationError as i,InternalServerError as c,ERROR_CODE as l}from"./error";import{parseCookie as f}from"./cookie";let u=new Headers().toJSON,d=RegExp(" (\\w+) = context","g"),p={value:0},m=({hasTrace:e,hasTraceSet:t=!1,addFn:r,condition:s={}})=>(r(`
const reporter = getReporter()
`),e)?(e,{name:n,attribute:o="",unit:a=0}={})=>{let i=e.indexOf("."),c=-1===i;if("request"!==e&&"response"!==e&&!s[c?e:e.slice(0,i)])return()=>{t&&"afterHandle"===e&&(r("reporter.emit('event',{id,event:'exit',type:'begin',time:0})"),r(`
await traceDone
`))};c?n||=e:n||="anonymous",r("\n"+`reporter.emit('event', { 
					id,
					event: '${e}',
					type: 'begin',
					name: '${n}',
					time: performance.now(),
					${c?`unit: ${a},`:""}
					${o}
				})`.replace(/(\t| |\n)/g,"")+"\n");let l=!1;return()=>{!l&&(l=!0,r("\n"+`reporter.emit('event', {
							id,
							event: '${e}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g,"")+"\n"),t&&"afterHandle"===e&&(r(`
reporter.emit('event',{id,event:'exit',type:'begin',time:0})
`),r("\nawait traceDone\n")))}}:()=>()=>{};export const hasReturn=e=>{let t=e.indexOf(")");return(// Is direct arrow function return eg. () => 1
61===e.charCodeAt(t+2)&&123!==e.charCodeAt(t+5)||e.includes("return"))};let h=(e,{injectResponse:t=""}={})=>({composeValidation:(t,r=`c.${t}`)=>e?`c.set.status = 400; throw new ValidationError(
'${t}',
${t},
${r}
)`:`c.set.status = 400; return new ValidationError(
	'${t}',
	${t},
	${r}
).toResponse(c.set.headers)`,composeResponseValidation:(r="r")=>{let s=e?`throw new ValidationError(
'response',
response[c.set.status],
${r}
)`:`return new ValidationError(
'response',
response[c.set.status],
${r}
).toResponse(c.set.headers)`;return`
${t}
		if(response[c.set.status]?.Check(${r}) === false) { 
	if(!(response instanceof Error))
		${s}
}
`}});export const isFnUse=(e,t)=>{t=(t=t.trimStart()).replaceAll(/^async /g,""),/^(\w+)\(/g.test(t)&&(t=t.slice(t.indexOf("(")));let r=// CharCode 40 is '('
40===t.charCodeAt(0)||t.startsWith("function")?t.slice(t.indexOf("(")+1,t.indexOf(")")):t.slice(0,t.indexOf("=")-1);if(""===r)return!1;let s=123===r.charCodeAt(0)?r.indexOf("..."):-1;// Using object destructuring
if(123===r.charCodeAt(0)){// Since Function already format the code, styling is enforced
if(r.includes(e))return!0;if(-1===s)return!1}// Match dot notation and named access
if(t.match(RegExp(`${r}(.${e}|\\["${e}"\\])`)))return!0;let n=-1!==s?r.slice(s+3,r.indexOf(" ",s+3)):void 0;if(t.match(RegExp(`${n}(.${e}|\\["${e}"\\])`)))return!0;let o=[r];for(let e of(n&&o.push(n),t.matchAll(d)))o.push(e[1]);let a=RegExp(`{.*?} = (${o.join("|")})`,"g");for(let[r]of t.matchAll(a))if(r.includes(`{ ${e}`)||r.includes(`, ${e}`))return!0;return!1};let y=e=>{e=(e=e.trimStart()).replaceAll(/^async /g,""),/^(\w+)\(/g.test(e)&&(e=e.slice(e.indexOf("(")));let t=// CharCode 40 is '('
40===e.charCodeAt(0)||e.startsWith("function")?e.slice(e.indexOf("(")+1,e.indexOf(")")):e.slice(0,e.indexOf("=")-1);if(""===t)return!1;let r=123===t.charCodeAt(0)?t.indexOf("..."):-1,s=-1!==r?t.slice(r+3,t.indexOf(" ",r+3)):void 0,n=[t];for(let t of(s&&n.push(s),e.matchAll(d)))n.push(t[1]);for(let t of n)if(RegExp(`\\b\\w+\\([^)]*\\b${t}\\b[^)]*\\)`).test(e))return!0;let o=RegExp(`{.*?} = (${n.join("|")})`,"g");for(let[t]of e.matchAll(o))if(RegExp(`\\b\\w+\\([^)]*\\b${t}\\b[^)]*\\)`).test(e))return!0;return!1},$=Symbol.for("TypeBox.Kind");export const hasType=(e,t)=>{if(t){if($ in t&&t[$]===e)return!0;if("object"===t.type){let r=t.properties;for(let t of Object.keys(r)){let s=r[t];if("object"===s.type){if(hasType(e,s))return!0}else if(s.anyOf){for(let t=0;t<s.anyOf.length;t++)if(hasType(e,s.anyOf[t]))return!0}if($ in s&&s[$]===e)return!0}return!1}return t.properties&&$ in t.properties&&t.properties[$]===e}};let g=Symbol.for("TypeBox.Transform");export const hasTransform=e=>{if(e){if("object"===e.type&&e.properties){let t=e.properties;for(let e of Object.keys(t)){let r=t[e];if("object"===r.type){if(hasTransform(r))return!0}else if(r.anyOf){for(let e=0;e<r.anyOf.length;e++)if(hasTransform(r.anyOf[e]))return!0}let s=g in r;if(s)return!0}return!1}return g in e||e.properties&&g in e.properties}};/**
 * This function will return the type of unioned if all unioned type is the same.
 * It's intent to use for content-type mapping only
 *
 * ```ts
 * t.Union([
 *   t.Object({
 *     password: t.String()
 *   }),
 *   t.Object({
 *     token: t.String()
 *   })
 * ])
 * ```
 */let b=e=>{if(!e)return;// @ts-ignore
let t=e?.schema;if(t&&"anyOf"in t){let e=!1,r=t.anyOf[0].type;for(let s of t.anyOf)if(s.type!==r){e=!0;break}if(!e)return r}// @ts-ignore
return e.schema?.type},k=/(?:return|=>) \S*\(/g;export const isAsync=e=>"AsyncFunction"===e.constructor.name||e.toString().match(k);export const composeHandler=({path:d,method:$,hooks:g,validator:k,handler:w,handleError:x,definitions:q,schema:R,onRequest:H,config:v,getReporter:E})=>{let A=v.forceErrorEncapsulation||g.error.length>0||"undefined"==typeof Bun||g.onResponse.length>0||!!g.trace.length,O=g.onResponse.length?`
;(async () => {${g.onResponse.map((e,t)=>`await res${t}(c)`).join(";")}})();
`:"",F=g.trace.map(e=>e.toString()),C=!1;if(y(w.toString())&&(C=!0),!C){for(let[e,t]of Object.entries(g))if(Array.isArray(t)&&t.length&&["parse","transform","beforeHandle","afterHandle","onResponse"].includes(e)){for(let e of t)if("function"==typeof e&&y(e.toString())){C=!0;break}if(C)break}}let T={parse:F.some(e=>isFnUse("parse",e)),transform:F.some(e=>isFnUse("transform",e)),handle:F.some(e=>isFnUse("handle",e)),beforeHandle:F.some(e=>isFnUse("beforeHandle",e)),afterHandle:F.some(e=>isFnUse("afterHandle",e)),error:A||F.some(e=>isFnUse("error",e))},j=g.trace.length>0,S="",U=k||"GET"!==$&&"HEAD"!==$?[w,...g.transform,...g.beforeHandle,...g.afterHandle].map(e=>e.toString()):[],D="GET"!==$&&"HEAD"!==$&&(C||"none"!==g.type&&(!!k.body||!!g.type||U.some(e=>isFnUse("body",e)))),V=C||k.headers||U.some(e=>isFnUse("headers",e)),I=C||k.cookie||U.some(e=>isFnUse("cookie",e)),N=k?.cookie?.schema,_="";if(N?.sign){if(!N.secrets)throw Error(`t.Cookie required secret which is not set in (${$}) ${d}.`);let e=N.secrets?"string"==typeof N.secrets?N.secrets:N.secrets[0]:void 0;if(_+=`const _setCookie = c.set.cookie
		if(_setCookie) {`,!0===N.sign)// encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\n`
_+=`for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${e}')
			}`;else for(let t of N.sign)// if (!(name in cookieMeta.properties)) continue
_+=`if(_setCookie['${t}']?.value) { c.set.cookie['${t}'].value = await signCookie(_setCookie['${t}'].value, '${e}') }
`;_+="}\n"}let{composeValidation:B,composeResponseValidation:P}=h(A);if(V&&// This function is Bun specific
// @ts-ignore
(S+=u?`c.headers = c.request.headers.toJSON()
`:`c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`),I){let e=(e,t)=>{// @ts-ignore
let r=N?.[e]??t;return r?"string"==typeof r?`${e}: '${r}',`:r instanceof Date?`${e}: new Date(${r.getTime()}),`:`${e}: ${r},`:"string"==typeof t?`${e}: "${t}",`:`${e}: ${t},`},t=N?`{
			secret: ${void 0!==N.secrets?"string"==typeof N.secrets?`'${N.secrets}'`:"["+N.secrets.reduce((e,t)=>e+`'${t}',`,"")+"]":"undefined"},
			sign: ${!0===N.sign||(void 0!==N.sign?"["+N.sign.reduce((e,t)=>e+`'${t}',`,"")+"]":"undefined")},
			${e("domain")}
			${e("expires")}
			${e("httpOnly")}
			${e("maxAge")}
			${e("path","/")}
			${e("priority")}
			${e("sameSite")}
			${e("secure")}
		}`:"undefined";V?S+=`
c.cookie = await parseCookie(c.set, c.headers.cookie, ${t})
`:S+=`
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${t})
`}let W=C||k.query||U.some(e=>isFnUse("query",e));W&&(S+=`const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`);let G=g.trace.map(e=>e.toString()),L=G.some(e=>isFnUse("set",e)||y(e));C||g.trace.some(e=>isFnUse("set",e.toString()));let Q=L||I||U.some(e=>isFnUse("set",e))||H.some(e=>isFnUse("set",e.toString()));j&&(S+="\nconst id = c.$$requestId\n");let J=m({hasTrace:j,hasTraceSet:L,condition:T,addFn:e=>{S+=e}});if(S+=A?"try {\n":"",j){// fnLiteral += `\nconst traceDone = new Promise(r => r())\n`
S+=`
const traceDone = Promise.all([`;for(let e=0;e<g.trace.length;e++)S+=`new Promise(r => { reporter.once(\`res\${id}.${e}\`, r) }),`;S+=`])
`}let K=I||D||L||isAsync(w)||g.parse.length>0||g.afterHandle.some(isAsync)||g.beforeHandle.some(isAsync)||g.transform.some(isAsync),z=J("parse",{unit:g.parse.length});if(D){let e=b(k?.body);if(g.type&&!Array.isArray(g.type)){if(g.type)switch(g.type){case"json":case"application/json":S+=`c.body = await c.request.json()
`;break;case"text":case"text/plain":S+=`c.body = await c.request.text()
`;break;case"urlencoded":case"application/x-www-form-urlencoded":S+=`c.body = parseQuery(await c.request.text())
`;break;case"arrayBuffer":case"application/octet-stream":S+=`c.body = await c.request.arrayBuffer()
`;break;case"formdata":case"multipart/form-data":S+=`c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`}g.parse.length&&(S+="}}")}else{let t=(()=>{if(g.parse.length&&e&&!Array.isArray(g.type)){// @ts-ignore
let t=k?.body?.schema;if("object"===e&&(hasType("File",t)||hasType("Files",t)))return`c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`}})();if(t)S+=t;else{if(S+="\n"+(V?"let contentType = c.headers['content-type']":"let contentType = c.request.headers.get('content-type')")+`
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)
`,g.parse.length){S+=`let used = false
`;let e=J("parse",{unit:g.parse.length});for(let e=0;e<g.parse.length;e++){let t=J("parse.unit",{name:g.parse[e].name}),r=`bo${e}`;0!==e&&(S+=`if(!used) {
`),S+=`let ${r} = parse[${e}](c, contentType)
if(${r} instanceof Promise) ${r} = await ${r}
if(${r} !== undefined) { c.body = ${r}; used = true }
`,t(),0!==e&&(S+="}")}e()}g.parse.length&&(S+="if (!used)"),S+=`
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}
}
`}}S+="\n"}if(z(),g?.transform){let e=J("transform",{unit:g.transform.length});for(let e=0;e<g.transform.length;e++){let t=g.transform[e],r=J("transform.unit",{name:t.name});"derive"===t.$elysia?S+=isAsync(g.transform[e])?`Object.assign(c, await transform[${e}](c));`:`Object.assign(c, transform[${e}](c));`:S+=isAsync(g.transform[e])?`await transform[${e}](c);`:`transform[${e}](c);`,r()}e()}if(k&&(S+="\n",k.headers&&(S+=`if(headers.Check(c.headers) === false) {
				${B("headers")}
			}`,hasTransform(k.headers.schema)&&(S+=`
c.headers = headers.Decode(c.headers)
`)),k.params&&(S+=`if(params.Check(c.params) === false) {
				${B("params")}
			}`,hasTransform(k.params.schema)&&(S+=`
c.params = params.Decode(c.params)
`)),k.query&&(S+=`if(query.Check(c.query) === false) {
				${B("query")} 
			}`,hasTransform(k.query.schema)&&// Decode doesn't work with Object.create(null)
(S+=`
c.query = query.Decode(Object.assign({}, c.query))
`)),k.body&&(S+=`if(body.Check(c.body) === false) { 
				${B("body")}
			}`,hasTransform(k.body.schema)&&(S+=`
c.body = body.Decode(c.body)
`)),o(k.cookie?.schema.properties??{})&&(S+=`const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${B("cookie","cookieValue")}
			}`,hasTransform(k.cookie.schema)&&(S+=`
c.cookie = params.Decode(c.cookie)
`))),g?.beforeHandle){let e=J("beforeHandle",{unit:g.beforeHandle.length});for(let e=0;e<g.beforeHandle.length;e++){let t=J("beforeHandle.unit",{name:g.beforeHandle[e].name}),r=`be${e}`,s=hasReturn(g.beforeHandle[e].toString());if(s){S+=isAsync(g.beforeHandle[e])?`let ${r} = await beforeHandle[${e}](c);
`:`let ${r} = beforeHandle[${e}](c);
`,t(),S+=`if(${r} !== undefined) {
`;let s=J("afterHandle",{unit:g.transform.length});if(g.afterHandle)for(let e=0;e<g.afterHandle.length;e++){let t=hasReturn(g.afterHandle[e].toString()),s=J("afterHandle.unit",{name:g.afterHandle[e].name});if(S+=`c.response = ${r}
`,t){let t=`af${e}`;S+=(isAsync(g.afterHandle[e])?`const ${t} = await afterHandle[${e}](c);
`:`const ${t} = afterHandle[${e}](c);
`)+`if(${t} !== undefined) { c.response = ${r} = ${t} }
`}else S+=isAsync(g.afterHandle[e])?`await afterHandle[${e}](c, ${r});
`:`afterHandle[${e}](c, ${r});
`;s()}s(),k.response&&(S+=P(r)),S+=_+`return mapEarlyResponse(${r}, c.set)}
`}else S+=isAsync(g.beforeHandle[e])?`await beforeHandle[${e}](c);
`:`beforeHandle[${e}](c);
`,t()}e()}if(g?.afterHandle.length){let e=J("handle",{name:w.name});g.afterHandle.length?S+=isAsync(w)?`let r = c.response = await handler(c);
`:`let r = c.response = handler(c);
`:S+=isAsync(w)?`let r = await handler(c);
`:`let r = handler(c);
`,e();let t=J("afterHandle",{unit:g.afterHandle.length});for(let e=0;e<g.afterHandle.length;e++){let r=`af${e}`,s=hasReturn(g.afterHandle[e].toString()),n=J("afterHandle.unit",{name:g.afterHandle[e].name});s?(k.response?S+=isAsync(g.afterHandle[e])?`let ${r} = await afterHandle[${e}](c)
`:`let ${r} = afterHandle[${e}](c)
`:S+=isAsync(g.afterHandle[e])?`let ${r} = mapEarlyResponse(await afterHandle[${e}](c), c.set)
`:`let ${r} = mapEarlyResponse(afterHandle[${e}](c), c.set)
`,n(),k.response?(S+=`if(${r} !== undefined) {`+P(r)+`${r} = mapEarlyResponse(${r}, c.set)
`+`if(${r}) {`,t(),L&&(S+=`${r} = mapEarlyResponse(${r}, c.set)
`),S+=`return ${r} } }`):(S+=`if(${r}) {`,t(),S+=`return ${r}}
`)):(S+=isAsync(g.afterHandle[e])?`await afterHandle[${e}](c)
`:`afterHandle[${e}](c)
`,n())}t(),S+=`r = c.response
`,k.response&&(S+=P()),S+=_,Q?S+=`return mapResponse(r, c.set)
`:S+=`return mapCompactResponse(r)
`}else{let e=J("handle",{name:w.name});if(k.response)S+=isAsync(w)?`const r = await handler(c);
`:`const r = handler(c);
`,e(),S+=P(),J("afterHandle")(),S+=_,Q?S+=`return mapResponse(r, c.set)
`:S+=`return mapCompactResponse(r)
`;else if(T.handle||I)S+=isAsync(w)?`let r = await handler(c);
`:`let r = handler(c);
`,e(),J("afterHandle")(),S+=_,Q?S+=`return mapResponse(r, c.set)
`:S+=`return mapCompactResponse(r)
`;else{e();let t=isAsync(w)?"await handler(c) ":"handler(c)";J("afterHandle")(),Q?S+=`return mapResponse(${t}, c.set)
`:S+=`return mapCompactResponse(${t})
`}}if(A||O){S+=`
} catch(error) {`,K||(S+="return (async () => {"),S+=`const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;let e=J("error",{unit:g.error.length});if(g.error.length){S+=`
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;for(let e=0;e<g.error.length;e++){let t=`er${e}`,r=J("error.unit",{name:g.error[e].name});S+=`
let ${t} = handleErrors[${e}](c)
`,isAsync(g.error[e])&&(S+=`if (${t} instanceof Promise) ${t} = await ${t}
`),r(),S+=`${t} = mapEarlyResponse(${t}, set)
if (${t}) {return ${t} }
`}}if(e(),S+=`return handleError(c, error)

`,K||(S+="})()"),S+="}",O||j){S+=" finally { ";let e=J("response",{unit:g.onResponse.length});S+=O,e(),S+="}"}}S=`const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${g.onResponse.length?`const ${g.onResponse.map((e,t)=>`res${t} = onResponse[${t}]`).join(",")}`:""}

	return ${K?"async":""} function(c) {
		${R&&q?"c.schema = schema; c.defs = definitions;":""}
		${S}
	}`;let M=Function("hooks",S);return M({handler:w,hooks:g,validator:k,handleError:x,utils:{mapResponse:s,mapCompactResponse:n,mapEarlyResponse:r,parseQuery:e},error:{NotFoundError:a,ValidationError:i,InternalServerError:c},schema:R,definitions:q,ERROR_CODE:l,getReporter:E,requestId:p,parseCookie:f,signCookie:t})};export const composeGeneralHandler=e=>{let t="",s="";// @ts-ignore
for(let r of Object.keys(e.decorators))t+=`,${r}: app.decorators.${r}`;// @ts-ignore
let{router:n,staticRouter:o}=e,i=e.event.trace.length>0,c=`
	const route = find(request.method, path) ${n.root.ALL?'?? find("ALL", path)':""}
	if (route === null)
		return ${e.event.error.length?"app.handleError(ctx, notFound)":`new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`,l="";for(let[e,{code:t,all:r}]of Object.entries(o.map))l+=`case '${e}':
switch(request.method) {
${t}
${r??"default: break map"}}

`;let f=e.event.request.some(isAsync);s+=`const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter
	} = data

	const notFound = new NotFoundError()

	${e.event.request.length?"const onRequest = app.event.request":""}

	${o.variables}

	const find = router.find.bind(router)
	const findWs = wsRouter.find.bind(wsRouter)
	const handleError = app.handleError.bind(this)

	${e.event.error.length?"":"const error404 = notFound.message.toString()"}

	return ${f?"async":""} function map(request) {
	`;let u=e.event.trace.map(e=>e.toString()),d=m({hasTrace:i,hasTraceSet:e.event.trace.some(e=>{let t=e.toString();return isFnUse("set",t)||y(t)}),condition:{request:u.some(e=>isFnUse("request",e)||y(e))},addFn:e=>{s+=e}});if(e.event.request.length){s+=`
			${i?"const id = +requestId.value++":""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${i?",$$requestId: +id":""}
				${t}
			}
		`;let r=d("request",{attribute:"ctx",unit:e.event.request.length});s+=`try {
`;for(let t=0;t<e.event.request.length;t++){let r=e.event.request[t],n=hasReturn(r.toString()),o=isAsync(r),a=d("request.unit",{name:e.event.request[t].name}),i=`re${t}`;n?(s+=`const ${i} = mapEarlyResponse(
					${o?"await":""} onRequest[${t}](ctx),
					ctx.set
				)
`,a(),s+=`if(${i}) return ${i}
`):(s+=`${o?"await":""} onRequest[${t}](ctx)
`,a())}s+=`} catch (error) {
			return app.handleError(ctx, error)
		}`,r(),s+=`
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`}else s+=`
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${i?"const id = +requestId.value++":""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${i?",$$requestId: id":""}
			${t}
		}`,d("request",{unit:e.event.request.length,attribute:u.some(e=>isFnUse("context",e))||u.some(e=>isFnUse("store",e))||u.some(e=>isFnUse("set",e))?"ctx":""})();// @ts-ignore
let h=e.wsPaths,$=e.wsRouter;if(Object.keys(h).length||$.history.length){for(let[e,t]of(s+=`
			if(request.method === 'GET') {
				switch(path) {`,Object.entries(h)))s+=`
					case '${e}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${t}(ctx)
							
						break`;s+=`
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = findWs('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`}// console.log(fnLiteral)
// console.log(app.event)
return s+=`
		map: switch(path) {
			${l}

			default:
				break
		}

		${c}
	}`,// @ts-ignore
e.handleError=composeErrorHandler(e),Function("data",s)({app:e,mapEarlyResponse:r,NotFoundError:a,// @ts-ignore
getReporter:()=>e.reporter,requestId:p})};export const composeErrorHandler=e=>{let t=`const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${e.event.error.find(isAsync)?"async":""} function(context, error) {
		const { set } = context

		context.code = error.code
		context.error = error
		`;for(let r=0;r<e.event.error.length;r++){let s=e.event.error[r],n=`${isAsync(s)?"await ":""}onError[${r}](context)`;hasReturn(s.toString())?t+=`const r${r} = ${n}; if(r${r} !== undefined) {
				if(set.status === 200) set.status = error.status
				return mapResponse(r${r}, set)
			}
`:t+=n+"\n"}return Function("inject",t+=`if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`)({app:e,mapResponse:s,ERROR_CODE:l})};